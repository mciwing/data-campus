{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":""},{"location":"data/","title":"Home","text":""},{"location":"data/#daten","title":"Daten","text":"Ihr Browser unterst\u00fctzt das Video-Tag nicht.               Video erstellt mit Nano Banana 3 Pro, Grok &amp; ElevenLabs               \ud83d\udd07"},{"location":"data/#willkommen-im-modul-daten","title":"Willkommen im Modul <code>Daten</code>! \ud83d\udc4b","text":"<p>In diesem Kurs lernst du die Grundlagen von Daten \u2013 von der Erfassung \u00fcber die Verarbeitung bis zur Speicherung. Du verstehst, wie Daten entstehen, wie Computer sie verarbeiten und wie sie dauerhaft gespeichert werden.</p>"},{"location":"data/#kursubersicht","title":"Kurs\u00fcbersicht","text":"<p>Der Kurs ist in vier aufeinander aufbauende Kapitel strukturiert:</p> <ul> <li> <p> Einf\u00fchrung</p> <ul> <li>Daten vs. Information vs. Wissen</li> <li>Big Data vs. klassische Daten</li> <li>Qualitative vs. quantitative Daten</li> <li>Attribute und Skalenniveaus</li> </ul> </li> <li> <p> Datenerfassung</p> <ul> <li>Biologische vs. technische Datenerfassung</li> <li>Messkette</li> </ul> </li> <li> <p> Datenverarbeitung</p> <ul> <li>Bin\u00e4rsystem und Bits</li> <li>Zahlensysteme (Bin\u00e4r, Oktal, Hexadezimal)</li> <li>Festkommaarithmetik</li> <li>Negative Zahlen in Bin\u00e4rform</li> </ul> </li> <li> <p> Datenspeicherung</p> <ul> <li>Speichern von Bildern und Texten</li> <li>Datentypen</li> <li>Speichermedien (HDD, SSD, Cloud)</li> </ul> </li> </ul>"},{"location":"data/#lernziele","title":"Lernziele","text":"<p>Nach Abschluss dieses Moduls kannst du:</p> <ul> <li> Den Unterschied zwischen Daten, Information und Wissen erkl\u00e4ren</li> <li> Verstehen, wie Daten erfasst und digitalisiert werden</li> <li> Im Bin\u00e4r-, Oktal- und Hexadezimalsystem rechnen</li> <li> Die wichtigsten Speichermedien und ihre Eigenschaften benennen</li> <li> Den Lebenszyklus von Daten nachvollziehen</li> </ul> <p>Bereit, in die Welt der Daten einzutauchen? Starte mit der Einf\u00fchrung und arbeite dich durch die vier Kapitel!</p> Los geht's! \ud83d\ude80 <p>Ressourcen</p> <p>Dieser Kurs basiert auf folgenden Quellen:</p> <ul> <li>Datenbanken - Andreas de Vries; FH S\u00fcdwestfalen</li> <li>Datenbanken 1 - Nikolaus Augsten; Universit\u00e4t Salzburg</li> </ul> <p>Zur Ausarbeitung wurden generative Tools unterst\u00fctzend eingesetzt.</p>"},{"location":"data/datenerfassung/","title":"Datenerfassung","text":""},{"location":"data/datenerfassung/#datenerfassung","title":"Datenerfassung","text":"<p>Im vorherigen Kapitel haben wir uns mit Daten auf semantischer Ebene besch\u00e4ftigt \u2013 mit ihrer Bedeutung, Struktur und Klassifikation. Wir haben gelernt, was Daten sind, wie sie sich von Information und Wissen unterscheiden, und welche verschiedenen Arten von Daten es gibt (qualitativ, quantitativ, nominal, ordinal, ...).</p> <p>Doch wie entstehen Daten \u00fcberhaupt? Woher kommen die 23,5\u00b0C, die wir als Temperaturmesswert ablesen? Wie wird aus einem physikalischen Reiz (Licht, Schall, Druck) eine digitale Information, mit der ein Computer arbeiten kann?</p> <p>In diesem Kapitel wechseln wir die Perspektive und betrachten den technischen Prozess der Datenerfassung \u2013 die erste Stufe im Lebenszyklus von Daten. Wir schauen uns an, wie biologische Systeme (der Mensch) und technische Systeme (Sensoren, Computer) Daten erfassen \u2013 und werden dabei erstaunliche Parallelen entdecken.</p>"},{"location":"data/datenerfassung/#wie-erfassen-wir-menschen-daten","title":"Wie erfassen wir Menschen Daten?","text":"<p>Ein wichtiges Merkmal aller Lebewesen ist es, Daten aus der Umwelt zu erfassen, sie als Information zu verarbeiten und daraus Aktionen abzuleiten.</p> <p>Dieser Prozess l\u00e4uft bei uns Menschen \u00fcber unsere Sinnesorgane ab \u2013 sie sind unsere Sensoren zur Umwelt. Unsere Umgebung sendet fortlaufend Reize aus \u2013 in Form von Licht, Schall, Druck, Geruch oder chemischen Stoffen. Diese Reize werden von den Sinneszellen aufgenommen, in elektrische Signale umgewandelt und anschlie\u00dfend vom Gehirn verarbeitet.</p> <pre><code>flowchart LR\n    A[Daten #40;Reize#41;]:::peach --&gt; B(Sensoren / Sinnesorgane):::teal\n    B --&gt; C[Informationsverarbeitung #40;Nervensystem, Gehirn#41;]:::peach\n    C --&gt; D(Aktoren / Muskeln):::teal\n    D --&gt; E[Aktion #40;Bewegung, Sprache, Reaktion#41;]:::peach\n\n    classDef peach fill:#FFB482aa,stroke:#333,stroke-width:1px;\n    classDef teal fill:#009485aa,stroke:#333,stroke-width:1px;</code></pre> <p>Die erfassten Daten liegen in ganz unterschiedlichen physikalischen Formen vor:</p> <ul> <li>Elektromagnetische Signale \u2192 Licht, Farbe, W\u00e4rme</li> <li>Akustische Signale \u2192 Sprache, Musik</li> <li>Mechanische Signale \u2192 Druck, Vibration, Ber\u00fchrung</li> <li>Chemische Signale \u2192 Geschmack, Geruch</li> </ul> <p>Das Gehirn filtert diese Rohdaten, reduziert sie auf das Wesentliche und formt daraus Information, die bewusst wahrgenommen werden kann (vgl. Abschnitt Von Daten zum Wissen).</p> Datenmenge Sinnesorgange (nach Zimmermann, 1993) <p>Beim Menschen geschieht dieser Prozess der Datenverarbeitung meist unbewusst. Von den ca. 11,2 Mbit/s,  die unsere Sinnesorgane aufnehmen, gelangen nur etwa 77 Bits/s ins Bewusstsein  (\u2248 0,01 \u2030).</p> <p></p> Sinnessystem Datenrate [bit/s] Bewusstsein [bit/s] Augen 10 000 000 40 Ohren 100 000 30 Haut 1 000 000 5 Geschmack 1 000 1 Geruch 100 000 1 Gesamt 11 201 000 77 <p></p> <p></p>     Quelle: nach Zimmermann 1993  <p></p> <p>An einem Tag mit 16 Stunden Helligkeit ergibt sich eine Datenmenge von ~72 GB alleine durch das menschliche Auge. Bewusst wahrgenommen werden allerdings nur ~288 kB.</p> <p>Zum Vergleich: die gesch\u00e4tzte Speicherkapazit\u00e4t unseres Gehirns betr\u00e4gt ~60 TB  </p> Reflexion <p>Unser Gehirn agiert wie ein intelligentes Filtersystem \u2013 es verwirft 99,99 % aller Daten. Auch in der Informatik ist das Ziel, relevante Informationen aus gro\u00dfen Datenmengen zu extrahieren \u2013 ein Konzept, das der biologischen Wahrnehmung erstaunlich \u00e4hnelt.</p>"},{"location":"data/datenerfassung/#die-messkette","title":"Die Messkette","text":"<p>Technische Systeme funktionieren nach einem ganz \u00e4hnlichen Prinzip wie unser K\u00f6rper: Auch sie ben\u00f6tigen eine Kette von Komponenten, um reale, analoge Gr\u00f6\u00dfen in digitale Daten umzuwandeln, zu verarbeiten und daraus Aktionen abzuleiten. Diese Kette wird als Messkette  bezeichnet und kann vereinfacht wiefolgt dargestellt werden.</p> <p></p> <pre><code>flowchart LR\n    A[Messgr\u00f6\u00dfe #40;physikalisch#41;]:::peach --&gt; B(Sensor):::teal\n    B --&gt; C(Verst\u00e4rker):::peach\n    C --&gt; D(A/D-Wandler):::teal\n    D --&gt; E(Steuereinheit / Rechner):::peach\n    E --&gt; F(D/A-Wandler):::teal\n    F --&gt; G(Aktuator):::peach\n\n    classDef peach fill:#FFB482aa,stroke:#333,stroke-width:1px;\n    classDef teal fill:#009485aa,stroke:#333,stroke-width:1px;</code></pre> <ul> <li>Der Sensor ist das \"Sinnesorgan\" einer Maschine. Er ist die Schnittstelle zwischen physikalischer Welt und digitalem System. Er wandelt eine physikalische Gr\u00f6\u00dfe (z. B. Temperatur, Druck, Licht) in ein elektrisches Signal um. Da Sensorsignale oft sehr klein oder nichtlinear sind, m\u00fcssen sie im n\u00e4chsten Schritt verst\u00e4rkt werden.</li> <li>Ein Verst\u00e4rker erh\u00f6ht die Leistung des Sensorsignals und kann gleichzeitig Nichtlinearit\u00e4ten ausgleichen. Er sorgt also daf\u00fcr, dass das Signal robust und auswertbar wird.</li> <li> <p>Unsere reale Welt ist analog, aber Computer verarbeiten digitale Daten. Daher wird ein A/D-Wandler (ADC) ben\u00f6tigt, der analoge Signale in digitale Werte umwandelt.</p> Merke <p>Manche Systeme ben\u00f6tigen keinen A/D-Wandler, weil die Daten bereits digital vorliegen. Das gilt z. B. f\u00fcr Daten aus einer Datenbank (Kundenverhalten, Ums\u00e4tze) oder f\u00fcr digitale Sensoren (z. B. Inkrementalgeber, I\u00b2C-Sensoren).</p> </li> <li> <p>In der Steuereinheit findet die Datenverarbeitung statt \u2013 hier kommen Methoden der Data Science, Regelungstechnik oder Signalverarbeitung zum Einsatz. Das kann ein Computer, ein Mikrocontroller, ein FPGA oder sogar ein neuronales Netzwerk sein.</p> </li> <li>Wenn das System mit der analogen Welt interagieren soll (z. B. Anzeige, Motor, Lautsprecher), muss das digitale Signal wieder in ein analoges Signal umgewandelt werden. Dazu dient der D/A-Wandler (DAC).</li> <li>Der Aktor setzt elektrische Signale und Energie in physikalische Bewegung oder Zustands\u00e4nderung um. Er ist also das Gegenst\u00fcck zum Sensor. Beispiele sind Motoren, LEDs, Heizungen oder Roboterarme.</li> </ul>"},{"location":"data/datenerfassung/#beispiel-aus-der-praxis","title":"Beispiel aus der Praxis","text":"<p>Ein selbstfahrendes Auto nutzt eine Vielzahl von Sensoren, um seine Umgebung zu erfassen:</p> <pre><code>flowchart TB\n    subgraph Sensoren\n        A1[Kamera #40;optisch#41;]:::teal\n        A2[Lidar #40;Laser#41;]:::teal\n        A3[Radar #40;Funkwellen#41;]:::teal\n        A4[Ultraschall]:::teal\n        A5[GPS]:::teal\n        A6[IMU #40;Beschleunigung#41;]:::teal\n    end\n\n    subgraph Verarbeitung\n        B[Sensorfusion]:::peach\n        C[KI-Algorithmen]:::peach\n        D[Entscheidungssystem]:::peach\n    end\n\n    subgraph Aktoren\n        E1[Lenkung]:::teal\n        E2[Gas/Bremse]:::teal\n        E3[Beleuchtung]:::teal\n    end\n\n    A1 &amp; A2 &amp; A3 &amp; A4 &amp; A5 &amp; A6 --&gt; B\n    B --&gt; C\n    C --&gt; D\n    D --&gt; E1 &amp; E2 &amp; E3\n\n    classDef peach fill:#FFB482aa,stroke:#333,stroke-width:1px;\n    classDef teal fill:#009485aa,stroke:#333,stroke-width:1px;</code></pre> <p>Sensoren und ihre Rolle:</p> <ul> <li>Kamera: Erkennung von Fahrbahnmarkierungen, Verkehrsschildern, Fu\u00dfg\u00e4ngern</li> <li>Lidar: 3D-Abstandsmessung zur Umgebung (Punktwolke)</li> <li>Radar: Geschwindigkeit und Entfernung anderer Fahrzeuge</li> <li>Ultraschall: Nahbereichserkennung (Einparken)</li> <li>GPS + IMU: Position und Bewegung des Fahrzeugs</li> </ul> <p>Alle Daten werden fusioniert und von neuronalen Netzen analysiert, um Entscheidungen wie \u201eBremsen\", \u201eAusweichen\" oder \u201eBeschleunigen\" zu treffen.</p>"},{"location":"data/datenerfassung/#vergleich-mensch-maschine","title":"Vergleich Mensch \ud83d\udc71\ud83c\udffc \u2194 Maschine \ud83e\udd16","text":"Biologisches System Technisches System Sinnesorgane (Auge, Ohr, Haut) Sensoren Nervensystem Signalverarbeitung, Kabel Gehirn Rechner / Control Unit Muskeln Aktoren Wahrnehmung Datenauswertung Fazit <p>Sowohl biologische als auch technische Systeme funktionieren nach demselben Prinzip:</p> <p>Daten aufnehmen \u2013 verarbeiten \u2013 reagieren.</p> <p>In der Informatik nennen wir das den Prozess der Datenerfassung, der die Grundlage jeder Datenanalyse bildet.</p> Praxisaufgabe: Eigene Messkette analysieren <p>Aufgabe: W\u00e4hle ein technisches Ger\u00e4t aus deinem Alltag (z.B. Smartphone, Fitness-Tracker, Kaffeemaschine, Spielkonsole) und analysiere:</p> <ol> <li>Welche Sensoren sind verbaut?</li> <li>Welche physikalischen Gr\u00f6\u00dfen werden gemessen?</li> <li>Wie werden die Daten verarbeitet?</li> <li>Welche Aktionen werden ausgel\u00f6st?</li> <li>Wo findet A/D-Wandlung statt?</li> </ol> <p>Erstelle ein Flussdiagramm der Messkette analog zu den obigen Beispielen.</p>"},{"location":"data/datenerfassung/#zusammenfassung","title":"Zusammenfassung \ud83d\udccc","text":"<ul> <li>Datenerfassung ist ein fundamentaler Prozess, der sowohl bei biologischen als auch bei technischen Systemen stattfindet: Daten aufnehmen \u2013 verarbeiten \u2013 reagieren.</li> <li>Die Messkette ist das technische Pendant zur biologischen Datenerfassung und besteht aus: Sensor, Verst\u00e4rker, A/D Wandler, Steuereinheit, D/A Wandler und Aktor.</li> <li>Mensch und Maschine funktionieren nach vergleichbaren Prinzipien: Sinnesorgane \u2194 Sensoren, Nervensystem \u2194 Signalverarbeitung, Gehirn \u2194 Rechner, Muskeln \u2194 Aktoren.</li> <li>Die Qualit\u00e4t der Datenerfassung bestimmt die Qualit\u00e4t der nachfolgenden Verarbeitung und Analyse \u2013 \u201eGarbage in, Garbage out\".</li> <li>Verschiedene Sensortechnologien erm\u00f6glichen die Erfassung unterschiedlicher physikalischer Gr\u00f6\u00dfen: Temperatur, Druck, Licht, Schall, Beschleunigung, chemische Zusammensetzung.</li> <li>Sensorfusion kombiniert Daten aus mehreren Sensoren, um ein vollst\u00e4ndigeres und zuverl\u00e4ssigeres Bild der Realit\u00e4t zu erhalten (z.B. autonome Fahrzeuge).</li> </ul> <p>Im n\u00e4chsten Kapitel schauen wir uns an, wie diese erfassten Daten verarbeitet werden \u2013 in welcher Form Computer intern mit Daten arbeiten und warum das Bin\u00e4rsystem die Basis aller digitalen Verarbeitung ist.</p>"},{"location":"data/einfuehrung/","title":"Einf\u00fchrung","text":""},{"location":"data/einfuehrung/#einfuhrung-in-die-welt-der-daten","title":"Einf\u00fchrung in die Welt der Daten","text":"<p>Daten sind heute der Treibstoff der digitalen Welt. Ob beim Online-Shopping, bei der Navigation mit Google Maps oder beim Streamen auf Spotify - \u00fcberall werden Daten erzeugt, \u00fcbertragen und analysiert. Unternehmen treffen auf Basis von Daten Entscheidungen, Maschinen reagieren auf Messwerte, und selbst unser Smartphone lernt aus unseren Gewohnheiten.</p> <p>Ohne Daten w\u00fcrde vieles, was f\u00fcr uns selbstverst\u00e4ndlich ist, schlicht nicht funktionieren. Doch um zu verstehen, warum Daten so zentral sind, m\u00fcssen wir uns zun\u00e4chst ansehen, was Daten eigentlich sind - und wie sie sich von Information und Wissen unterscheiden.</p>"},{"location":"data/einfuehrung/#von-daten-zum-wissen","title":"Von Daten zum Wissen \ud83e\udde0","text":"<p>Daten sind zun\u00e4chst einmal Rohmaterial - einzelne, isolierte Fakten, die f\u00fcr sich genommen keine Bedeutung tragen. Erst wenn wir sie in einen Kontext setzen (Semantik), entstehen Informationen. Und wenn wir diese Informationen anwenden und verkn\u00fcpfen (Pragmatik), also Entscheidungen daraus ableiten, sprechen wir von Wissen.</p>          Bild erstellt mit Nano Banana 3 Pro      Quelle: in Anlehnung an Der Wirtschaftsinformatiker Ebene Beschreibung Beispiel Daten Einzelne, unbehandelte Fakten <code>23.5</code> Information Daten mit Bedeutung Die Temperatur im Raum 101 betr\u00e4gt 23,5 \u00b0C. Wissen Angewandte Information Wenn die Temperatur \u00fcber 23 \u00b0C liegt, soll die Klimaanlage eingeschaltet werden. <p>Dieses Prinzip begegnet uns t\u00e4glich: In einer Fitness-App werden Schritte gez\u00e4hlt (Daten), daraus wird der Kalorienverbrauch berechnet (Information) - und das Wissen daraus motiviert uns, unser Tagesziel zu erreichen (Wissen).</p> <p>Damit wird klar: Daten sind nicht Selbstzweck, sondern der Ausgangspunkt eines Verarbeitungsprozesses, der von der Erfassung bis zur Anwendung reicht.</p> Quelle: imgflip Reflexionsfrage <p>\u00dcberlege dir ein Beispiel aus deinem Alltag, bei dem du unbewusst Daten in Information oder Wissen verwandelst.</p>"},{"location":"data/einfuehrung/#wie-konnen-daten-unterschieden-werden","title":"Wie k\u00f6nnen Daten unterschieden werden?","text":"<p>Bevor wir Daten analysieren oder Modelle darauf anwenden, m\u00fcssen wir sie verstehen. Das bedeutet: Wir m\u00fcssen wissen, welche Eigenschaften die Daten haben, welche Strukturen sie aufweisen und welche Probleme sie mitbringen.</p> <p>Denn reale Daten sind selten \u201esauber\u201c:</p> <ul> <li>Sensordaten enthalten oft fehlende Werte oder Messfehler,</li> <li>Social-Media-Daten sind unstrukturiert (Text, Bild, Video),</li> <li>Finanzdaten enthalten Ausrei\u00dfer oder extreme Werte, die Analysen verzerren k\u00f6nnen.</li> </ul> <p>Ein gutes Verst\u00e4ndnis der Daten ist deshalb die Grundlage jeder erfolgreichen Datenvorverarbeitung \u2013 also der Phase, in der Daten aufbereitet, bereinigt und in ein nutzbares Format gebracht werden. Nur wer seine Daten kennt, kann sie richtig interpretieren und nutzen. In weiterer Folge betrachten wir unterschiedliche M\u00f6glichkeiten, Daten zu klassifizieren und charakterisieren. </p>"},{"location":"data/einfuehrung/#klassische-daten-vs-big-data","title":"Klassische Daten vs. Big Data","text":"<p>Wenn wir von \"Daten\" sprechen, denken viele zun\u00e4chst an Tabellen mit Zahlen und Texten - klassische Daten, wie sie in Excel oder relationalen Datenbanken gespeichert sind. Diese Daten sind meist strukturiert, leicht zu durchsuchen und stammen aus klar definierten Quellen (z. B. Kundendaten, Rechnungen, Lagerbest\u00e4nde).</p> <p>Mit dem digitalen Wandel kamen jedoch neue Formen der Datenerzeugung hinzu: Sensoren, Smartphones, soziale Netzwerke, Kameras, Maschinen. Dadurch entstanden riesige, heterogene Datenmengen - das Zeitalter der Big Data.</p> <p>Big Data wird oft durch die 3 V beschrieben:</p> <ol> <li>Volume - die Menge: Daten in gro\u00dfem Ausma\u00df vor (Terabyte- oder Petabyte-Bereich).</li> <li>Velocity - die Geschwindigkeit: Daten entstehen in enormer Geschwindigkeit, z. B. bei B\u00f6rsenkursen oder in Industrieanlagen.</li> <li>Variety - die Vielfalt: Texte, Bilder, Videos, Audiosignale, Sensordaten u.v.m. sollen verarbeitet werden.</li> </ol> Quelle: IBM Quelle: localiq.com <p>Diese Vielfalt bringt Chancen, aber auch neue Herausforderungen. W\u00e4hrend klassische Datenbanken gut geeignet sind, strukturierte Informationen zu speichern, m\u00fcssen Big-Data-Systeme unstrukturierte Daten verarbeiten, Verkn\u00fcpfungen herstellen und Muster erkennen - oft mithilfe von k\u00fcnstlicher Intelligenz.</p> Beispiel: Klassische &amp; Big Data <p>Ein Online-Shop speichert seine Bestellungen (klassische Daten) in einer Datenbank. Zus\u00e4tzlich analysiert er Social-Media-Beitr\u00e4ge, Wetterdaten und Standortinformationen (Big Data), um vorherzusagen, welche Produkte morgen besonders gefragt sein werden.</p> <p>Damit verschiebt sich der Fokus: Weg vom reinen Speichern - hin zum Verstehen und Nutzen der Daten.</p> Big Data <p>\u00dcberlege drei Situationen, in denen Unternehmen Big Data nutzen k\u00f6nnten. Schreibe zu jedem Beispiel kurz dazu, welche der drei \u201eV\u201c-Eigenschaften (Volume, Velocity, Variety) besonders relevant ist.</p> Quelle: imgflip"},{"location":"data/einfuehrung/#datenarten","title":"Datenarten","text":"<p>Ein weiteres Unterscheidungsmerkmal ist die Datenart. Um Daten sinnvoll zu verwalten, ist es hilfreich, ihre Form und Herkunft zu verstehen. Denn je nach Art ben\u00f6tigen sie unterschiedliche Speicher- und Analyseverfahren.</p> Datenart Beschreibung Beispiele Tabellarische Daten Strukturiert, in Spalten und Zeilen organisiert Excel-Tabellen, Kundendatenbanken Bilddaten Visuelle Informationen Fotos, R\u00f6ntgenbilder, Satellitenaufnahmen Audiodaten Schall- und Sprachsignale Musik, Podcasts, Maschinenkl\u00e4nge Videodaten Kombination aus Bild- und Audiospuren YouTube-Clips, \u00dcberwachungskameras Textdaten Unstrukturierte Sprache oder Schrift E-Mails, Chatverl\u00e4ufe, Tweets Sensordaten Physikalische Messwerte Temperatur, Luftfeuchtigkeit, Bewegung Beispiel: Mischform <p>In der Praxis treten oft Mischformen auf:</p> <p>Ein modernes Auto erzeugt Bilddaten (Kameras), Sensordaten (Radar, Lidar) und Textdaten (Fehlerprotokolle) \u2013 gleichzeitig und in Echtzeit.</p> <p>Dieser technologische Mix zeigt, dass der Begriff \"Daten\" weit \u00fcber Tabellen hinausgeht: Alles, was sich digital erfassen und speichern l\u00e4sst, sind Daten.</p>"},{"location":"data/einfuehrung/#qualitative-vs-quantitative-daten","title":"Qualitative vs. Quantitative Daten","text":"<p>Daten unterscheiden sich nicht nur im Inhalt, sondern auch in der Art der Darstellung.</p> <p>Qualitative (kategorische) Daten</p> <p>Eine Variable wird als qualitativ (kategorial) bezeichnet, wenn jede Beobachtung eindeutig einer bestimmten Kategorie zugeordnet werden kann. Qualitative Variablen dr\u00fccken unterschiedliche Eigenschaften oder Merkmale aus, ohne eine Gr\u00f6\u00dfe oder ein Ausma\u00df anzugeben.</p> Beispiel: Qualitative Daten <ul> <li>Geschlecht (m/w/d)</li> <li>Augenfarbe (blau, braun, gr\u00fcn)</li> <li>Nationalit\u00e4t (AT, DE, IT)</li> </ul> <p>Quantitative (numerische) Daten</p> <p>Dem gegen\u00fcber wird eine Variable als quantitativ (numerisch) bezeichnet, wenn sie das Ausma\u00df oder die Gr\u00f6\u00dfe einer Eigenschaft misst. Quantitative Variablen k\u00f6nnen in zwei Typen unterteilt werden:</p> <ul> <li>Diskrete Variablen: Die Variable kann nur eine endliche oder abz\u00e4hlbare Anzahl von Werten annehmen.</li> <li>Kontinuierliche Variablen: Die Variable kann jeden Wert innerhalb eines bestimmten Intervalls annehmen.</li> </ul> Beispiel: Qualitativ vs. Quantitativ <ul> <li>Qualitativ: Religion, Geschlecht, Wohnort</li> <li>Quantitativ \u2013 diskret: Anzahl der Bestellungen, St\u00fcckzahl</li> <li>Quantitativ \u2013 stetig: Umsatz in \u20ac, Temperatur, K\u00f6rpergr\u00f6\u00dfe</li> </ul> Hinweis <p>Nicht alle Zahlen sind automatisch quantitativ! Nur weil etwas mit Zahlen dargestellt wird, hei\u00dft das nicht automatisch, dass es eine numerische (messbare) Eigenschaft beschreibt.</p> <p>Beispiel: Eine Trikotnummer im Sport (z. B. Spieler Nummer 10) ist keine messbare Zahl. Die \"10\" steht hier nur als Bezeichner f\u00fcr eine Person, nicht f\u00fcr eine messbare Eigenschaft wie L\u00e4nge, Gewicht oder Alter.</p> <p>Das hei\u00dft: Eine Zahl ist nur dann quantitativ, wenn sie ein Messwert ist \u2013 also ein Ausma\u00df einer Eigenschaft ausdr\u00fcckt (z. B. Gewicht, Preis, Alter). Wenn sie dagegen nur zur Unterscheidung oder Kennzeichnung dient, ist sie qualitativ.</p> Qualitative und Quantiative Daten <p>Nenne zu jedem der folgenden Begriffe, ob er qualitativ oder quantitativ ist:</p> <ul> <li>Postleitzahl</li> <li>K\u00f6rpergr\u00f6\u00dfe</li> <li>Note</li> <li>Blutgruppe</li> </ul>"},{"location":"data/einfuehrung/#attributtypen","title":"Attributtypen","text":"<p>Nachdem wir qualitative und quantitative Daten unterschieden haben, betrachten wir nun feinere Abstufungen, sogenannte Skalenniveaus. Diese bestimmen, welche mathematischen Operationen erlaubt sind - z. B. ob man Mittelwerte bilden darf oder nur vergleichen kann.</p> <p>Um Daten zu strukturieren, werden sie in Attribute zerlegt - also Merkmale, die ein Objekt oder Ereignis beschreiben.</p> Beispiel: Attribute <p>F\u00fcr das Objekt Student k\u00f6nnten die Attribute Name, Matrikelnummer, Studiengang und Geburtsdatum definiert werden.</p> <p>Nicht jedes Attribut ist gleichartig. In der Statistik und Datenanalyse unterscheidet man verschiedene Skalenniveaus: kategorial (nominal oder ordinal) und metrisch/numerisch (intervallskaliert oder verh\u00e4ltnisskaliert).</p> <p>Die richtige Zuordnung ist entscheidend, da sie bestimmt, welche Analysen zul\u00e4ssig sind: Mit Nominaldaten kann man z\u00e4hlen, mit Ordinaldaten sortieren und mit Verh\u00e4ltnisskalen rechnen. Wer also Daten richtig verstehen will, muss wissen, welches Skalenniveo sie haben.</p>"},{"location":"data/einfuehrung/#nominale-attribute","title":"Nominale Attribute","text":"<p>Nominale Attribute sind Kategorien ohne nat\u00fcrliche Reihenfolge. Sie bestehen aus Namen, Symbolen oder Codes, die Gruppen kennzeichnen.</p> Beispiel: Nominal <ul> <li>Automarken: BMW, Audi, VW, Skoda, Tesla</li> <li>Haarfarbe: blond, braun, schwarz</li> <li>Beruf: Lehrer, Arzt, Programmierer</li> </ul> <p>Anhand dieser Beispiele erkennt man, dass es m\u00f6glich ist zu \u00fcberpr\u00fcfen, ob zwei Werte gleich oder ungleich sind, aber nicht, ob einer gr\u00f6\u00dfer ist. </p> Hinweis <p>Nominale Attribute k\u00f6nnen auch als Zahlen codiert werden \u2013 diese Zahlen haben aber keine rechnerische Bedeutung.</p> <p>Beispiel Automarken: Wir k\u00f6nnten f\u00fcr jede Automarke eine eindeutige Nummer vergeben und unsere Daten damit codieren. Dann w\u00e4re beispielsweise BMW = 1, Audi = 2, VW = 3 usw. Mathematisch k\u00f6nnte ich nun sagen dass 2 (Audi) gr\u00f6\u00dfer ist als 1 (BMW). Da die inhaltliche Bedeutung der Daten aber nicht ver\u00e4ndert wurde, ist diese Aussage weiterhin nicht sinnvoll.  </p> <p>Dies bedeutet nun in weiterer Folge, dass die Berechnung des arithmetischen Mittelwerts oder des Medians entweder nicht m\u00f6glich oder nicht sinnvoll ist. Einzig die Berechnung des Modus (h\u00e4ufigster Wert) f\u00fchrt zu einer matematisch und logisch sinnvollen Aussage.</p> <p>Ein Sonderfall von nominalen Attributen sind Bin\u00e4re Attribute welche nur zwei Kategorien besitzen. Diese Kategorien werden h\u00e4ufig durch die Zahlen <code>0</code> und <code>1*</code> dargestellt, wobei <code>0</code> das Fehlen und <code>1</code> das vorhandensein des Merkmals kennzeichnet. Diese bin\u00e4re Klassifikation wird in der Datenanalyse h\u00e4ufig verwendet, um einfache Variablen darzustellen.</p> Beispiel: Nominal-Bin\u00e4r <ul> <li>Raucher: Ja = 1, Nein = 0</li> <li>Test positiv = 1, negativ = 0</li> </ul>"},{"location":"data/einfuehrung/#ordinale-attribute","title":"Ordinale Attribute","text":"<p>Auf der n\u00e4chsten Stufe der Skalenniveaus befinden sich Ordinale Attribute. Diese haben eine nat\u00fcrliche Reihenfolge, aber die Abst\u00e4nde zwischen den Stufen sind nicht messbar.</p> Beispiel: Ordinal <ul> <li>Getr\u00e4nkegr\u00f6\u00dfen (klein, mittel gro\u00df)</li> <li>Zufriedenheitsbewertungen (hoch, mittel, niedrig)</li> <li>T-Shirt-Gr\u00f6\u00dfen (S, M, L, XL)</li> </ul> <p>Bei den gezeigten Beispielen erkennt man, dass eine Aussage wie \"etwas ist gr\u00f6\u00dfer/schneller/besser als\" zul\u00e4ssig ist, wenngleich man aber nicht wei\u00df, wie viel gr\u00f6\u00dfer. Dies bedeutet, dass Vergleiche (\"besser als\", \"kleiner als\") erlaubt sind, aber keine Differenz- oder Durchschnittsberechnungen. </p> <p>Daher ist es m\u00f6glich und sinnvoll, den Median und den Modus zu berechnen. Der (arithmetische) Mittelwert hingegen ist nicht sinnvoll.</p>"},{"location":"data/einfuehrung/#intervallskalierte-attribute","title":"Intervallskalierte Attribute","text":"<p>Intervallskalierte Attribute k\u00f6nnen auf einer Skala mit gleich gro\u00dfen Einheiten gemessen werden, wodurch konstante und vergleichbare Abst\u00e4nde zwischen den Werten m\u00f6glich sind. Diese Attribute besitzen eine nat\u00fcrliche Reihenfolge und k\u00f6nnen positive, null oder negative Werte annehmen.</p> <p>Das bedeutet, dass eine Rangordnung der Werte sowohl m\u00f6glich als auch sinnvoll ist und ein klares Gef\u00fchl von Zunahme oder Abnahme entlang der Skala vermittelt. Einzig der Nullpunkt ist willk\u00fcrlich gew\u00e4hlt. </p> Beispiel: Intervallskaliert <ul> <li>Temperatur in \u00b0C (0\u00b0C ist nicht \u201ekeine Temperatur\u201c)</li> <li>Kalenderjahre (das Jahr 0 ist willk\u00fcrlich gew\u00e4hlt)</li> </ul> <p>Wie bei der Ordinalskala kann man auch bei der Intervallskala feststellen, ob zwei Werte gleich sind und ob ein Wert h\u00f6her ist als eine andere. Zus\u00e4tzlich l\u00e4sst sich der Unterschied zwischen Werten sinnvoll interpretieren.</p> <p>Da jedoch der Nullpunkt willk\u00fcrlich festgelegt ist (z. B. 0\u00b0C = Gefrierpunkt von Wasser), k\u00f6nnen Verh\u00e4ltnisse (Quotienten) nicht sinnvoll interpretiert werden. So ist es z. B. nicht korrekt zu sagen, dass 20\u00b0C \"doppelt so warm\" ist wie 10\u00b0C.</p> <p>Sowohl f\u00fcr intervallskalierte Attribute als auch f\u00fcr die nachfolgenden verh\u00e4ltnisskalierten Attribute k\u00f6nnen sowohl Modus, Median als auch das arithmetische Mittel berechnet und sinnvoll interpretiert werden. </p>"},{"location":"data/einfuehrung/#verhaltnisskalierte-attribute","title":"Verh\u00e4ltnisskalierte Attribute","text":"<p>Verh\u00e4ltnisskalierte Attribute besitzen einen nat\u00fcrlichen Nullpunkt, der das vollst\u00e4ndige Fehlen des Merkmals anzeigt. Diese Eigenschaft erm\u00f6glicht es, einen Wert als ein Vielfaches eines anderen sinnvoll zu interpretieren.</p> <p>Dadurch erlauben verh\u00e4ltnisskalierte Daten eine gro\u00dfe Bandbreite mathematischer Operationen, einschlie\u00dflich aussagekr\u00e4ftiger Vergleiche sowohl von Unterschieden als auch von Verh\u00e4ltnissen zwischen den Werten.</p> Beispiel: Verh\u00e4ltnisskaliert <ul> <li>Temperatur in Kelvin</li> <li>Alter, Einkommen, Gewicht, Entfernung</li> </ul> <p>Die Verh\u00e4ltnisskala ist das h\u00f6hchste Skalenniveau in der Statistik und erlaubt alle mathematischen Operationen: Mittelwert, Median, Varianz, Verh\u00e4ltnisvergleiche usw.</p> Skalenniveaus =, \u2260 &gt;, &lt; +, \u2212 \u00d7, \u00f7            kategorial          nominal \u2713 \u2717 \u2717 \u2717 ordinal \u2713 \u2713 \u2717 \u2717            metrisch          Intervall \u2713 \u2713 \u2713 \u2717 Verh\u00e4ltnis \u2713 \u2713 \u2713 \u2713      Legende: \u2713 zul\u00e4ssig \u00b7 \u2717 nicht zul\u00e4ssig    Skalenniveaus <p>Je h\u00f6her das Skalenniveau, desto mehr Rechenoperationen sind erlaubt. Nominal \u2192 Ordinal \u2192 Intervall \u2192 Verh\u00e4ltnis</p> \u00dcbungsaufgabe: Attributtypen bestimmen <p>Bestimme f\u00fcr die folgenden Attribute den Skalenniveau-Typ und begr\u00fcnde deine Entscheidung:</p> <ul> <li>Alter</li> <li>Beruf</li> <li>Schulnote</li> <li>Temperatur in \u00b0C</li> <li>Entfernung in Metern</li> </ul>"},{"location":"data/einfuehrung/#von-der-theorie-zur-praxis","title":"Von der Theorie zur Praxis","text":"<p>Bislang haben wir Daten auf semantischer Ebene betrachtet \u2013 ihre Bedeutung, Struktur und Klassifikation. Wir wissen jetzt, was Daten sind, wie sie sich unterscheiden lassen und welche Rolle sie in der digitalen Welt spielen.</p> <p>Doch eine zentrale Frage haben wir noch nicht beantwortet: Wie entstehen Daten \u00fcberhaupt?</p> <p>Wenn wir von \u201eTemperatur: 23,5\u00b0C\" oder \u201eGeschwindigkeit: 87 km/h\" sprechen, dann wirkt das selbstverst\u00e4ndlich \u2013 aber wie wird aus einem physikalischen Ph\u00e4nomen (W\u00e4rme, Bewegung) eine messbare Zahl, mit der ein Computer arbeiten kann?</p> <p>Diese Frage f\u00fchrt uns zur n\u00e4chsten Ebene: der technischen Umsetzung. In den folgenden Kapiteln schauen wir uns an:</p> <ol> <li>Datenerfassung \u2013 Wie werden Daten aus der physikalischen Welt gewonnen? (Sensoren, Messger\u00e4te, A/D-Wandler)</li> <li>Datenverarbeitung \u2013 Wie arbeiten Computer intern mit Daten? (Bin\u00e4rsystem, Zahlensysteme)</li> <li>Datenspeicherung \u2013 Wie werden Daten dauerhaft gesichert? (RAM, SSD, HDD, Datenbanken)</li> </ol> <p>Diese drei Schritte bilden den Lebenszyklus von Daten \u2013 von der Erfassung \u00fcber die Verarbeitung bis zur Speicherung und sp\u00e4teren Analyse.</p>"},{"location":"data/einfuehrung/#zusammenfassung","title":"Zusammenfassung \ud83d\udccc","text":"<ul> <li>Daten sind Rohinformationen, die erst durch Kontext zu Information und Wissen werden.</li> <li>Big Data erweitert klassische Daten um neue Dimensionen: Menge, Geschwindigkeit und Vielfalt.</li> <li>Es gibt viele Arten von Daten - von Tabellen bis zu Videos.</li> <li>Attribute beschreiben Objekte; ihr Typ entscheidet, welche Analysen sinnvoll sind.</li> <li>Daten allein sind wertlos \u2013 entscheidend ist ihre Struktur und Nutzung.</li> <li>Daten zu verstehen ist der erste Schritt jeder Analyse.</li> <li>Attribute k\u00f6nnen qualitativ oder quantitativ sein.</li> <li>Je nach Skalenniveau (nominal, ordinal, intervall-, verh\u00e4ltnisskaliert) sind unterschiedliche Operationen erlaubt.</li> <li>Der korrekte Umgang mit Attributtypen verhindert Fehlinterpretationen in Analysen.</li> </ul> <p>Im n\u00e4chsten Kapitel beginnen wir mit der Datenerfassung und werden dabei eine faszinierende Parallele entdecken: Die Art, wie Computer Daten erfassen, \u00e4hnelt verbl\u00fcffend der Art, wie wir Menschen unsere Umwelt wahrnehmen \u2013 durch Sensoren, Signalverarbeitung und intelligente Filterung.</p>"},{"location":"data/speicherung/","title":"Speicherung","text":""},{"location":"data/speicherung/#datenspeicherung","title":"Datenspeicherung","text":"<p>Im vorherigen Kapitel haben wir gelernt, wie Computer Daten in bin\u00e4rer Form verarbeiten - als Folgen von Nullen und Einsen. Doch wie werden diese Daten dauerhaft gespeichert? Wie wird aus einem abstrakten Bitmuster ein konkretes Bild, ein Text oder eine Musikdatei? Und welche Technologien nutzen wir, um diese Daten langfristig zu sichern?</p> <p>In diesem Kapitel beantworten wir drei zentrale Fragen:</p> <ol> <li>Wie werden verschiedene Datentypen bin\u00e4r dargestellt? (Bilder und Text)</li> <li>Welche Datentypen gibt es in der Programmierung? (Primitive und komplexe Typen)</li> <li>Welche Speichertechnologien existieren? (RAM, HDD, SSD, Cloud)</li> </ol>"},{"location":"data/speicherung/#vom-bit-zur-information-wie-werden-daten-gespeichert","title":"Vom Bit zur Information - Wie werden Daten gespeichert?","text":"<p>Alle digitalen Daten - ob Zahlen, Texte, Bilder oder Videos - werden letztlich als Folge von Bits gespeichert. Die Kunst liegt darin, diese Bitfolgen so zu strukturieren und interpretieren, dass daraus sinnvolle Informationen entstehen.</p> Quelle: Harvard University <p>Wir schauen uns nun an, wie unterschiedliche Datentypen bin\u00e4r dargestellt werden.</p>"},{"location":"data/speicherung/#bilder","title":"Bilder","text":"<p>Ein digitales Bild besteht aus vielen kleinen Bildpunkten (Pixeln), die in einem Raster angeordnet sind. Jeder Pixel wird durch eine Zahlenfolge beschrieben, die seine Farbe oder Helligkeit angibt.</p> <p>Schwarz-Wei\u00df-Bilder (1 Bit pro Pixel)</p> <p>Stellen wir uns vor, wir haben ein Array von Lampen, die wir unabh\u00e4ngig voneinander ansteuern k\u00f6nnen. Es gibt zwei m\u00f6gliche Zust\u00e4nde: Lampe ein (wei\u00df) oder Lampe aus (schwarz).</p> <p>Genau so funktioniert ein Schwarz-Wei\u00df-Bild: Jeder Pixel wird durch 1 Bit beschrieben - <code>0</code> f\u00fcr schwarz, <code>1</code> f\u00fcr wei\u00df.</p> Minimalbeispiel: 1-Bit Bild <p></p> <p></p> Python Code <pre><code>import cv2\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n# Bild einlesen\nimg = cv2.imread(\"logo.svg\", cv2.IMREAD_COLOR)\nimg = cv2.cvtColor(img, cv2.COLOR_BGR2RGB)\n\n# Nur einen Farbkanal verwenden (Blau)\nimg1c = img[:, :, 2]\n\n# Schwellwert: alles &lt; 128 = 0, alles &gt;= 128 = 255\nimg1c = np.where(img1c &lt; 128, 0, 255)\n\n# Bild anzeigen\nplt.imshow(img1c, cmap=\"gray\")\nplt.axis(\"off\")\nplt.show()\n</code></pre> <p>Farbbilder (3 Bit pro Pixel - RGB)</p> <p>Um Farben darzustellen, ben\u00f6tigen wir mehr als nur schwarz und wei\u00df. Das gebr\u00e4uchlichste Farbmodell ist RGB (Rot, Gr\u00fcn, Blau) - jede Farbe entsteht durch Mischung dieser drei Grundfarben.</p> <p>Wenn wir 1 Bit pro Farbkanal verwenden, ergeben sich 3 Bit pro Pixel \u2192 \\(2^3 = 8\\) verschiedene Farben.</p> Minimalbeispiel: 3-Bit RGB Bild <p></p> <p></p> Python Code <pre><code>import cv2\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n# Bild einlesen\nimg = cv2.imread(\"logo.svg\", cv2.IMREAD_COLOR)\nimg = cv2.cvtColor(img, cv2.COLOR_BGR2RGB)\n\n# Schwellwert anwenden: alles &lt; 128 = 0, alles &gt;= 128 = 255\nimg3c = np.where(img &lt; 128, 0, 255)\n\n# Bild als RGB anzeigen\nplt.imshow(img3c)\nplt.axis(\"off\")\nplt.show()\n</code></pre> <p>True Color - 24 Bit pro Pixel</p> <p>Da unsere Welt sehr farbenfroh ist und wir uns nicht mit 8 Farben begn\u00fcgen wollen, verwenden moderne Bildschirme 8 Bit pro Farbkanal (= 1 Byte).</p> <p>24 Bit RGB bedeutet:</p> <ul> <li>8 Bit Rot \u2192 256 Stufen</li> <li>8 Bit Gr\u00fcn \u2192 256 Stufen</li> <li>8 Bit Blau \u2192 256 Stufen</li> </ul> <p>Gesamtzahl der darstellbaren Farben: \\(256^3 = 16.777.216\\) Farben!</p> Minimalbeispiel: 24-Bit RGB Bild <p></p> <p></p> Python Code <pre><code>import cv2\nimport matplotlib.pyplot as plt\n\n# Bild einlesen (volle Farbtiefe)\nimg = cv2.imread(\"logo.svg\", cv2.IMREAD_COLOR)\nimg = cv2.cvtColor(img, cv2.COLOR_BGR2RGB)\n\n# Bild anzeigen\nplt.imshow(img)\nplt.axis(\"off\")\nplt.show()\n</code></pre> Hexadezimaldarstellung von Farben <p>Die Darstellung der 8 Bit pro Farbe erfolgt sehr h\u00e4ufig als Hexadezimal. Dabei k\u00f6nnen die 256 Stufen mit zwei Hexadezimal-Ziffern abgebildet werden. H\u00e4ufig wird das <code>#</code>-Zeichen vorangestellt.</p> <p>Beispiele:</p> <ul> <li>Dezimal: <code>(244, 155, 0)</code> entspricht in HEX: <code>#F49B00</code> (Orange)</li> <li>Dezimal: <code>(0, 73, 131)</code> entspricht in HEX: <code>#004983</code> (Blau)</li> </ul> <p>Diese Notation kennst du vielleicht aus HTML/CSS oder Grafikprogrammen!</p> <p>Berechnung der Dateigr\u00f6\u00dfe:</p> <p>Ein Bild mit 1920 \u00d7 1080 Pixeln (Full HD) ben\u00f6tigt bei 24 Bit Farbtiefe:</p> \\[1920 \\times 1080 \\times 3 \\text{ Byte} = 6.220.800 \\text{ Byte} \\approx 6{,}2 \\text{ MB}\\] <p>Das ist ohne Kompression! Durch Bildkompression (JPEG, PNG) l\u00e4sst sich die Dateigr\u00f6\u00dfe erheblich reduzieren.</p>"},{"location":"data/speicherung/#text","title":"Text","text":"<p>Nachdem wir uns die Speicherung von Bildern angesehen haben, schauen wir uns nun Texte an. Auch hier werden die Inhalte als bin\u00e4re Daten gespeichert \u2013 aber wie wird aus einem Buchstaben eine Zahl?</p> <p>Die Herausforderung: Ein Computer kennt nur Zahlen (Bits). Um Text zu speichern, brauchen wir eine Abbildung von Zeichen auf Zahlen \u2013 eine sogenannte Zeichenkodierung.</p> <p>Bevor wir zu modernen Standards kommen, ein kurzer Blick zur\u00fcck:</p> <p>ASCII (1963) \u2013 Der erste weitverbreitete Standard:</p> <ul> <li>Kodiert 128 Zeichen mit 7 Bit (erweitert auf 8 Bit = 1 Byte)</li> <li>Enth\u00e4lt: Lateinische Buchstaben (A\u2013Z, a\u2013z), Ziffern (0\u20139), Sonderzeichen (!?.,;), Steuerzeichen (Zeilenumbruch, Tab)</li> <li>Problem: Keine Umlaute (\u00e4, \u00f6, \u00fc), keine anderen Schriftsysteme (Kyrillisch, Arabisch, Chinesisch)</li> </ul> Beispiel: ASCII-Kodierung <pre><code>A \u2192 65 (Dezimal) \u2192 01000001 (Bin\u00e4r)\nB \u2192 66 (Dezimal) \u2192 01000010 (Bin\u00e4r)\na \u2192 97 (Dezimal) \u2192 01100001 (Bin\u00e4r)\n</code></pre> <p>Das Problem der Globalisierung:</p> <p>Mit der weltweiten Verbreitung von Computern brauchte man einen Standard, der alle Schriftsysteme der Welt abdeckt. Die L\u00f6sung: Unicode.</p> <p>Unicode ist ein universeller Standard, der jedem Schriftzeichen der Welt eine eindeutige Nummer zuweist \u2013 unabh\u00e4ngig von Plattform, Programm oder Sprache.</p> <pre><code>flowchart LR\n    A[Zeichen: A]:::peach --&gt; B[Unicode Codepoint: U+0041]:::teal\n    B --&gt; C[Encoding UTF-8: 0x41]:::peach\n    C --&gt; D[Bin\u00e4r: 01000001]:::teal\n\n    classDef peach fill:#FFB482aa,stroke:#333,stroke-width:1px;\n    classDef teal fill:#009485aa,stroke:#333,stroke-width:1px;</code></pre> <p>Unicode umfasst heute (Stand 2024):</p> <ul> <li>154.998 Zeichen aus 161 Schriftsystemen</li> <li>Latein, Kyrillisch, Griechisch, Arabisch, Hebr\u00e4isch, Chinesisch, Japanisch, Koreanisch, ...</li> <li>Mathematische Symbole (\u2211, \u222b, \u221e)</li> <li>Pfeile und geometrische Formen (\u2192, \u25ef, \u25b6)</li> <li>Emojis (\ud83d\ude00, \ud83d\ude80, \u2764\ufe0f, \ud83c\udf89)</li> </ul> <p>Jedes Zeichen erh\u00e4lt einen Codepoint \u2013 eine eindeutige Nummer in hexadezimaler Schreibweise:</p> Zeichen Unicode Codepoint Beschreibung A <code>U+0041</code> Lateinischer Gro\u00dfbuchstabe A \u00fc <code>U+00FC</code> Lateinisches kleines u mit Umlaut \u20ac <code>U+20AC</code> Euro-Zeichen \u4e2d <code>U+4E2D</code> Chinesisches Zeichen (Mitte) \ud83d\ude00 <code>U+1F600</code> Grinning Face Emoji \ud83d\ude80 <code>U+1F680</code> Rocket Emoji <p>\ud83d\udca1 Wichtig: Unicode definiert nur die Zuordnung von Zeichen zu Nummern (Codepoints), aber nicht, wie diese Nummern als Bytes gespeichert werden. Daf\u00fcr brauchen wir ein Encoding.</p> <p>UTF-8 (Unicode Transformation Format \u2013 8 Bit) ist das heute am weitesten verbreitete Encoding-Verfahren f\u00fcr Unicode. Es wandelt Unicode-Codepoints in Byte-Sequenzen um.</p> <p>Besonderheit: UTF-8 ist variabel lang \u2013 ein Zeichen kann 1 bis 4 Bytes ben\u00f6tigen:</p> Codepoint-Bereich Bytes Beispiele <code>U+0000</code> bis <code>U+007F</code> 1 Byte ASCII-Zeichen: A\u2013Z, a\u2013z, 0\u20139, !?.,; <code>U+0080</code> bis <code>U+07FF</code> 2 Bytes Lateinische Erweiterungen: \u00e4, \u00f6, \u00fc, \u00e9, \u00f1, \u00df <code>U+0800</code> bis <code>U+FFFF</code> 3 Bytes Die meisten Zeichen: \u20ac, \u00a9, \u4e2d (Chinesisch), \u2211 <code>U+10000</code> bis <code>U+10FFFF</code> 4 Bytes Emojis, historische Schriften: \ud83d\ude00, \ud83d\ude80, \ud835\udd73 (Math) <p>Warum UTF-8 so erfolgreich ist:</p> <ul> <li>Abw\u00e4rtskompatibel zu ASCII \u2013 ASCII-Texte sind gleichzeitig g\u00fcltige UTF-8-Texte</li> <li>Platzsparend \u2013 Englische Texte ben\u00f6tigen nur 1 Byte pro Zeichen</li> <li>Selbstsynchronisierend \u2013 Man kann mitten im Text einsteigen und die Zeichengrenzen erkennen</li> <li>Weltweit einsetzbar \u2013 Alle Sprachen, Symbole und Emojis darstellbar</li> </ul> Unicode &amp; UTF-8 Encoding <ul> <li><code>A</code> \\(\\xrightarrow{\\text{Codepoint}}\\) <code>U+0041</code> \\(\\xrightarrow{\\text{UTF-8}}\\) <code>41</code> (1 Byte)</li> <li><code>\u20ac</code> \\(\\xrightarrow{\\text{Codepoint}}\\) <code>U+20AC</code> \\(\\xrightarrow{\\text{UTF-8}}\\) <code>E2 82 AC</code> (3 Bytes)</li> <li><code>\ud83d\ude42</code> \\(\\xrightarrow{\\text{Codepoint}}\\) <code>U+1F642</code> \\(\\xrightarrow{\\text{UTF-8}}\\) <code>F0 9F 99 82</code> (4 Bytes)</li> </ul> Python Code <pre><code>s = \"A\u20ac\ud83d\ude42\"  # Mix aus ASCII, Symbol und Emoji\n\n# Codepoints (Unicode)\nfor ch in s:\n    print(f\"{ch} -&gt; U+{ord(ch):04X}\")\n\n# Gleiche Zeichen in verschiedenen Encodings\nencodings = [\"ascii\", \"latin-1\", \"utf-8\", \"utf-16-le\", \"utf-32-le\"]\nfor enc in encodings:\n    try:\n        b = s.encode(enc)\n        print(f\"{enc:10s} -&gt; {len(b):2d} Bytes -&gt; {b.hex(' ')}\")\n    except UnicodeEncodeError as e:\n        print(f\"{enc:10s} -&gt; NICHT darstellbar\")\n</code></pre> <p>\ud83d\udca1 Fazit: UTF-8 ist effizienter als UTF-16 und UTF-32 f\u00fcr Texte mit lateinischen Zeichen und gleichzeitig universell einsetzbar f\u00fcr alle Sprachen.</p>"},{"location":"data/speicherung/#datentypen-in-der-programmierung","title":"Datentypen in der Programmierung","text":"<p>Nachdem wir nun wissen, wie verschiedene Datenarten bin\u00e4r gespeichert werden, schauen wir uns an, welche Datentypen in der Programmierung verwendet werden.</p> <p>\ud83d\udca1 Wichtig: Die verf\u00fcgbaren Datentypen und ihre Eigenschaften h\u00e4ngen stark von der Programmiersprache ab. Jede Sprache hat ihre eigenen Typsysteme mit unterschiedlichen Regeln, Gr\u00f6\u00dfen und Verhaltensweisen.</p> <p>In weiterer Folge wollen wir das ganze anhand der Programmiersprache Python erkl\u00e4ren - einer der wichtigsten Sprachen f\u00fcr Data Science und maschinelles Lernen. Im Gegensatz zu Sprachen wie Java oder C++ ist Python dynamisch typisiert - der Datentyp wird zur Laufzeit automatisch ermittelt. Dennoch arbeitet Python intern mit denselben bin\u00e4ren Repr\u00e4sentationen.</p>"},{"location":"data/speicherung/#grundlegende-datentypen-in-python","title":"Grundlegende Datentypen in Python","text":"<p>Python bietet mehrere eingebaute Datentypen, die die Grundlage jeder Programmierung bilden. Diese Typen werden automatisch zugewiesen, sobald du einen Wert einer Variable zuweist.</p> Datentyp Python-Typ Beispiel Verwendung Boolean <code>bool</code> <code>True</code>, <code>False</code> Wahrheitswerte, Bedingungen Ganzzahl <code>int</code> <code>42</code>, <code>-17</code>, <code>1000000</code> Ganze Zahlen (beliebige Gr\u00f6\u00dfe!) Flie\u00dfkommazahl <code>float</code> <code>3.14</code>, <code>-0.001</code>, <code>2.5e10</code> Dezimalzahlen, wissenschaftliche Notation Komplexe Zahl <code>complex</code> <code>3+4j</code>, <code>2.5-1.5j</code> Komplexe Zahlen (Mathematik, Physik) Zeichenkette <code>str</code> <code>\"Hallo\"</code>, <code>'Python'</code>, <code>\"\ud83d\ude00\"</code> Text, Zeichen, Emojis Bytes <code>bytes</code> <code>b'hello'</code>, <code>b'\\x00\\xFF'</code> Bin\u00e4rdaten, Dateien, Netzwerk None <code>NoneType</code> <code>None</code> Fehlender oder undefinierter Wert Python's dynamische Typisierung <p>Im Gegensatz zu Sprachen wie Java oder C++ musst du in Python keine Datentypen deklarieren. Python erkennt automatisch, welchen Typ eine Variable hat:</p> <pre><code>x = 42          # int\ny = 3.14        # float\nname = \"Alice\"  # str\nis_valid = True # bool\n</code></pre> <p>Du kannst den Typ jederzeit mit <code>type()</code> \u00fcberpr\u00fcfen:</p> <pre><code>print(type(x))  # &lt;class 'int'&gt;\n</code></pre> Besonderheit: Python <code>int</code> hat unbegrenzte Gr\u00f6\u00dfe <p>Anders als in vielen anderen Sprachen (Java, C++, C#) hat Python's <code>int</code> keine feste Gr\u00f6\u00dfe. Python kann beliebig gro\u00dfe Ganzzahlen darstellen - nur begrenzt durch den verf\u00fcgbaren Arbeitsspeicher!</p> <pre><code># In Java w\u00fcrde dies zu einem \u00dcberlauf f\u00fchren\nweltbevoelkerung = 8000000000  # 8 Milliarden - kein Problem\n\n# Selbst gigantische Zahlen sind m\u00f6glich\nfactorial_100 = 93326215443944152681699238856266700490715968264381621468592963895217599993229915608941463976156518286253697920827223758251185210916864000000000000000000000000\n\n# Python verarbeitet das problemlos\nprint(2**1000)  # Eine Zahl mit \u00fcber 300 Stellen!\n</code></pre> <p>Hintergrund: Python verwendet intern eine variable Anzahl von Bytes f\u00fcr <code>int</code>, je nach Gr\u00f6\u00dfe der Zahl. Kleine Zahlen (&lt; 256) werden optimiert gespeichert.</p>"},{"location":"data/speicherung/#container-datentypen","title":"Container-Datentypen","text":"<p>Neben den grundlegenden Datentypen bietet Python Container, die mehrere Werte speichern k\u00f6nnen:</p> Container-Typ Python-Typ Eigenschaften Beispiel Liste <code>list</code> Geordnet, ver\u00e4nderbar, Duplikate erlaubt <code>[1, 2, 3]</code> Tupel <code>tuple</code> Geordnet, unver\u00e4nderbar, Duplikate erlaubt <code>(1, 2, 3)</code> Menge <code>set</code> Ungeordnet, ver\u00e4nderbar, keine Duplikate <code>{1, 2, 3}</code> Dictionary <code>dict</code> Schl\u00fcssel-Wert-Paare, ver\u00e4nderbar <code>{\"name\": \"Alice\"}</code> Beispiele: Container in Python <p>Liste - die vielseitigste Datenstruktur: </p><pre><code>zahlen = [1, 2, 3, 4, 5]\nzahlen.append(6)        # Hinzuf\u00fcgen\nzahlen[0] = 10          # \u00c4ndern\nprint(zahlen)           # [10, 2, 3, 4, 5, 6]\n</code></pre><p></p> <p>Tupel - unver\u00e4nderlich, ideal f\u00fcr feste Werte: </p><pre><code>koordinaten = (52.52, 13.405)  # Berlin (Lat, Lon)\n# koordinaten[0] = 50  # \u274c Fehler! Tupel sind unver\u00e4nderbar\n</code></pre><p></p> <p>Set - automatisch eindeutig: </p><pre><code>farben = {\"rot\", \"gr\u00fcn\", \"blau\", \"rot\"}\nprint(farben)  # {'rot', 'gr\u00fcn', 'blau'} - Duplikat entfernt\n</code></pre><p></p> <p>Dictionary - Key-Value-Paare: </p><pre><code>person = {\n    \"name\": \"Alice\",\n    \"alter\": 30,\n    \"stadt\": \"Berlin\"\n}\nprint(person[\"name\"])  # Alice\n</code></pre><p></p>"},{"location":"data/speicherung/#speichertechnologien","title":"Speichertechnologien","text":"<p>Nachdem wir wissen, wie Daten bin\u00e4r dargestellt werden, stellt sich die Frage: Wo werden diese Bits physisch gespeichert?</p> <p>Es gibt verschiedene Speichertechnologien, die sich in Geschwindigkeit, Kapazit\u00e4t, Kosten und Fl\u00fcchtigkeit unterscheiden.</p>"},{"location":"data/speicherung/#speicherhierarchie","title":"Speicherhierarchie","text":"<p>Computer nutzen eine Speicherhierarchie - vom schnellen, aber teuren Cache bis zum langsamen, aber g\u00fcnstigen Massenspeicher.</p> Speichertyp Geschwindigkeit Kapazit\u00e4t Fl\u00fcchtig? CPU Register \ud83d\udfe2\ud83d\udfe2\ud83d\udfe2 Sehr schnell Bytes \u2705 Ja Cache (L1/L2/L3) \ud83d\udfe2\ud83d\udfe2 Schnell KB - MB \u2705 Ja RAM (Arbeitsspeicher) \ud83d\udfe2 Mittel GB \u2705 Ja SSD \ud83d\udfe1 Schnell (f\u00fcr Massenspeicher) TB \u274c Nein HDD \ud83d\udd34 Langsam TB \u274c Nein Cloud / Archiv \ud83d\udd34\ud83d\udd34 Sehr langsam PB \u274c Nein <p>\ud83d\udca1 Merke: Fl\u00fcchtig (volatil) bedeutet: Daten gehen beim Ausschalten verloren (z. B. RAM). Nicht-fl\u00fcchtig (persistent): Daten bleiben erhalten (z. B. SSD, HDD).</p>"},{"location":"data/speicherung/#ram-arbeitsspeicher","title":"RAM - Arbeitsspeicher","text":"<p>RAM (Random Access Memory) ist der Arbeitsspeicher des Computers. Hier werden Programme und Daten gespeichert, die gerade aktiv genutzt werden.</p> <p>Eigenschaften:</p> <ul> <li> Vorteile <ul> <li>Sehr schneller Zugriff (Nanosekunden)</li> <li>Wahlfreier Zugriff (Random Access)</li> </ul> </li> <li> Nachteile <ul> <li>Fl\u00fcchtig - Daten gehen beim Ausschalten verloren</li> <li>Begrenzte Kapazit\u00e4t (4-64 GB typisch)</li> </ul> </li> </ul> <p>Merke Wenn du ein Programm \u00f6ffnest, wird es von der Festplatte in den RAM geladen. Solange es l\u00e4uft, arbeitet die CPU mit den Daten im RAM.</p>"},{"location":"data/speicherung/#massenspeicher-hdd-vs-ssd","title":"Massenspeicher - HDD vs. SSD","text":"<p>F\u00fcr die dauerhafte Speicherung gro\u00dfer Datenmengen nutzen wir Massenspeicher. Die beiden wichtigsten Typen sind HDD (Hard Drive Disk) und SSD (Solid State Disk).</p> Merkmal HDD SSD Technik Magnetische Scheiben, K\u00f6pfe Elektronische Flash-Zellen Geschwindigkeit Mittel (80-160 MB/s) Sehr hoch (500-7000 MB/s) Haltbarkeit Mechanisch anf\u00e4llig (sto\u00dfempfindlich) Begrenzte Schreibzyklen Kosten G\u00fcnstiger pro TB (~\u20ac20/TB) Teurer pro TB (~\u20ac60-100/TB) Einsatz Archivierung, gro\u00dfe Datenmengen Betriebssystem, Programme, Datenbanken Typische Schnittstellen SATA, SAS SATA, NVMe/PCIe <p>\ud83d\udca1 Empfehlung: Moderne Computer nutzen oft eine Kombination: SSD f\u00fcr das Betriebssystem und Programme (schnell), HDD f\u00fcr gro\u00dfe Datenmengen wie Fotos, Videos, Backups (g\u00fcnstig).</p>"},{"location":"data/speicherung/#cloud-speicher","title":"Cloud-Speicher","text":"<p>Cloud-Speicher bedeutet, dass Daten nicht lokal, sondern auf entfernten Servern gespeichert werden (z. B. Google Drive, Dropbox, OneDrive).</p> <ul> <li> Vorteile <ul> <li>Von \u00fcberall zug\u00e4nglich</li> <li>Automatische Backups</li> <li>Skalierbar (beliebig erweiterbar)</li> </ul> </li> <li> Nachteile <ul> <li>Abh\u00e4ngig von Internetverbindung</li> <li>Datenschutz / Privatsph\u00e4re</li> <li>Laufende Kosten</li> </ul> </li> </ul>"},{"location":"data/speicherung/#zusammenfassung","title":"Zusammenfassung \ud83d\udccc","text":"<ul> <li>Bilder werden als Pixel-Matrix gespeichert, wobei jeder Pixel durch Bits f\u00fcr Farben (RGB) codiert wird. 24-Bit-RGB erm\u00f6glicht 16,7 Millionen Farben.</li> <li>Text wird \u00fcber Unicode-Codepoints und UTF-8-Encoding in Bytes umgewandelt. UTF-8 ist variabel und sehr effizient.</li> <li>Primitive Datentypen (<code>int</code>, <code>float</code>, <code>char</code>, ...) sind die Bausteine der Programmierung mit fester Gr\u00f6\u00dfe.</li> <li>Speichertechnologien bilden eine Hierarchie: vom schnellen RAM (fl\u00fcchtig) bis zum langsamen HDD (dauerhaft).</li> <li>SSD ist schneller als HDD, aber teurer. Moderne Systeme nutzen oft beide.</li> <li>Cloud-Speicher bietet Flexibilit\u00e4t, aber erfordert Internetverbindung.</li> </ul> <p>Nachdem wir nun verstanden haben, wie Daten erfasst, verarbeitet und gespeichert werden, k\u00f6nnen wir uns im n\u00e4chsten Kapitel damit besch\u00e4ftigen, wie wir mit diesen Daten arbeiten: Sie organisieren, abfragen und analysieren - die Grundlage von Datenbanken und Data Science!</p>"},{"location":"data/zahlensysteme/","title":"Datenverarbeitung","text":""},{"location":"data/zahlensysteme/#datenverarbeitung","title":"Datenverarbeitung","text":"<p>Im vorherigen Kapitel haben wir gelernt, wie Daten erfasst werden \u2013 von Sensoren \u00fcber Verst\u00e4rker bis zum A/D-Wandler. Doch was passiert danach? Wie verarbeitet ein Computer diese Daten? Warum \"versteht\" ein Rechner nur Nullen und Einsen? Und wie werden Zahlen, Texte oder Bilder intern dargestellt?</p> <p>Um diese Fragen zu beantworten, m\u00fcssen wir verstehen, wie Computer rechnen und welche Zahlensysteme sie verwenden. Denn w\u00e4hrend wir Menschen mit dem Dezimalsystem arbeiten, basiert die gesamte digitale Welt auf dem Bin\u00e4rsystem.</p>"},{"location":"data/zahlensysteme/#warum-das-binarsystem","title":"Warum das Bin\u00e4rsystem?","text":"<p>Computer bestehen aus Milliarden winziger Transistoren \u2013 elektronischen Schaltern, die nur zwei stabile Zust\u00e4nde kennen: EIN (1) oder AUS (0). Diese physikalische Eigenschaft macht das Bin\u00e4rsystem (Basis 2) zur idealen Sprache der Maschinen.</p> <pre><code>flowchart LR\n    A[Analoges Signal]:::peach --&gt; B(A/D-Wandler):::teal\n    B --&gt; C[Digitales Signal #40;Bin\u00e4r#41;]:::peach\n    C --&gt; D(Prozessor):::teal\n    D --&gt; E[Berechnung in Bin\u00e4r]:::peach\n\n    classDef peach fill:#FFB482aa,stroke:#333,stroke-width:1px;\n    classDef teal fill:#009485aa,stroke:#333,stroke-width:1px;</code></pre> <p>Gr\u00fcnde f\u00fcr das Bin\u00e4rsystem:</p> <ul> <li>Einfache physikalische Realisierung: Transistoren kennen zuverl\u00e4ssig nur zwei stabile Zust\u00e4nde: leitend (1) oder nicht leitend (0). Auch andere Tr\u00e4gersysteme wie Magnetisierung, Licht oder Spannung lassen sich leicht auf an/aus abbilden.</li> <li>Hohe St\u00f6rsicherheit: Mit nur zwei Zust\u00e4nden sind Signale weniger fehleranf\u00e4llig. Schon kleine Abweichungen lassen sich durch Schwellwerte tolerieren, ohne dass der Informationsgehalt verloren geht.</li> <li>Einfache elektronische Verarbeitung: Logikgatter wie AND, OR, NOT lassen sich direkt auf das Bin\u00e4rsystem abbilden. Dadurch ist die Umsetzung von Rechenoperationen in Hardware effizient und robust.</li> </ul> Bit \u2013 die kleinste Informationseinheit <p>Ein Bit (B inary Dig it) ist die kleinste Informationseinheit in der Informatik und repr\u00e4sentiert eine Stelle einer Bin\u00e4rzahl. Ein Bit kann zwei Zust\u00e4nde annehmen: <code>0</code> oder <code>1</code>.</p> <p>Die Interpretation der Zust\u00e4nde kann abh\u00e4ngig vom jeweiligen Kontext variieren:</p> <ul> <li>Licht an/aus</li> <li>Wahr/Falsch</li> <li>Hochspannung/Niederspannung</li> <li>Nord/S\u00fcd (Magnetisierung)</li> </ul>"},{"location":"data/zahlensysteme/#vom-bit-zum-byte","title":"Vom Bit zum Byte","text":"<p>Da ein einzelnes Bit sehr wenig Information speichert, werden mehrere Bits zu Gruppen zusammengefasst. Die wichtigste Gruppe ist das Byte \u2013 eine Einheit aus 8 Bit.</p> Beispiel: Kombinationen mit Bits <p>Nachdem ein Bit zwei verschiedene Zust\u00e4nde annehmen kann, k\u00f6nnen n Bits genau \\(2^n\\) verschiedene Zust\u00e4nde darstellen:</p> <ul> <li>1 Bit: \\(2^1 = 2\\) Zust\u00e4nde \u2192 <code>[0, 1]</code></li> <li>2 Bit: \\(2^2 = 4\\) Zust\u00e4nde \u2192 <code>[00, 01, 10, 11]</code></li> <li>3 Bit: \\(2^3 = 8\\) Zust\u00e4nde \u2192 <code>[000, 001, 010, 011, 100, 101, 110, 111]</code></li> <li>8 Bit (1 Byte): \\(2^8 = 256\\) Zust\u00e4nde \u2192 <code>[00000000 ... 11111111]</code></li> </ul> <p>Diese Reihe l\u00e4sst sich beliebig fortsetzen:</p> <p>2 - 4 - 8 - 16 - 32 - 64 - 128 - 256 - 512 - 1024 - 2048 - 4096 ...</p> <p>Dem ein oder anderen werden diese Zahlen bekannt vorkommen \u2013 beim Blick auf den Speicherplatz des Smartphones, beim Kauf einer neuen Festplatte oder bei der Aufl\u00f6sung des Monitors. Nun wisst ihr auch, woher diese Zahlen kommen!</p> Warum 8 Bit = 1 Byte? <p>Fr\u00fcher hatten verschiedene Systeme Bytes mit 6, 7 oder 9 Bits, aber 8 Bits haben sich als Standard etabliert:</p> <ul> <li>Passt perfekt ins bin\u00e4re System (16 Bit = 2 Byte, 32 Bit = 4 Byte, 64 Bit = 8 Byte)</li> <li>256 Zust\u00e4nde reichen aus, um alle Zeichen einer Tastatur abzubilden (ASCII-Code)</li> <li>Computer k\u00f6nnen heutzutage nicht jedes einzelne Bit separat adressieren \u2013 Bytes sind die kleinste adressierbare Einheit</li> </ul> Quelle: Programmerhumor.io"},{"location":"data/zahlensysteme/#zahlensysteme","title":"Zahlensysteme","text":"<p>Im Laufe der Geschichte haben sich verschiedene Zahlensysteme entwickelt, die jeweils an die Bed\u00fcrfnisse der Gesellschaften angepasst waren.</p> Quelle: Kryptografie.de <p>Das \u00e4gyptische Zahlensystem ist beispielsweise ein additives Zehnersystem, bei dem f\u00fcr jede Zehnerpotenz (Einer, Zehner, Hunderter usw.) ein eigenes Hieroglyphen-Symbol verwendet wird, das beliebig oft wiederholt werden kann.</p> <p>Heute sind insbesondere Stellenwertsysteme (Positionssysteme) von Bedeutung: Jede Stelle einer Zahl hat eine bestimmte Wertigkeit, die sich aus der Basis des Systems ergibt.</p> Beispiel: Dezimalsystem (Basis 10) <p>Die Zahl <code>123</code> setzt sich aus Hunderten, Zehnern und Einern zusammen:</p> \\[123_{10} = 1 \\cdot 10^2 + 2 \\cdot 10^1 + 3 \\cdot 10^0 = 100 + 20 + 3\\] <p>Die Basis 10 verwendet die Ziffern <code>0\u20139</code>. Das Zeichen \u201e3\" repr\u00e4sentiert den Wert 3 und wird mit entsprechenden Vielfachen von 10 multipliziert \u2013 abh\u00e4ngig von der Position in der Zahl.</p> Quelle: Programmerhumor.io <p>F\u00fcr all jene, die diesen Witz noch nicht verstehen: Kein Problem. Einfach weiterlesen. \ud83d\ude09</p>"},{"location":"data/zahlensysteme/#wichtige-zahlensysteme-in-der-informatik","title":"Wichtige Zahlensysteme in der Informatik","text":"<p>Neben dem uns vertrauten Dezimalsystem gibt es weitere Zahlensysteme, die speziell in der Informatik h\u00e4ufig verwendet werden. Jedes System bietet unterschiedliche Vorteile.</p> Zahlensystem Basis Ziffern Beispiel Dezimalsystem 10 0\u20139 7345\u2081\u2080 Bin\u00e4rsystem 2 0, 1 1001\u2082 Oktalsystem 8 0\u20137 7345\u2088 Hexadezimalsystem 16 0\u20139, A\u2013F CAFE\u2081\u2086 <p>Warum verschiedene Systeme?</p> <ul> <li>Bin\u00e4r: Basis des Computers (Hardware-Ebene)</li> <li>Oktal: Kompakte Darstellung von Bin\u00e4rzahlen (3 Bit = 1 Oktalziffer)</li> <li>Hexadezimal: Sehr kompakt (4 Bit = 1 Hexziffer), h\u00e4ufig f\u00fcr Farben (#FF5733), Speicheradressen, Maschinenbefehle</li> </ul> <p>Die Basis <code>b</code> gibt an, wie viele Ziffern im System verwendet werden. Mathematisch l\u00e4sst sich eine Zahl <code>X</code> in der jeweiligen Basis wie folgt darstellen:</p> Positions- oder Stellenwertsystem <p>Allgemein gilt f\u00fcr eine positive Zahl <code>X</code> in Basis <code>b</code>:</p> \\[X = \\sum_{i=0}^{n-1} x_i \\cdot b^i\\] <p>mit den Ziffern \\(x_i \\in \\{0, 1, \\ldots, b-1\\}\\).</p> <p>Die Basis wird oft tiefgestellt oder durch Symbole gekennzeichnet: <code>O</code> f\u00fcr Oktal, <code>H</code> f\u00fcr Hexadezimal. Beim Dezimalsystem wird die Basis meist weggelassen.</p> Aufgabe: Zahlensysteme verstehen <p>Stelle die nachfolgenden Zahlen entsprechend ihrer Basis mit der allgemeinen Formel dar:</p> <ol> <li>\\(1010_2\\)</li> <li>\\(1755_{10}\\)</li> <li>\\(\\text{A4B}_{16}\\)</li> <li>\\(1755\\) (ohne Basis angegeben)</li> </ol> <p>Beispiel:</p> \\[213_{10} = 2 \\cdot \\underbrace{10^2}_{100} + 1 \\cdot \\underbrace{10^1}_{10} + 3 \\cdot \\underbrace{10^0}_{1}\\]"},{"location":"data/zahlensysteme/#verschiedene-zahlensysteme-im-alltag","title":"Verschiedene Zahlensysteme im Alltag","text":"<p>Bevor wir uns den technischen Details der Basisumwandlung widmen, schauen wir uns zun\u00e4chst an, wo uns diese Zahlensysteme \u2013 insbesondere das Bin\u00e4r- und Hexadezimalsystem \u2013 im t\u00e4glichen Leben begegnen. Diese praktischen Beispiele zeigen, warum das Verst\u00e4ndnis verschiedener Zahlensysteme nicht nur theoretisch wichtig ist, sondern konkrete Anwendungen hat.</p> <p>Beispiel 1: Farbdarstellung (RGB)</p> <p>Farben auf Bildschirmen werden meist im RGB-Modell dargestellt \u2013 jede Farbe besteht aus Rot, Gr\u00fcn und Blau-Anteilen. Jeder Farbkanal wird mit 8 Bit (= 1 Byte) codiert \u2192 256 Stufen pro Kanal.</p> Beispiel: Farbcode <ul> <li>Wei\u00df: <code>#FFFFFF</code> (Hex) = <code>(255, 255, 255)</code> (Dez) = <code>11111111 11111111 11111111</code> (Bin)</li> <li>Schwarz: <code>#000000</code> (Hex) = <code>(0, 0, 0)</code> (Dez) = <code>00000000 00000000 00000000</code> (Bin)</li> <li>Rot: <code>#FF0000</code> (Hex) = <code>(255, 0, 0)</code> (Dez) = <code>11111111 00000000 00000000</code> (Bin)</li> </ul> <p>Beispiel 2: IPv4-Adressen</p> <p>Eine IPv4-Adresse besteht aus 4 Bytes (32 Bit), z. B. <code>192.168.1.1</code>.</p> Beispiel: IP-Adresse in Bin\u00e4r \\[192.168.1.1_{10} = 11000000.10101000.00000001.00000001_2\\] <p>Jede Zahl ist ein Byte (0\u2013255).</p> <p>Beispiel 3: Speichergr\u00f6\u00dfen</p> Einheit Gr\u00f6\u00dfe Bytes 1 Kilobyte 2<sup>10</sup> Bytes 1.024 Bytes 1 Megabyte 2<sup>20</sup> Bytes 1.048.576 Bytes 1 Gigabyte 2<sup>30</sup> Bytes 1.073.741.824 Bytes 1 Terabyte 2<sup>40</sup> Bytes ~1 Billion Bytes Hinweis <p>In der Praxis wird oft 1 KB = 1000 Bytes verwendet (SI-Standard), was zu Verwirrung f\u00fchrt. Computer rechnen aber in Zweierpotenzen (1 KiB = 1024 Bytes).</p>"},{"location":"data/zahlensysteme/#basisumwandlung","title":"Basisumwandlung","text":"<p>Prinzipiell ist es m\u00f6glich, jede Zahl in ein anderes Zahlensystem umzuwandeln. Daf\u00fcr stehen verschiedene Verfahren zur Verf\u00fcgung. Meist verwendet man das Dezimalsystem als Zwischensystem.</p> <p>Umwandlung in das Dezimalsystem (b \u2192 10)</p> <p>Das Umrechnen in das Dezimalsystem ist besonders einfach: Jede Ziffer wird mit ihrer Stellenwertigkeit multipliziert und anschlie\u00dfend aufsummiert.</p> Beispiel: Umwandlung in das Dezimalsystem <p>Bin\u00e4r zu Dezimal:</p> \\[1001_2 = 1 \\cdot 2^3 + 0 \\cdot 2^2 + 0 \\cdot 2^1 + 1 \\cdot 2^0 = 8 + 0 + 0 + 1 = 9_{10}\\] <p>Oktal zu Dezimal:</p> \\[7345_8 = 7 \\cdot 8^3 + 3 \\cdot 8^2 + 4 \\cdot 8^1 + 5 \\cdot 8^0 = 3584 + 192 + 32 + 5 = 3813_{10}\\] <p>Hexadezimal zu Dezimal:</p> \\[\\text{CAFE}_{16} = 12 \\cdot 16^3 + 10 \\cdot 16^2 + 15 \\cdot 16^1 + 14 \\cdot 16^0 = 51966_{10}\\] <p>(Hinweis: \\(\\text{C} = 12, \\text{A} = 10, \\text{F} = 15, \\text{E} = 14\\))</p> <p>Umwandlung vom Dezimalsystem in ein beliebiges Zahlensystem (10 \u2192 b)</p> <p>Die Ausgangszahl wird wiederholt durch die Zielbasis geteilt, bis der Quotient 0 ist. Die Reste ergeben die Ziffern der neuen Darstellung \u2013 von rechts nach links.</p> Beispiele: Umwandlung vom Dezimalsystem <p>Vom Dezimal- ins Oktalsystem:</p> \\[ \\begin{align} 327 \\div 8 &amp;= 40 \\text{ Rest } 7 \\\\ 40 \\div 8 &amp;= 5 \\text{ Rest } 0 \\\\ 5 \\div 8 &amp;= 0 \\text{ Rest } 5 \\end{align} \\] <p>Ergebnis (Reste von unten nach oben lesen): \\(327_{10} = 507_8\\)</p> <p>Vom Dezimal- ins Hexadezimalsystem:</p> \\[ \\begin{align} 327 \\div 16 &amp;= 20 \\text{ Rest } 7 \\\\ 20 \\div 16 &amp;= 1 \\text{ Rest } 4 \\\\ 1 \\div 16 &amp;= 0 \\text{ Rest } 1 \\end{align} \\] <p>Ergebnis: \\(327_{10} = 147_{16}\\)</p> Aufgabe: Basisumwandlung <p>Wandle die nachfolgenden Zahlen in die geforderte Basis um:</p> <ol> <li>\\(1010_2\\) zu Dezimal</li> <li>\\(1755_{10}\\) zu Oktal</li> <li>\\(\\text{A4B}_{16}\\) zu Bin\u00e4r</li> <li>\\(1755_{10}\\) zu Hexadezimal</li> </ol>"},{"location":"data/zahlensysteme/#festkommaarithmetik","title":"Festkommaarithmetik","text":"<p>Nicht nur ganze Zahlen, auch rationale Zahlen (Kommazahlen) k\u00f6nnen in verschiedenen Basen dargestellt werden. Dabei wird zwischen Vorkomma- und Nachkommateil unterschieden.</p> Festkommaarithmetik \u2013 allgemeine Formel <p>Allgemein gilt f\u00fcr eine Zahl <code>X</code> in Basis <code>b</code> mit <code>n</code> Vorkomma- und <code>m</code> Nachkommastellen:</p> \\[X = \\sum_{i=0}^{n-1} x_i \\cdot b^i + \\sum_{j=1}^{m} x_{-j} \\cdot b^{-j}\\] <p>mit den Ziffern \\(x_i \\in \\{0, 1, \\ldots, b-1\\}\\).</p> Beispiel: Festkommaarithmetik <p>Die Zahl \\(10{,}625_{10}\\) l\u00e4sst sich zerlegen in:</p> \\[10{,}625_{10} = \\underbrace{1 \\cdot 10^1 + 0 \\cdot 10^0}_{\\text{Vorkomma}} + \\underbrace{6 \\cdot 10^{-1} + 2 \\cdot 10^{-2} + 5 \\cdot 10^{-3}}_{\\text{Nachkomma}}\\] \\[= 10 + 0 + 0{,}6 + 0{,}02 + 0{,}005 = 10{,}625\\] <p>Die Konvertierung zwischen verschiedenen Basen in der Festkommaarithmetik ist ebenfalls m\u00f6glich, wird aber hier nicht weiter behandelt. Eine Beschreibung findet sich beispielsweise hier.</p>"},{"location":"data/zahlensysteme/#negative-zahlen","title":"Negative Zahlen","text":"<p>Bisher haben wir nur positive ganze Zahlen betrachtet. Um auch negative Zahlen darstellen zu k\u00f6nnen, gibt es verschiedene Verfahren. Die wichtigsten sind:</p> <ol> <li>Vorzeichen-Betrag-Darstellung</li> <li>Einerkomplement</li> <li>Zweierkomplement \u2b50 (heute Standard)</li> </ol> <p>Vorzeichen-Betrag-Darstellung</p> <ul> <li>Das h\u00f6chstwertige Bit (MSB = Most Significant Bit) dient als Vorzeichenbit:<ul> <li><code>0</code> \u2192 Zahl ist positiv</li> <li><code>1</code> \u2192 Zahl ist negativ</li> </ul> </li> <li>Die restlichen Bits geben den Betrag an.</li> </ul> Vorzeichen-Betrag Darstellung <p>Die Zahl \\(5\\) wird bin\u00e4r dargestellt als:</p> \\[101_2\\] <p>Wenn wir \\(\\pm 5\\) mit Vorzeichen und Betrag darstellen wollen, stellen wir ein Vorzeichenbit voran:</p> \\[\\underbrace{0}_{+} 101 \\rightarrow +5\\] \\[\\underbrace{1}_{-} 101 \\rightarrow -5\\] <p>Nachteile:</p> <ul> <li>Es gibt zwei Darstellungen f\u00fcr Null: <code>0000</code> und <code>1000</code></li> <li>Rechenoperationen (Addition/Subtraktion) sind aufw\u00e4ndiger als bei anderen Darstellungen</li> </ul> <p>Einerkomplement-Darstellung</p> <ul> <li>Positive Zahlen wie gewohnt.</li> <li>Negative Zahlen entstehen durch bitweise Invertierung (alle 0 \u2192 1 und 1 \u2192 0).</li> <li>Auch hier gibt es ein Vorzeichenbit (zeigt an, ob invertiert wurde).</li> </ul> Einerkomplement Darstellung <p>Wir m\u00f6chten die Zahlen \\(\\pm 5\\) im Einerkomplement darstellen:</p> <p>Positive Zahl (bleibt gleich):</p> \\[ \\underbrace{0}_{+} 101 \\rightarrow +5\\] <p>Negative Zahl (Bits invertieren):</p> \\[ 0101 \\rightarrow 1010 \\rightarrow -5\\] <p>Vorteil:</p> <ul> <li>Subtraktion kann durch Addition der negativen Zahl realisiert werden: \\(3 - 4 = 3 + (-4)\\)</li> </ul> <p>Nachteile:</p> <ul> <li>Auch hier zwei Darstellungen der Null: <code>0000</code> und <code>1111</code></li> <li>Bei Addition wird eine \u00dcbertrag-Korrektur ben\u00f6tigt</li> </ul> Quelle: Programmerhumor.io <p>Zweierkomplement-Darstellung \u2b50</p> <p>Die Zweierkomplement-Darstellung ist das heute in Computern gebr\u00e4uchlichste Verfahren zum Umgang mit negativen Zahlen. Sie baut auf dem Einerkomplement auf:</p> <p>Vorgehensweise:</p> <ol> <li>Positive Zahlen: Wie gewohnt darstellen</li> <li>Negative Zahlen:<ol> <li>Alle Bits invertieren (Einerkomplement bilden)</li> <li>Anschlie\u00dfend 1 addieren</li> </ol> </li> </ol> Zweierkomplement Darstellung <p>Wir m\u00f6chten die Zahlen \\(\\pm 5\\) im Zweierkomplement darstellen.</p> <p>Positive Zahl:</p> \\[ \\underbrace{0}_{+} 101 \\rightarrow +5\\] <p>Negative Zahl:</p> <ol> <li>Einerkomplement bilden: \\(0101 \\rightarrow 1010\\)</li> <li>1 addieren:</li> </ol> \\[ \\begin{array}{cr}      &amp; 1010 \\\\      + &amp; 0001 \\\\ \\hline      &amp; 1011 \\end{array} \\] <p>Ergebnis: \\(-5 = 1011_2\\) (im Zweierkomplement)</p> <p>Vorteile des Zweierkomplements:</p> <ul> <li>Es gibt nur eine Darstellung der Null (<code>0000</code>)</li> <li>Addition und Subtraktion funktionieren ohne Sonderregeln</li> <li>Hardware-Implementierung ist einfach und effizient</li> </ul> <p>Gegen\u00fcberstellung der Darstellungen</p> Zahl Vorzeichen-Betrag Einerkomplement Zweierkomplement +5 0101 0101 0101 \u22125 1101 1010 1011 Aufgabe: Negative Zahlen <p>Stellen Sie die Zahl \\(-7\\) in allen drei verschiedenen Darstellungsarten dar (verwenden Sie 4 Bit).</p>"},{"location":"data/zahlensysteme/#zusammenfassung","title":"Zusammenfassung \ud83d\udccc","text":"<ul> <li>Computer arbeiten auf Basis des Bin\u00e4rsystems, weil Transistoren nur zwei stabile Zust\u00e4nde kennen.</li> <li>Ein Bit ist die kleinste Informationseinheit, ein Byte besteht aus 8 Bit.</li> <li>Es gibt verschiedene Zahlensysteme (Bin\u00e4r, Oktal, Dezimal, Hexadezimal), die sich durch ihre Basis unterscheiden.</li> <li>Zahlen k\u00f6nnen zwischen verschiedenen Basen umgewandelt werden.</li> <li>Negative Zahlen werden meist im Zweierkomplement dargestellt \u2013 das ist effizient und hat keine doppelte Null.</li> <li>Das Bin\u00e4rsystem begegnet uns \u00fcberall: bei Farben, IP-Adressen, Speichergr\u00f6\u00dfen und in der Datenverarbeitung.</li> </ul> <p>Nachdem wir nun verstehen, wie Computer Daten verarbeiten und in welcher Form sie intern dargestellt werden, stellt sich die Frage: Wie werden diese Daten dauerhaft gespeichert? Dieser Frage gehen wir im n\u00e4chsten Kapitel nach.</p>"},{"location":"database/","title":"Home","text":""},{"location":"database/#datenbanken","title":"Datenbanken","text":"Ihr Browser unterst\u00fctzt das Video-Tag nicht.               Video erstellt mit Nano Banana 3 Pro, Grok &amp; ElevenLabs               \ud83d\udd07"},{"location":"database/#willkommen-im-modul-datenbanken","title":"Willkommen im Modul <code>Datenbanken</code>! \ud83d\udc4b","text":"<p>In diesem Kurs lernst du die Grundlagen relationaler Datenbanken mit PostgreSQL. Du verstehst, wie Datenbanken funktionieren, wie du Daten strukturierst, abfragst und manipulierst, und wie du professionelle Datenbankprojekte umsetzt.</p>"},{"location":"database/#kursubersicht","title":"Kurs\u00fcbersicht","text":"<p>Der Kurs ist in mehrere aufeinander aufbauende Kapitel strukturiert:</p> <ul> <li> <p> Einf\u00fchrung</p> <ul> <li>Was sind Datenbanken?</li> <li>Relationale Datenbanken</li> <li>PostgreSQL Setup</li> <li>Erste Schritte</li> </ul> </li> <li> <p> Relationale Datenbanken</p> <ul> <li>Tabellen und Attribute</li> <li>Prim\u00e4r- und Fremdschl\u00fcssel</li> <li>Beziehungen zwischen Tabellen</li> <li>Integrit\u00e4tsbedingungen</li> </ul> </li> <li> <p> Abfragen von Daten</p> <ul> <li>SELECT-Statement</li> <li>WHERE, ORDER BY, LIMIT</li> <li>Aggregatfunktionen</li> <li>GROUP BY und HAVING</li> </ul> </li> <li> <p> Daten Manipulieren</p> <ul> <li>INSERT: Daten einf\u00fcgen</li> <li>UPDATE: Daten \u00e4ndern</li> <li>DELETE: Daten l\u00f6schen</li> <li>Best Practices</li> </ul> </li> <li> <p> Datenmodellierung</p> <ul> <li>Entity-Relationship-Modell</li> <li>Normalisierung</li> <li>1:1, 1:n, n:m Beziehungen</li> <li>Von ER zu SQL</li> </ul> </li> <li> <p> Daten Zusammenf\u00fchren</p> <ul> <li>INNER JOIN</li> <li>LEFT, RIGHT, FULL JOIN</li> <li>CROSS JOIN</li> <li>Self-Joins</li> </ul> </li> <li> <p> Fortgeschrittene Techniken</p> <ul> <li>Subqueries</li> <li>WITH (CTEs)</li> <li>CASE WHEN</li> <li>Fortgeschrittene Aggregationen</li> </ul> </li> <li> <p> Datenintegrit\u00e4t</p> <ul> <li>NOT NULL, UNIQUE</li> <li>CHECK Constraints</li> <li>DEFAULT Werte</li> <li>Constraints verwalten</li> </ul> </li> <li> <p> Transaktionen</p> <ul> <li>BEGIN, COMMIT, ROLLBACK</li> <li>ACID-Prinzipien</li> <li>Fehlerbehandlung</li> <li>Transaktionssicherheit</li> </ul> </li> <li> <p> Ausblick</p> <ul> <li>Views </li> <li>Stored Procedures</li> <li>Trigger und JSON-Support</li> <li>Backup &amp; Recovery</li> </ul> </li> </ul>"},{"location":"database/#lernziele","title":"Lernziele","text":"<p>Nach Abschluss dieses Moduls kannst du:</p> <ul> <li> Datenbanken entwerfen und modellieren</li> <li> Tabellen mit Beziehungen erstellen</li> <li> Komplexe SQL-Abfragen schreiben</li> <li> Daten sicher manipulieren</li> <li> Datenintegrit\u00e4t mit Constraints sicherstellen</li> <li> Transaktionen f\u00fcr sichere Operationen nutzen</li> <li> Professionelle Datenbankprojekte umsetzen</li> </ul> <p>Bereit, in die Welt der Datenbanken einzutauchen? Starte mit der Einf\u00fchrung und arbeite dich durch die Kapitel!</p> Los geht's! \ud83d\ude80 <p>Ressourcen</p> <p>Dieser Kurs basiert auf folgenden Quellen:</p> <ul> <li>Datenbanken - Andreas de Vries; FH S\u00fcdwestfalen</li> <li>Datenbanken 1 - Nikolaus Augsten; Universit\u00e4t Salzburg</li> </ul> <p>Zur Ausarbeitung wurden generative Tools unterst\u00fctzend eingesetzt.</p>"},{"location":"database/abfragen/","title":"Abfragen von Daten","text":""},{"location":"database/abfragen/#daten-abfragen-mit-sql","title":"Daten abfragen mit SQL","text":"<p>Im vorherigen Kapitel haben wir gelernt, wie man Tabellen erstellt, Daten einf\u00fcgt und Daten auch einfach ausliest. Jetzt gehen wir einen Schritt weiter: Wir lernen, wie man gezielt nach Daten sucht, sie filtert, sortiert und analysiert - das Herzst\u00fcck jeder Datenbank!</p> <p>SQL ist eine deklarative Sprache: Wir beschreiben, was wir haben m\u00f6chten, nicht wie die Datenbank es finden soll. Das macht SQL m\u00e4chtig und gleichzeitig einfach zu lernen.</p>"},{"location":"database/abfragen/#die-grundstruktur-von-select","title":"Die Grundstruktur von <code>SELECT</code>","text":"<p>Im vorigen Kapitel haben wir bereits den <code>SELECT</code> Befehl kennengelernt. Doch neben dieser einfachen gezeigten Abfrage k\u00f6nnen wir auch noch mehr damit machen. Eine SELECT-Abfrage hat folgende Grundstruktur:</p> <pre><code>SELECT spalten\nFROM tabelle\n-- \u2193\u2193 Weitere Klauseln \u2193\u2193\nWHERE bedingung\nORDER BY sortierung;\n</code></pre> <p>\u00dcbersetzt bedeutet das:</p> <p>\"W\u00e4hle diese Spalten aus dieser Tabelle, aber nur die Zeilen, die diese Bedingung erf\u00fcllen, und sortiere das Ergebnis nach dieser Sortierung.\"</p> <p>Wir werden uns nun in diesem Kapitel ansehen, welche weiteren M\u00f6glichkeiten wir haben, um Daten aus einer Datenbank abzufragen und schon einfache Analysen durchf\u00fchren.</p> Datenbank-Setup <p>F\u00fcr die Beispiele in diesem Kapitel verwenden wir eine Lieferketten-Datenbank. Diese verwaltet Materiallieferungen f\u00fcr ein produzierendes Unternehmen - ein typisches Szenario im Wirtschaftsingenieurwesen.</p> <p>F\u00fchre folgenden Code aus, um die Beispieldatenbank zu erstellen:</p> <pre><code>-- Datenbank erstellen\nCREATE DATABASE lieferkette_db;\n\n-- Zur Datenbank wechseln\n\\c lieferkette_db\n\n-- Tabelle f\u00fcr Lieferungen erstellen\nCREATE TABLE lieferungen (\n    lieferung_id INTEGER PRIMARY KEY,\n    lieferant VARCHAR(100),\n    material VARCHAR(100),\n    menge INTEGER,\n    preis_pro_einheit NUMERIC(10,2),\n    lieferdatum DATE,\n    status VARCHAR(20),\n    zielstandort VARCHAR(50)\n);\n\n-- Beispieldaten einfuegen\nINSERT INTO lieferungen VALUES\n(1, 'Stahlwerk Salzgitter', 'Stahlblech 2mm', 500, 12.50, '2024-03-15', 'Geliefert', 'Lager Nord'),\n(2, 'Aluminium AG', 'Aluminiumprofile', 200, 25.00, '2024-03-18', 'Geliefert', 'Lager Sued'),\n(3, 'Kunststoff GmbH', 'PVC-Platten', 150, 8.75, '2024-03-20', 'In Transit', 'Lager Nord'),\n(4, 'Stahlwerk Salzgitter', 'Stahlprofil IPE200', 80, 45.00, '2024-03-22', 'Bestellt', 'Lager Ost'),\n(5, 'Schrauben Meyer', 'Sechskantschrauben M8', 5000, 0.15, '2024-03-16', 'Geliefert', 'Lager Nord'),\n(6, 'Aluminium AG', 'Aluminiumblech 3mm', 300, 18.50, '2024-03-25', 'Bestellt', 'Lager Sued'),\n(7, 'Elektronik Weber', 'Sensoren Typ A', 100, 12.90, '2024-03-19', 'Geliefert', 'Lager Ost'),\n(8, 'Kunststoff GmbH', 'Gummiband 10mm', 800, 2.30, '2024-03-21', 'In Transit', 'Lager Nord'),\n(9, 'Schrauben Meyer', 'Muttern M8', 5000, 0.08, '2024-03-17', 'Geliefert', 'Lager Nord'),\n(10, 'Elektronik Weber', 'Kabelbaum 5m', 50, 22.00, '2024-03-28', 'Bestellt', 'Lager Ost');\n</code></pre> <p>Diese Tabelle enth\u00e4lt typische Lieferinformationen: Lieferant, Material, Menge, Preis, Lieferdatum, Status und Zielstandort.</p>"},{"location":"database/abfragen/#filtern-mit-where","title":"Filtern mit <code>WHERE</code>","text":"<p>Bislang haben wir bei der Abfrage von Daten entweder alles abgefragt (<code>*</code>) oder gewisse Spalten ausgew\u00e4hlt. Welche Zeilen / Tuples aber geladen werden sollen, haben wir bisher nicht eingrenzt. Daher wurden zuvor alle Zeilen geladen.</p> <p>Mit der WHERE-Klausel k\u00f6nnen wir aber nun Datens\u00e4tze nach bestimmten Kriterien filtern. Der grundlegende Syntax lautet wiefolgt:</p> <pre><code>SELECT *\nFROM tabellenname\nWHERE bedingung;\n</code></pre>"},{"location":"database/abfragen/#einfache-vergleiche","title":"Einfache Vergleiche","text":"<p>Wie auch in der Mathematik stehen uns f\u00fcr die Bedingungen verschiedenste Vergleichsoperatoren zur Verf\u00fcgung.</p> Operator Bedeutung Beispiel <code>=</code> Gleich <code>status = 'Geliefert'</code> <code>!=</code> oder <code>&lt;&gt;</code> Ungleich <code>status != 'Bestellt'</code> <code>&gt;</code> Gr\u00f6\u00dfer als <code>menge &gt; 100</code> <code>&lt;</code> Kleiner als <code>preis_pro_einheit &lt; 10</code> <code>&gt;=</code> Gr\u00f6\u00dfer oder gleich <code>menge &gt;= 500</code> <code>&lt;=</code> Kleiner oder gleich <code>preis_pro_einheit &lt;= 5</code> <p>Mit diesen Vergleichsoperatoren k\u00f6nnen wir nun Filter-Bedingungen f\u00fcr die Abfrage der Daten festlegen.</p> Lieferungen von spezifischen Lieferanten <pre><code>-- Alle Lieferungen von 'Stahlwerk Salzgitter'\nSELECT * FROM lieferungen\nWHERE lieferant = 'Stahlwerk Salzgitter';\n</code></pre> Output<pre><code> lieferung_id |      lieferant       |      material       | menge | preis_pro_einheit | lieferdatum |  status  | zielstandort\n--------------+----------------------+---------------------+-------+-------------------+-------------+----------+--------------\n            1 | Stahlwerk Salzgitter | Stahlblech 2mm      |   500 |             12.50 | 2024-03-15  | Geliefert| Lager Nord\n            4 | Stahlwerk Salzgitter | Stahlprofil IPE200  |    80 |             45.00 | 2024-03-22  | Bestellt | Lager Ost\n(2 rows)\n</code></pre> weitere Beispiele <p>Menge gr\u00f6\u00dfer 200</p> <pre><code>-- Lieferungen mit Menge gr\u00f6\u00dfer 200\nSELECT lieferant, material, menge\nFROM lieferungen\nWHERE menge &gt; 200;\n</code></pre> Output<pre><code>      lieferant       |       material        | menge\n----------------------+-----------------------+-------\n Stahlwerk Salzgitter | Stahlblech 2mm        |   500\n Schrauben Meyer      | Sechskantschrauben M8 |  5000\n Aluminium AG         | Aluminiumblech 3mm    |   300\n Kunststoff GmbH      | Gummiband 10mm        |   800\n Schrauben Meyer      | Muttern M8            |  5000\n(5 rows)\n</code></pre> <p>Alle au\u00dfer gelieferte Lieferungen</p> <pre><code>-- Alle au\u00dfer gelieferte Lieferungen\nSELECT lieferant, material, status\nFROM lieferungen\nWHERE status != 'Geliefert';\n</code></pre> Output<pre><code>      lieferant       |      material      |   status\n----------------------+--------------------+------------\n Kunststoff GmbH      | PVC-Platten        | In Transit\n Stahlwerk Salzgitter | Stahlprofil IPE200 | Bestellt\n Aluminium AG         | Aluminiumblech 3mm | Bestellt\n Kunststoff GmbH      | Gummiband 10mm     | In Transit\n Elektronik Weber     | Kabelbaum 5m       | Bestellt\n(5 rows)\n</code></pre>"},{"location":"database/abfragen/#verknupfte-vergleiche","title":"Verkn\u00fcpfte Vergleiche","text":"<p>Neben den einfachen Vergleichen k\u00f6nnen wir mehrere Bedingungen auch zu komplexeren verkn\u00fcpften Vergleichen kombinieren. Dazu stehen uns <code>AND</code>, <code>OR</code>, <code>NOT</code>, <code>IN</code> und <code>BETWEEN</code> zur Verf\u00fcgung.</p> Operator Bedeutung Beispiel <code>AND</code> Beide Bedingungen m\u00fcssen erf\u00fcllt sein <code>menge &gt; 100 AND status = 'Geliefert'</code> <code>OR</code> Mindestens eine Bedingung muss erf\u00fcllt sein <code>status = 'In Transit' OR status = 'Bestellt'</code> <code>NOT</code> Negiert eine Bedingung <code>NOT status = 'Geliefert'</code> <code>IN</code> Pr\u00fcft, ob Wert in einer Liste enthalten ist <code>lieferant IN ('Aluminium AG', 'Elektronik Weber')</code> <code>BETWEEN</code> Pr\u00fcft, ob Wert in einem Bereich liegt (inklusiv) <code>menge BETWEEN 100 AND 500</code> Inklusive <p><code>BETWEEN</code> ist inklusive - beide Grenzen sind mit eingeschlossen</p> Gro\u00dfe Lieferungen die bereits geliefert wurden <pre><code>-- Gro\u00dfe Lieferungen (&gt; 200) die bereits geliefert wurden\nSELECT lieferant, material, menge, status\nFROM lieferungen\nWHERE menge &gt; 200 AND status = 'Geliefert';\n</code></pre> Output<pre><code>      lieferant       |       material        | menge |  status\n----------------------+-----------------------+-------+-----------\n Stahlwerk Salzgitter | Stahlblech 2mm        |   500 | Geliefert\n Schrauben Meyer      | Sechskantschrauben M8 |  5000 | Geliefert\n Schrauben Meyer      | Muttern M8            |  5000 | Geliefert\n(3 rows)\n</code></pre> weitere Beispiele <p>Lieferungen die in Transit oder Bestellt sind</p> <pre><code>-- Lieferungen die in Transit oder Bestellt sind\nSELECT lieferant, material, status\nFROM lieferungen\nWHERE status = 'In Transit' OR status = 'Bestellt';\n</code></pre> Output<pre><code>      lieferant       |      material      |   status\n----------------------+--------------------+------------\n Kunststoff GmbH      | PVC-Platten        | In Transit\n Stahlwerk Salzgitter | Stahlprofil IPE200 | Bestellt\n Aluminium AG         | Aluminiumblech 3mm | Bestellt\n Kunststoff GmbH      | Gummiband 10mm     | In Transit\n Elektronik Weber     | Kabelbaum 5m       | Bestellt\n(5 rows)\n</code></pre> <p>Alle au\u00dfer gelieferte Lieferungen</p> <pre><code>-- Alle au\u00dfer gelieferte Lieferungen\nSELECT lieferant, material, status\nFROM lieferungen\nWHERE NOT status = 'Geliefert';\n</code></pre> Output<pre><code>      lieferant       |      material      |   status\n----------------------+--------------------+------------\n Kunststoff GmbH      | PVC-Platten        | In Transit\n Stahlwerk Salzgitter | Stahlprofil IPE200 | Bestellt\n Aluminium AG         | Aluminiumblech 3mm | Bestellt\n Kunststoff GmbH      | Gummiband 10mm     | In Transit\n Elektronik Weber     | Kabelbaum 5m       | Bestellt\n(5 rows)\n</code></pre> <p>Lieferungen zwischen 100 und 500 Einheiten</p> <pre><code>-- Lieferungen zwischen 100 und 500 Einheiten\nSELECT lieferant, material, menge\nFROM lieferungen\nWHERE menge BETWEEN 100 AND 500;\n</code></pre> Output<pre><code>      lieferant       |      material      | menge\n----------------------+--------------------+-------\n Stahlwerk Salzgitter | Stahlblech 2mm     |   500\n Aluminium AG         | Aluminiumprofile   |   200\n Kunststoff GmbH      | PVC-Platten        |   150\n Aluminium AG         | Aluminiumblech 3mm |   300\n Elektronik Weber     | Sensoren Typ A     |   100\n(5 rows)\n</code></pre> <p>Lieferungen von bestimmten Lieferanten</p> <pre><code>-- Lieferungen von bestimmten Lieferanten\nSELECT lieferant, material, menge\nFROM lieferungen\nWHERE lieferant IN ('Aluminium AG', 'Elektronik Weber');\n</code></pre> <p>Das ist \u00e4quivalent zu:</p> <pre><code>WHERE lieferant = 'Aluminium AG' OR lieferant = 'Elektronik Weber'\n</code></pre> Output<pre><code>    lieferant     |      material      | menge\n------------------+--------------------+-------\n Aluminium AG     | Aluminiumprofile   |   200\n Aluminium AG     | Aluminiumblech 3mm |   300\n Elektronik Weber | Sensoren Typ A     |   100\n Elektronik Weber | Kabelbaum 5m       |    50\n(4 rows)\n</code></pre>"},{"location":"database/abfragen/#muster-mit-like","title":"Muster mit <code>LIKE</code>","text":"<p>Oft wissen wir nicht genau, nach welchem exakten Wert wir suchen. Zum Beispiel:</p> <ul> <li>\"Alle Materialien, die mit 'Stahl' beginnen\"</li> <li>\"Alle Lieferanten, die 'GmbH' im Namen haben\"</li> <li>\"Alle Materialien mit einem Namen der L\u00e4nge 10\"</li> </ul> <p>F\u00fcr solche Mustersuchen verwenden wir den <code>LIKE</code>-Operator zusammen mit Platzhaltern. Platzhalter sind spezielle Zeichen, welche f\u00fcr ein beliebiges oder mehrere beliebige Zeichen stehen. Die mag im ersten Moment etwas verwirrend klingen, ist aber in der Praxis durchaus praktisch. Im Grunde gibt es zwei verschiedene Platzhalter:</p> Platzhalter Bedeutung Beispiel <code>%</code> Steht f\u00fcr beliebig viele Zeichen (auch 0) <code>'Stahl%'</code> findet \"Stahlblech\", \"Stahlprofil\" <code>_</code> Steht f\u00fcr genau ein beliebiges Zeichen <code>'M_8'</code> findet \"M08\", \"M18\", \"M88\" <p>Mit diesen zwei Zeichen und deren Bedeutung k\u00f6nnen wir bereits komplexere Abfragen erstellen. Beispielhaft Muster f\u00fcr <code>LIKE</code> Abfragen sind</p> LIKE-Muster Bedeutung <code>LIKE 'Stahl%'</code> Beginnt mit \"Stahl\" <code>LIKE '%GmbH%'</code> Enth\u00e4lt \"GmbH\" irgendwo im Text <code>LIKE '%Weber'</code> Endet mit \"Weber\" <code>LIKE '_l%'</code> Das zweite Zeichen ist \"l\" <code>LIKE '____'</code> Genau 4 Zeichen lang <code>LIKE 'A___%'</code> Beginnt mit \"A\" und hat mindestens 4 Zeichen Alle Lieferanten filtern <pre><code>-- Alle Lieferanten mit 'GmbH' im Namen\nSELECT lieferant, material\nFROM lieferungen\nWHERE lieferant LIKE '%GmbH%';\n</code></pre> Output<pre><code>    lieferant    |    material\n-----------------+----------------\n Kunststoff GmbH | PVC-Platten\n Kunststoff GmbH | Gummiband 10mm\n(2 rows)\n</code></pre> weitere Beispiele <p>Alle Materialien die mit 'Stahl' beginnen</p> <pre><code>-- Alle Materialien die mit 'Stahl' beginnen\nSELECT lieferant, material\nFROM lieferungen\nWHERE material LIKE 'Stahl%';\n</code></pre> Output<pre><code>      lieferant       |      material\n----------------------+--------------------\n Stahlwerk Salzgitter | Stahlblech 2mm\n Stahlwerk Salzgitter | Stahlprofil IPE200\n(2 rows)\n</code></pre> <p>Alle Lieferanten deren Name mit 'Weber' endet</p> <pre><code>-- Alle Lieferanten deren Name mit 'Weber' endet\nSELECT lieferant, material\nFROM lieferungen\nWHERE lieferant LIKE '%Weber';\n</code></pre> Output<pre><code>    lieferant     |    material\n------------------+----------------\n Elektronik Weber | Sensoren Typ A\n Elektronik Weber | Kabelbaum 5m\n(2 rows)\n</code></pre> <p>Alle Materialien die 'blech' im Namen enthalten</p> <pre><code>-- Alle Materialien die 'blech' enthalten\nSELECT lieferant, material\nFROM lieferungen\nWHERE material LIKE '%blech%';\n</code></pre> Output<pre><code>      lieferant       |      material\n----------------------+--------------------\n Stahlwerk Salzgitter | Stahlblech 2mm\n Aluminium AG         | Aluminiumblech 3mm\n(2 rows)\n</code></pre> Gro\u00df-/Kleinschreibung <p><code>LIKE</code> ist in PostgreSQL standardm\u00e4\u00dfig case-sensitive. Dies bedeutet, es wird sehr genau zwischen Gro\u00df- und Kleinschreibung unterschieden!</p> <ul> <li><code>LIKE 'stahl%'</code> findet NICHT \"Stahlblech\"</li> <li><code>LIKE 'Stahl%'</code> findet \"Stahlblech\"</li> </ul> <p>F\u00fcr case-insensitive Suche verwende ILIKE:</p> <pre><code>SELECT material FROM lieferungen WHERE material ILIKE 'stahl%';  -- findet \"Stahlblech\"\n</code></pre> Output<pre><code>      material\n--------------------\n Stahlblech 2mm\n Stahlprofil IPE200\n(2 rows)\n</code></pre>"},{"location":"database/abfragen/#sortieren-mit-order-by","title":"Sortieren mit <code>ORDER BY</code>","text":"<p>Standardm\u00e4\u00dfig werden Abfrageergebnisse in keiner bestimmten Reihenfolge zur\u00fcckgegeben - die Datenbank entscheidet selbst, wie sie die Daten ausgibt. Wenn wir eine definierte Sortierung ben\u00f6tigen (z.B. alphabetisch, nach Datum, nach Zahlen), verwenden wir <code>ORDER BY</code>.</p> <p>Mit <code>ORDER BY</code> k\u00f6nnen wir Ergebnisse nach einer oder mehreren Spalten sortieren - sowohl aufsteigend (A\u2192Z, 0\u21929, alt\u2192neu) als auch absteigend (Z\u2192A, 9\u21920, neu\u2192alt). Der grundlegende Syntax lautet wiefolgt:</p> <pre><code>SELECT *\nFROM tabellenname\nORDER BY attribut ASC; -- oder DESC\n</code></pre> <p>Die zwei verschiedenen Sortierrichtungen k\u00f6nnen mit Hilfe zweier Schl\u00fcsselw\u00f6rter ausgew\u00e4hlt werden:</p> Schl\u00fcsselwort Bedeutung Beispiel <code>ASC</code> Aufsteigend (ascending) - Standard! A\u2192Z, 0\u21929, 2020\u21922024 <code>DESC</code> Absteigend (descending) Z\u2192A, 9\u21920, 2024\u21922020 Lieferant und Menge sortieren <pre><code>-- Erst nach Lieferant (A-Z), dann nach Menge (gr\u00f6\u00dfte zuerst)\nSELECT lieferant, material, menge\nFROM lieferungen\nORDER BY lieferant ASC, menge DESC;\n</code></pre> Output<pre><code>      lieferant       |       material        | menge\n----------------------+-----------------------+-------\n Aluminium AG         | Aluminiumblech 3mm    |   300\n Aluminium AG         | Aluminiumprofile      |   200\n Elektronik Weber     | Sensoren Typ A        |   100\n Elektronik Weber     | Kabelbaum 5m          |    50\n Kunststoff GmbH      | Gummiband 10mm        |   800\n Kunststoff GmbH      | PVC-Platten           |   150\n Schrauben Meyer      | Sechskantschrauben M8 |  5000\n Schrauben Meyer      | Muttern M8            |  5000\n Stahlwerk Salzgitter | Stahlblech 2mm        |   500\n Stahlwerk Salzgitter | Stahlprofil IPE200    |    80\n(10 rows)\n</code></pre> <p>Erkl\u00e4rung: Die Daten werden zuerst nach <code>lieferant</code> alphabetisch sortiert. Innerhalb jedes Lieferanten werden die Materialien nach <code>menge</code> absteigend sortiert (gr\u00f6\u00dfte zuerst).</p> weitere Beispiele <p>Nach Material sortiert (A-Z)</p> <pre><code>-- Nach Material sortiert (A-Z)\nSELECT material, lieferant\nFROM lieferungen\nORDER BY material;  -- ASC ist Standard und kann weggelassen werden\n</code></pre> Output<pre><code>       material        |      lieferant\n-----------------------+----------------------\n Aluminiumblech 3mm    | Aluminium AG\n Aluminiumprofile      | Aluminium AG\n Gummiband 10mm        | Kunststoff GmbH\n Kabelbaum 5m          | Elektronik Weber\n Muttern M8            | Schrauben Meyer\n PVC-Platten           | Kunststoff GmbH\n Sechskantschrauben M8 | Schrauben Meyer\n Sensoren Typ A        | Elektronik Weber\n Stahlblech 2mm        | Stahlwerk Salzgitter\n Stahlprofil IPE200    | Stahlwerk Salzgitter\n(10 rows)\n</code></pre> <p>Nach Lieferdatum sortiert (neueste zuerst)</p> <pre><code>-- Nach Lieferdatum sortiert (neueste zuerst)\nSELECT material, lieferdatum\nFROM lieferungen\nORDER BY lieferdatum DESC;\n</code></pre> Output<pre><code>       material        | lieferdatum\n-----------------------+-------------\n Kabelbaum 5m          | 2024-03-28\n Aluminiumblech 3mm    | 2024-03-25\n Stahlprofil IPE200    | 2024-03-22\n Gummiband 10mm        | 2024-03-21\n PVC-Platten           | 2024-03-20\n Sensoren Typ A        | 2024-03-19\n Aluminiumprofile      | 2024-03-18\n Muttern M8            | 2024-03-17\n Sechskantschrauben M8 | 2024-03-16\n Stahlblech 2mm        | 2024-03-15\n(10 rows)\n</code></pre> <p>Alternativ kann man auch die Position der Spalte im SELECT angeben:</p> <pre><code>SELECT lieferant, material, lieferdatum\nFROM lieferungen\nORDER BY 3 DESC;  -- Sortiere nach der 3. Spalte (lieferdatum)\n</code></pre> Nicht empfohlen! <p>Diese Schreibweise ist weniger lesbar und sollte nur in Ausnahmef\u00e4llen verwendet werden. Besser ist es, den Spaltennamen explizit anzugeben: <code>ORDER BY lieferdatum DESC</code></p> <p>Sortierung und NULL-Werte</p> <p>Was passiert eigentlich, wenn eine Spalte NULL-Werte (leere Eintr\u00e4ge) enth\u00e4lt?</p> Quelle: devhumor Standardverhalten <p>Das Standardverhalten in PostgreSQL ist:</p> <ul> <li>Bei <code>ASC</code> (aufsteigend): NULL-Werte kommen am Ende</li> <li>Bei <code>DESC</code> (absteigend): NULL-Werte kommen am Anfang</li> </ul> <p>Doch dieses Verhalten ist nicht in Stein gemeiselt. Wir k\u00f6nnen dies auch gezielt steuern und festlegen.</p> <pre><code>-- NULL-Werte zuerst, dann aufsteigend sortieren\nORDER BY spalte ASC NULLS FIRST;\n\n-- NULL-Werte am Ende, dann aufsteigend sortieren\nORDER BY spalte ASC NULLS LAST;\n</code></pre>"},{"location":"database/abfragen/#ergebnismenge-begrenzen-mit-limit","title":"Ergebnismenge begrenzen mit <code>LIMIT</code>","text":"<p>Alle bisher kennengelernten Befehle liefern uns als R\u00fcckgabe s\u00e4mtliche Datens\u00e4tze - sofern diese die geforderten Bedingungen erf\u00fcllen. Manchmal m\u00f6chten wir aber nur eine bestimmte Anzahl - zum Beispiel: Die Top 5 der teuersten Lieferungen.</p> <p>Daf\u00fcr gibt es die Klausel <code>LIMIT</code> und optional dazugeh\u00f6rigt <code>OFFSET</code>.</p> Klausel <p>Eine Klausel ist ein Teil einer SQL-Anweisung, der eine bestimmte Aufgabe hat. Beispielsweise:</p> <ul> <li><code>SELECT</code>-Klausel</li> <li><code>FROM</code>-Klausel</li> <li><code>WHERE</code>-Klausel</li> <li><code>GROUP BY</code>-Klausel</li> <li><code>HAVING</code>-Klausel</li> <li><code>ORDER BY</code>-Klausel</li> </ul>"},{"location":"database/abfragen/#grundlegende-verwendung","title":"Grundlegende Verwendung","text":"<p>Wir starten mit der einfachen Verwendung von <code>LIMIT</code> zur Limitierung der R\u00fcckgabeergebnisse. Der grundlegende Syntax kann wiefolgt beschrieben werden:</p> <pre><code>SELECT spalten\nFROM tabelle\nORDER BY sortierung\nLIMIT anzahl;\n</code></pre> <p>Wenn wir diesem Syntax folgen k\u00f6nnen wir beispielsweise die ersten 3 Ergebnisse zur\u00fcckgeben lassen.</p> Die 3 g\u00fcnstigsten Materialien <pre><code>-- Die 3 g\u00fcnstigsten Materialien (nach Preis pro Einheit)\nSELECT material, preis_pro_einheit, lieferant\nFROM lieferungen\nORDER BY preis_pro_einheit ASC\nLIMIT 3;\n</code></pre> Output<pre><code>       material        | preis_pro_einheit |    lieferant\n-----------------------+-------------------+-----------------\n Muttern M8            |              0.08 | Schrauben Meyer\n Sechskantschrauben M8 |              0.15 | Schrauben Meyer\n Gummiband 10mm        |              2.30 | Kunststoff GmbH\n(3 rows)\n</code></pre> LIMIT ohne ORDER BY <p>Wenn du <code>LIMIT</code> ohne <code>ORDER BY</code> verwendest, ist das Ergebnis nicht vorhersehbar - die Datenbank gibt irgendwelche Zeilen zur\u00fcck! Verwende daher immer ORDER BY zusammen mit LIMIT.</p>"},{"location":"database/abfragen/#zeilen-uberspringen-mit-offset","title":"Zeilen \u00fcberspringen mit <code>OFFSET</code>","text":"<p>Nun kann es vorkommen, dass wir nicht die ersten N Ergebnisse auslesen m\u00f6chten, sondern erst bei einem gewissen Wert beginnend. Mit <code>OFFSET</code> k\u00f6nnen wir die ersten N Zeilen \u00fcberspringen und erst ab einer bestimmten Position Ergebnisse zur\u00fcckgeben.</p> <pre><code>SELECT spalten\nFROM tabelle\nORDER BY sortierung\nLIMIT anzahl OFFSET \u00fcberspringen;\n</code></pre> Werte ab 3. Position auslesen <pre><code>-- \u00dcberspringe die ersten 3, zeige die n\u00e4chsten 3 Lieferungen (nach Datum)\nSELECT material, lieferdatum, lieferant\nFROM lieferungen\nORDER BY lieferdatum ASC\nLIMIT 3 OFFSET 3;\n</code></pre> Output<pre><code>     material     | lieferdatum |    lieferant\n------------------+-------------+------------------\n Aluminiumprofile | 2024-03-18  | Aluminium AG\n Sensoren Typ A   | 2024-03-19  | Elektronik Weber\n PVC-Platten      | 2024-03-20  | Kunststoff GmbH\n(3 rows)\n</code></pre> <p>Erkl\u00e4rung: Die ersten 3 Lieferungen (15., 16., 17. M\u00e4rz) werden \u00fcbersprungen, dann werden die n\u00e4chsten 3 zur\u00fcckgegeben.</p> Paginierung <p><code>LIMIT</code> und <code>OFFSET</code> werden h\u00e4ufig f\u00fcr Paginierung verwendet - z.B. wenn eine Webseite Ergebnisse seitenweise anzeigt.</p> <p>Bei sehr gro\u00dfen OFFSET-Werten (z.B. <code>OFFSET 10000</code>) kann die Performance leiden, da die Datenbank alle \u00fcbersprungenen Zeilen dennoch laden und durchlaufen muss. F\u00fcr gro\u00dfe Datens\u00e4tze gibt es bessere Ans\u00e4tze (z.B. Cursor-basierte Paginierung).</p>"},{"location":"database/abfragen/#aggregatfunktionen-daten-zusammenfassen","title":"Aggregatfunktionen - Daten zusammenfassen","text":"<p>Bisher haben wir einzelne Datens\u00e4tze abgefragt - jede Zeile wurde einzeln zur\u00fcckgegeben. Manchmal interessieren uns aber zusammengefasste Informationen \u00fcber viele Datens\u00e4tze:</p> <ul> <li>Wie viele Lieferungen haben wir insgesamt?</li> <li>Was ist die durchschnittliche Menge?</li> <li>Was ist der h\u00f6chste oder niedrigste Preis?</li> <li>Was ist die Summe aller Mengen?</li> </ul> <p>F\u00fcr solche statistischen Auswertungen verwenden wir Aggregatfunktionen. Sie fassen mehrere Zeilen zu einem einzigen Ergebniswert zusammen.</p> <pre><code>SELECT funktion AS ergebnisname\nFROM tabelle;\n</code></pre> <p>Neben der Funktion ist es sinnvoll einen Alias Namen f\u00fcr das Ergebnis der Berechnung mittels <code>AS</code> zum vergeben.</p> Funktion Beschreibung Anwendungsfall <code>COUNT(*)</code> Z\u00e4hlt alle Zeilen Wie viele Lieferungen gibt es? <code>COUNT(spalte)</code> Z\u00e4hlt Nicht-NULL-Werte Wie viele Lieferungen haben Status-Eintrag? <code>SUM(spalte)</code> Summe aller Werte Gesamtmenge aller Lieferungen? <code>AVG(spalte)</code> Durchschnittswert Durchschnittlicher Preis pro Einheit? <code>MIN(spalte)</code> Kleinster Wert G\u00fcnstigster Preis? <code>MAX(spalte)</code> Gr\u00f6\u00dfter Wert Teuerster Preis? G\u00fcnstigster und teuerster Preis pro Einheit <pre><code>-- G\u00fcnstigster und teuerster Preis pro Einheit\nSELECT\n    MIN(preis_pro_einheit) AS guenstigster_preis,\n    MAX(preis_pro_einheit) AS teuerster_preis\nFROM lieferungen;\n</code></pre> Output<pre><code> guenstigster_preis | teuerster_preis\n--------------------+-----------------\n               0.08 |           45.00\n(1 row)\n</code></pre> <p>Erkl\u00e4rung: Wir wir sehen, k\u00f6nnen wir mehrere Aggregatfunktionen in einer Abfrage kombinieren.</p> weitere Beispiele <p>Wie viele Lieferungen gibt es insgesamt?</p> <pre><code>-- Wie viele Lieferungen gibt es insgesamt?\nSELECT COUNT(*) AS anzahl_lieferungen\nFROM lieferungen;\n</code></pre> Output<pre><code> anzahl_lieferungen\n--------------------\n                 10\n(1 row)\n</code></pre> <p>Erkl\u00e4rung: <code>COUNT(*)</code> z\u00e4hlt alle Zeilen in der Tabelle - unabh\u00e4ngig vom Inhalt.</p> <p>Wie viele Lieferungen sind bereits geliefert?</p> <pre><code>-- Wie viele Lieferungen sind bereits geliefert?\nSELECT COUNT(*) AS anzahl_geliefert\nFROM lieferungen\nWHERE status = 'Geliefert';\n</code></pre> Output<pre><code> anzahl_geliefert\n------------------\n                5\n(1 row)\n</code></pre> <p>Erkl\u00e4rung: <code>COUNT(*)</code> z\u00e4hlt alle Zeilen in der Tabelle - unabh\u00e4ngig vom Inhalt. <code>WHERE status = 'Geliefert'</code> filtert die Zeilen, die den Status \"Geliefert\" haben.</p> <p>Durchschnittlicher Preis pro Einheit</p> <pre><code>-- Durchschnittlicher Preis pro Einheit\nSELECT AVG(preis_pro_einheit) AS durchschnittspreis\nFROM lieferungen;\n</code></pre> Output<pre><code> durchschnittspreis\n---------------------\n 14.7180000000000000\n(1 row)\n</code></pre> <p>Erkl\u00e4rung: <code>AVG()</code> berechnet den arithmetischen Mittelwert aller Preise pro Einheit.</p> <p>Gesamtmenge aller Lieferungen</p> <pre><code>-- Gesamtmenge aller Lieferungen\nSELECT SUM(menge) AS gesamtmenge\nFROM lieferungen;\n</code></pre> Output<pre><code> gesamtmenge\n-------------\n       12180\n(1 row)\n</code></pre> <p>Hinweis: <code>SUM()</code> funktioniert nur mit numerischen Spalten (INTEGER, NUMERIC, etc.)</p> NULL-Werte werden ignoriert <p>Aggregatfunktionen (au\u00dfer <code>COUNT(*)</code>) ignorieren NULL-Werte!</p> <ul> <li><code>COUNT(spalte)</code> z\u00e4hlt nur Nicht-NULL-Werte</li> <li><code>AVG(spalte)</code> berechnet den Durchschnitt nur aus vorhandenen Werten</li> <li><code>SUM(spalte)</code> summiert nur vorhandene Werte</li> </ul>"},{"location":"database/abfragen/#gruppieren-mit-group-by","title":"Gruppieren mit <code>GROUP BY</code>","text":"<p>Mit den Aggregatfunktionen k\u00f6nnen wir bereits einfache Analysen unseres Datensatzes durchf\u00fchren. Wir k\u00f6nnen Summen bilden, Mittelwerte berechnen oder Werte z\u00e4hlen. Doch h\u00e4ufig kann es sein, dass wir diese Analysen nach gewissen Gruppen unterteilen wollen:</p> <ul> <li>Wie viele Lieferungen gibt es pro Lieferant?</li> <li>Was ist die durchschnittliche Menge pro Zielstandort?</li> <li>Wie viele Lieferungen gibt es pro Status?</li> </ul> <p>Um diese Fragen zu beantworten, verwenden wir <code>GROUP BY</code> - es fasst Zeilen mit gleichen Werten zusammen und erlaubt Aggregationen pro Gruppe.</p> <pre><code>SELECT gruppenspalte, aggregatfunktion(spalte)\nFROM tabelle\nGROUP BY gruppenspalte;\n</code></pre> Wie viele Lieferungen gibt es pro Lieferant? <pre><code>-- Wie viele Lieferungen gibt es pro Lieferant?\nSELECT lieferant, COUNT(*) AS anzahl\nFROM lieferungen\nGROUP BY lieferant;\n</code></pre> Output<pre><code>      lieferant       | anzahl\n----------------------+--------\n Schrauben Meyer      |      2\n Stahlwerk Salzgitter |      2\n Elektronik Weber     |      2\n Aluminium AG         |      2\n Kunststoff GmbH      |      2\n(5 rows)\n</code></pre> <p>Erkl\u00e4rung: Die Datenbank gruppiert alle Lieferungen nach <code>lieferant</code> und z\u00e4hlt, wie viele Lieferungen in jeder Gruppe sind.</p> weiteres Beispiel <p>G\u00fcnstigste und teuerste Lieferung pro Lieferant</p> <pre><code>-- G\u00fcnstigste und teuerste Lieferung pro Lieferant\nSELECT\n    lieferant,\n    MIN(preis_pro_einheit) AS guenstigster,\n    MAX(preis_pro_einheit) AS teuerster\nFROM lieferungen\nGROUP BY lieferant;\n</code></pre> Output<pre><code>      lieferant       | guenstigster | teuerster\n----------------------+--------------+-----------\n Schrauben Meyer      |         0.08 |      0.15\n Stahlwerk Salzgitter |        12.50 |     45.00\n Elektronik Weber     |        12.90 |     22.00\n Aluminium AG         |        18.50 |     25.00\n Kunststoff GmbH      |         2.30 |      8.75\n(5 rows)\n</code></pre> <p>Die <code>GROUP BY</code> Klausel wird fast ausschlie\u00dflich in Kombination mit einer Aggregatfunktion verwendet. Prinzipiell ist es syntaktisch erlaubt ein <code>GROUP BY</code> ohne Aggregation zu verwenden - semantisch ist es aber meist sinnlos. Das Ergebnis w\u00e4re ident mit jenem von <code>DISTINCT</code> - es liefert nur die einzigartigen Werte einer Spalte.</p> <p>Spannend wird es, wenn wir mehrere Aggregatfunktionen gleichzeitig auf dieselbe Gruppierung anwenden. Damit k\u00f6nnen wir umfassendere Statistiken \u00fcber unseren Datensatz erzeugen.</p> Umfassende Statistik pro Zielstandort <pre><code>SELECT\n    zielstandort,\n    COUNT(*) AS anzahl,\n    SUM(menge) AS gesamtmenge,\n    AVG(preis_pro_einheit) AS durchschnittspreis\nFROM lieferungen\nGROUP BY zielstandort\nORDER BY anzahl DESC;\n</code></pre> Output<pre><code> zielstandort | anzahl | gesamtmenge | durchschnittspreis\n--------------+--------+-------------+---------------------\n Lager Nord   |      5 |       11450 |  4.7560000000000000\n Lager Ost    |      3 |         230 | 26.6333333333333333\n Lager Sued   |      2 |         500 | 21.7500000000000000\n(3 rows)\n</code></pre> <p>Erkl\u00e4rung: F\u00fcr jeden Zielstandort sehen wir die Anzahl der Lieferungen, die Gesamtmenge und den durchschnittlichen Preis pro Einheit.</p> <p>Um unsere Analyse noch weiter zu verfeinern, k\u00f6nnen wir auch mehreren Spalten gleichzeitig gruppieren. Dabei wird jede einzigartige Kombination der Spaltenwerte separat aufgef\u00fchrt und die entsprechenden Analysen durchgef\u00fchrt.</p> Gruppierung nach Zielstandort UND Status <pre><code>SELECT\n    zielstandort,\n    status,\n    COUNT(*) AS anzahl\nFROM lieferungen\nGROUP BY zielstandort, status\nORDER BY anzahl DESC;\n</code></pre> Output<pre><code> zielstandort |   status   | anzahl\n--------------+------------+--------\n Lager Nord   | Geliefert  |      3\n Lager Nord   | In Transit |      2\n Lager Ost    | Bestellt   |      2\n Lager Ost    | Geliefert  |      1\n Lager Sued   | Bestellt   |      1\n Lager Sued   | Geliefert  |      1\n(6 rows)\n</code></pre> <p>Erkl\u00e4rung: Jede Kombination aus <code>zielstandort</code> und <code>status</code> bildet eine eigene Gruppe.</p> SELECT-Regel f\u00fcr GROUP BY <p>Wenn du <code>GROUP BY</code> verwendest, d\u00fcrfen nur </p> <ol> <li>Spalten, die in GROUP BY stehen</li> <li>Aggregatfunktionen</li> </ol> <p>in der <code>SELECT</code> Klausel vorkommen. Dies bedeutet, dass nachfolgendes Beispiel zu einem Fehler f\u00fchren w\u00fcrde:</p> <pre><code>SELECT lieferant, material, COUNT(*) AS anzahl  -- \u2717 material steht nicht in GROUP BY!\nFROM lieferungen\nGROUP BY lieferant;\n</code></pre> Output<pre><code>ERROR:  Spalte \u00bblieferungen.material\u00ab muss in der GROUP-BY-Klausel erscheinen oder in einer Aggregatfunktion verwendet werden\nLINE 1: SELECT lieferant, material, COUNT(*) AS anzahl  -- ? materia...\n                          ^\n</code></pre> <p>Warum? Wenn wir nach <code>lieferant</code> gruppieren, gibt es in der Gruppe \"Aluminium AG\" zwei verschiedene Materialien (\"Aluminiumprofile\" und \"Aluminiumblech 3mm\"). Die Datenbank wei\u00df nicht, welches sie anzeigen soll!</p> ORDER BY mit GROUP BY <p>Nach der Gruppierung k\u00f6nnen wir das Ergebnis mit <code>ORDER BY</code> sortieren:</p> <pre><code>SELECT lieferant, COUNT(*) AS anzahl\nFROM lieferungen\nGROUP BY lieferant\nORDER BY anzahl DESC;  -- Sortiere nach Anzahl (absteigend)\n</code></pre> <p>Wir k\u00f6nnen nach:</p> <ul> <li>Der Gruppenspalte sortieren: <code>ORDER BY lieferant</code></li> <li>Einem Aggregat-Ergebnis sortieren: <code>ORDER BY anzahl DESC</code></li> </ul>"},{"location":"database/abfragen/#gruppen-filtern-mit-having","title":"Gruppen filtern mit <code>HAVING</code>","text":"<p>Mit <code>WHERE</code> haben wir bis jetzt einzelne Zeilen vor der Gruppierung filtern. Was aber, wenn wir Gruppen nach ihrer Aggregation filtern m\u00f6chten?</p> <p>Zum Beispiel:</p> <ul> <li>Welche Lieferanten haben mehr als 100 Einheiten geliefert?</li> <li>Welche Zielstandorte haben einen durchschnittlichen Preis \u00fcber 20 EUR?</li> </ul> <p>Hier kommt <code>HAVING</code> ins Spiel - es filtert Gruppen nach Aggregationsergebnissen.</p> <pre><code>SELECT gruppenspalte, aggregatfunktion(spalte)\nFROM tabelle\nGROUP BY gruppenspalte\nHAVING bedingung_f\u00fcr_aggregat;\n</code></pre> <p>Der Unterschied zwischen  <code>WHERE</code> und <code>HAVING</code> kann wiefolgt zusammengefasst werden</p> Aspekt WHERE HAVING Filtert Einzelne Zeilen Gruppen (nach Aggregation) Zeitpunkt Vor GROUP BY Nach GROUP BY Kann verwenden Spalten, einfache Vergleiche Aggregatfunktionen (COUNT, AVG, etc.) Beispiel <code>WHERE status = 'Geliefert'</code> <code>HAVING COUNT(*) &gt; 2</code> Zielstandorte mit durchschnittlichem Preis &gt; 10 EUR <pre><code>-- Zielstandorte mit durchschnittlichem Preis &gt; 10 EUR\nSELECT\n    zielstandort,\n    AVG(preis_pro_einheit) AS durchschnittspreis,\n    COUNT(*) AS anzahl\nFROM lieferungen\nGROUP BY zielstandort\nHAVING AVG(preis_pro_einheit) &gt; 10;\n</code></pre> Output<pre><code> zielstandort | durchschnittspreis  | anzahl\n--------------+---------------------+--------\n Lager Ost    | 26.6333333333333333 |      3\n Lager Sued   | 21.7500000000000000 |      2\n(2 rows)\n</code></pre> <p>Erkl\u00e4rung: Nur Zielstandorte, deren durchschnittlicher Preis \u00fcber 10 EUR liegt, werden angezeigt.</p> weitere Beispiele <p>Lieferanten mit mehr als 1 Lieferung</p> <pre><code>-- Lieferanten mit mehr als 1 Lieferung\nSELECT lieferant, COUNT(*) AS anzahl\nFROM lieferungen\nGROUP BY lieferant\nHAVING COUNT(*) &gt; 1;\n</code></pre> Output<pre><code>      lieferant       | anzahl\n----------------------+--------\n Schrauben Meyer      |      2\n Stahlwerk Salzgitter |      2\n Elektronik Weber     |      2\n Aluminium AG         |      2\n Kunststoff GmbH      |      2\n(5 rows)\n</code></pre> <p>Erkl\u00e4rung: Erst werden die Lieferungen nach Lieferant gruppiert und gez\u00e4hlt. Dann werden nur die Gruppen angezeigt, die mehr als 1 Lieferung haben.</p> <p>Zielstandorte mit mehr als 1 gelieferter Lieferung</p> <pre><code>-- Zielstandorte mit mehr als 1 gelieferter Lieferung\nSELECT zielstandort, COUNT(*) AS anzahl_geliefert\nFROM lieferungen\nWHERE status = 'Geliefert'      -- Filtert Zeilen VOR Gruppierung\nGROUP BY zielstandort\nHAVING COUNT(*) &gt; 1;        -- Filtert Gruppen NACH Aggregation\n</code></pre> Output<pre><code> zielstandort | anzahl_geliefert\n--------------+------------------\n Lager Nord   |                3\n(1 row)\n</code></pre> <p>Ablauf:</p> <ol> <li><code>WHERE</code> filtert alle Zeilen \u2192 nur Lieferungen mit Status \"Geliefert\"</li> <li><code>GROUP BY</code> gruppiert nach Zielstandort</li> <li><code>COUNT(*)</code> z\u00e4hlt Lieferungen pro Zielstandort</li> <li><code>HAVING</code> filtert Gruppen \u2192 nur Standorte mit mehr als 1 Lieferung</li> </ol> <p>Lieferanten mit Gesamtmenge &gt; 200 UND durchschnittlichem Preis &lt; 20</p> <pre><code>-- Lieferanten mit Gesamtmenge &gt; 200 UND durchschnittlichem Preis &lt; 20\nSELECT\n    lieferant,\n    SUM(menge) AS gesamtmenge,\n    AVG(preis_pro_einheit) AS durchschnittspreis\nFROM lieferungen\nGROUP BY lieferant\nHAVING SUM(menge) &gt; 200 AND AVG(preis_pro_einheit) &lt; 20;\n</code></pre> Output<pre><code>    lieferant    | gesamtmenge |   durchschnittspreis\n-----------------+-------------+------------------------\n Schrauben Meyer |       10000 | 0.11500000000000000000\n Kunststoff GmbH |         950 |     5.5250000000000000\n(2 rows)\n</code></pre> <p>Erkl\u00e4rung: Kombiniert mehrere HAVING-Bedingungen mit <code>AND</code> - nur Lieferanten mit Gesamtmenge &gt; 200 UND durchschnittlichem Preis &lt; 20.</p> HAVING ohne GROUP BY? <p>Technisch ist <code>HAVING</code> ohne <code>GROUP BY</code> erlaubt - die gesamte Tabelle wird dann als eine einzige Gruppe behandelt was in den allermeisten F\u00e4llen sinnlos ist:</p> <pre><code>SELECT COUNT(*) AS anzahl\nFROM lieferungen\nHAVING COUNT(*) &gt; 5;\n</code></pre>"},{"location":"database/abfragen/#eindeutige-werte-mit-distinct","title":"Eindeutige Werte mit <code>DISTINCT</code>","text":"<p>Manchmal m\u00f6chten wir wissen, welche verschiedenen Werte in einer Spalte vorkommen - ohne Duplikate. Zum Beispiel: Welche verschiedenen Lieferanten gibt es?</p> <p>Daf\u00fcr verwenden wir DISTINCT - es entfernt Duplikate und zeigt jeden Wert nur einmal.</p> <pre><code>SELECT DISTINCT spalte\nFROM tabelle;\n</code></pre> Welche verschiedenen Lieferanten gibt es? <pre><code>-- Welche verschiedenen Lieferanten gibt es?\nSELECT DISTINCT lieferant\nFROM lieferungen;\n</code></pre> Output<pre><code>      lieferant\n----------------------\n Schrauben Meyer\n Stahlwerk Salzgitter\n Elektronik Weber\n Aluminium AG\n Kunststoff GmbH\n(5 rows)\n</code></pre> <p>Erkl\u00e4rung: Obwohl es 10 Lieferungen gibt, werden nur die 5 verschiedenen Lieferanten angezeigt (ohne Wiederholungen).</p> weitere Beispiele <p>Welche einzigartigen Kombinationen von Zielstandort und Status gibt es?</p> <pre><code>-- Welche einzigartigen Kombinationen von Zielstandort und Status gibt es?\nSELECT DISTINCT zielstandort, status\nFROM lieferungen\nORDER BY zielstandort, status;\n</code></pre> Output<pre><code> zielstandort |   status\n--------------+------------\n Lager Nord   | Geliefert\n Lager Nord   | In Transit\n Lager Ost    | Bestellt\n Lager Ost    | Geliefert\n Lager Sued   | Bestellt\n Lager Sued   | Geliefert\n(6 rows)\n</code></pre> <p>Erkl\u00e4rung: <code>DISTINCT</code> arbeitet hier auf der Kombination beider Spalten - jede einzigartige Kombination wird nur einmal angezeigt.</p> <p>Alle Zielstandorte alphabetisch sortiert</p> <pre><code>-- Alle Zielstandorte alphabetisch sortiert\nSELECT DISTINCT zielstandort\nFROM lieferungen\nORDER BY zielstandort;\n</code></pre> Output<pre><code> zielstandort\n--------------\n Lager Nord\n Lager Ost\n Lager Sued\n(3 rows)\n</code></pre> <p>Erkl\u00e4rung: <code>DISTINCT</code> kann mit <code>ORDER BY</code> kombiniert werden, um die eindeutigen Werte sortiert auszugeben.</p> <p>Welche Lieferanten haben bereits geliefert?</p> <pre><code>-- Welche Lieferanten haben bereits geliefert?\nSELECT DISTINCT lieferant\nFROM lieferungen\nWHERE status = 'Geliefert';\n</code></pre> Output<pre><code>      lieferant\n----------------------\n Aluminium AG\n Elektronik Weber\n Schrauben Meyer\n Stahlwerk Salzgitter\n(4 rows)\n</code></pre> <p>Erkl\u00e4rung: Erst werden die Zeilen mit <code>WHERE</code> gefiltert, dann werden die eindeutigen Lieferanten ermittelt.</p> Performance-Hinweis <p><code>DISTINCT</code> kann bei gro\u00dfen Tabellen langsam sein, da die Datenbank alle Zeilen verarbeiten und Duplikate entfernen muss. Wenn m\u00f6glich, kombiniere es mit <code>WHERE</code>, um die Datenmenge vorher zu reduzieren:</p> <pre><code>-- Besser: Erst filtern, dann DISTINCT\nSELECT DISTINCT lieferant\nFROM lieferungen\nWHERE preis_pro_einheit &gt; 10;  -- Reduziert Datenmenge\n</code></pre>"},{"location":"database/abfragen/#ubung","title":"\u00dcbung \u270d\ufe0f","text":"<p>Nun ist es an der Zeit, unser erlerntes Wissen auf unser Gesamtprojekt anzuwenden! In diesem Kapitel erweitern wir das Produktionsplanungssystem f\u00fcr TecGuy GmbH.</p> <p>Im vorherigen Kapitel haben wir die Datenbank <code>produktionsplanung_db</code> mit den Tabellen <code>produktionsauftraege</code> und <code>maschinen</code> erstellt.</p> \u00dcbungsvorbereitung - Datenbank zur\u00fccksetzen <p>Falls du das vorherige Kapitel nicht abgeschlossen hast oder neu starten m\u00f6chtest, f\u00fchre nachfolgendes Setup aus. Es l\u00f6scht alle bestehenden Daten und erstellt den korrekten Ausgangszustand f\u00fcr dieses Kapitel.</p> Setup <pre><code>-- Zu anderer Datenbank wechseln\n\\c postgres\n\n-- Zur Datenbank wechseln (oder neu erstellen)\nDROP DATABASE IF EXISTS produktionsplanung_db;\nCREATE DATABASE produktionsplanung_db;\n\\c produktionsplanung_db\n\n-- Tabelle f\u00fcr Maschinen erstellen\nCREATE TABLE maschinen (\n    maschinen_id INTEGER PRIMARY KEY,\n    maschinenname VARCHAR(100),\n    maschinentyp VARCHAR(50),\n    produktionshalle VARCHAR(50),\n    anschaffungsjahr INTEGER,\n    maschinenstatus VARCHAR(20),\n    wartungsintervall_tage INTEGER\n);\n\n-- Tabelle f\u00fcr Produktionsauftr\u00e4ge erstellen\nCREATE TABLE produktionsauftraege (\n    auftrag_id INTEGER PRIMARY KEY,\n    auftragsnummer VARCHAR(20),\n    kunde VARCHAR(100),\n    produkt VARCHAR(100),\n    menge INTEGER,\n    startdatum DATE,\n    lieferdatum DATE,\n    status VARCHAR(20),\n    maschinen_id INTEGER\n);\n\n-- Maschinen-Daten einf\u00fcgen\nINSERT INTO maschinen VALUES\n(1, 'CNC-Fraese Alpha', 'CNC-Fraese', 'Halle A', 2020, 'Aktiv', 90),\n(2, 'Drehbank Delta', 'Drehbank', 'Halle A', 2018, 'Aktiv', 120),\n(3, 'Presse Gamma', 'Presse', 'Halle B', 2019, 'Wartung', 60),\n(4, 'Schweissroboter Beta', 'Schweissroboter', 'Halle C', 2021, 'Aktiv', 90);\n\n-- Produktionsauftr\u00e4ge-Daten einf\u00fcgen (erste 4 aus Kapitel 1)\nINSERT INTO produktionsauftraege VALUES\n(1, 'AUF-2024-001', 'BMW AG', 'Getriebegeh\u00e4use', 500, '2024-04-01', '2024-04-15', 'In Produktion', 1),\n(2, 'AUF-2024-002', 'Audi AG', 'Kurbelwelle', 200, '2024-04-10', '2024-04-20', 'Geplant', 2),\n(3, 'AUF-2024-003', 'Mercedes-Benz', 'Pleuelstange', 350, '2024-04-05', '2024-04-18', 'In Produktion', 2),\n(4, 'AUF-2024-004', 'Porsche AG', 'Kolben', 150, '2024-04-12', '2024-04-25', 'Geplant', 4);\n</code></pre> <p>Wir erweitern nun unsere Tabelle mit zus\u00e4tzlichen Produktionsauftr\u00e4gen, um unsere Analysen aussagekr\u00e4ftiger zu machen:</p> <pre><code>-- Weitere Produktionsauftr\u00e4ge hinzuf\u00fcgen\nINSERT INTO produktionsauftraege VALUES\n(5, 'AUF-2024-005', 'BMW AG', 'Kurbelwelle', 300, '2024-04-15', '2024-04-22', 'In Produktion', 2),\n(6, 'AUF-2024-006', 'Volkswagen AG', 'Kolben', 400, '2024-04-20', '2024-04-28', 'Geplant', 4),\n(7, 'AUF-2024-007', 'Mercedes-Benz', 'Getriebegeh\u00e4use', 250, '2024-04-22', '2024-04-30', 'Abgeschlossen', 1),\n(8, 'AUF-2024-008', 'Audi AG', 'Pleuelstange', 180, '2024-04-08', '2024-04-16', 'Abgeschlossen', 2),\n(9, 'AUF-2024-009', 'Porsche AG', 'Kurbelwelle', 120, '2024-04-28', '2024-05-05', 'Geplant', 2),\n(10, 'AUF-2024-010', 'BMW AG', 'Kolben', 350, '2024-04-12', '2024-04-19', 'In Produktion', 4);\n</code></pre> Aufgabe 1: Einfache Abfragen mit WHERE <p>Zeige alle Auftr\u00e4ge ...</p> <ol> <li>... von BMW AG</li> <li>... mit Status \"In Produktion\"</li> <li>... mit einer Menge gr\u00f6\u00dfer als 200</li> <li>... f\u00fcr das Produkt \"Kolben\"</li> </ol> Aufgabe 2: Verkn\u00fcpfte Bedingungen <p>Zeige alle Auftr\u00e4ge ...</p> <ol> <li>... von BMW AG, die in Produktion sind</li> <li>... mit Lieferdatum zwischen dem 15. und 20. April</li> <li>... von BMW AG, Audi AG oder Mercedes-Benz</li> <li>... die nicht den Status \"Geplant\" haben</li> </ol> Aufgabe 3: Sortierung und Begrenzung <ol> <li>Sortiere alle Auftr\u00e4ge nach Lieferdatum (fr\u00fcheste zuerst)</li> <li>Zeige die 3 gr\u00f6\u00dften Auftr\u00e4ge (nach Menge)</li> <li>Sortiere alle Auftr\u00e4ge erst nach Kunde (A-Z), dann nach Menge (gr\u00f6\u00dfte zuerst)</li> <li>Zeige die Auftr\u00e4ge 4-6, wenn nach Lieferdatum sortiert</li> </ol> Aufgabe 4: Aggregationen und Statistiken <ol> <li>Wie viele Produktionsauftr\u00e4ge gibt es insgesamt?</li> <li>Was ist die Gesamtmenge aller Auftr\u00e4ge?</li> <li>Was ist die durchschnittliche Menge pro Auftrag?</li> <li>Was ist die kleinste und gr\u00f6\u00dfte Menge in einem Auftrag?</li> </ol> Aufgabe 5: Gruppierungen und Analysen <ol> <li>Wie viele Auftr\u00e4ge gibt es pro Kunde?</li> <li>Was ist die Gesamtmenge pro Produkt?</li> <li>Wie viele Auftr\u00e4ge gibt es pro Status?</li> <li>Was ist die durchschnittliche Menge pro Kunde?</li> </ol> Aufgabe 6: Erweiterte Analysen mit HAVING <ol> <li>Welche Kunden haben mehr als 2 Auftr\u00e4ge?</li> <li>Welche Produkte haben eine Gesamtmenge \u00fcber 600?</li> <li>Welche Kunden haben eine durchschnittliche Menge \u00fcber 250?</li> <li>Welche Produkte haben mehr als 1 Auftrag UND eine Gesamtmenge \u00fcber 700?</li> </ol> Aufgabe 7: Komplexe Abfragen (Kombinationen) <ol> <li>Zeige alle BMW AG Auftr\u00e4ge, die in Produktion sind, sortiert nach Lieferdatum</li> <li>Zeige die Top 3 Kunden nach Gesamtmenge (absteigend)</li> <li>Wie viele Auftr\u00e4ge haben Status \"In Produktion\" pro Produkt?</li> </ol>"},{"location":"database/abfragen/#zusammenfassung","title":"Zusammenfassung \ud83d\udccc","text":"<ul> <li>WHERE filtert Zeilen nach Bedingungen (<code>=</code>, <code>!=</code>, <code>&gt;</code>, <code>&lt;</code>, <code>&gt;=</code>, <code>&lt;=</code>)</li> <li>AND, OR, NOT kombinieren Bedingungen</li> <li>BETWEEN pr\u00fcft Wertebereiche, IN pr\u00fcft gegen eine Liste</li> <li>LIKE erm\u00f6glicht Mustersuche (<code>%</code> und <code>_</code> als Platzhalter)</li> <li>ORDER BY sortiert Ergebnisse (ASC aufsteigend, DESC absteigend)</li> <li>LIMIT begrenzt die Anzahl der Ergebnisse, OFFSET \u00fcberspringt Zeilen</li> <li>Aggregatfunktionen (COUNT, SUM, AVG, MIN, MAX) fassen Daten zusammen</li> <li>GROUP BY gruppiert Zeilen f\u00fcr Aggregationen</li> <li>HAVING filtert Gruppen (\u00e4hnlich wie WHERE, aber f\u00fcr Gruppen)</li> <li>DISTINCT entfernt Duplikate</li> </ul> <p>Im n\u00e4chsten Kapitel werden wir lernen, wie man Daten ver\u00e4ndert (INSERT, UPDATE, DELETE) und unser Produktionsplanungssystem weiter ausbauen!</p> Quelle: imgflip"},{"location":"database/ausblick/","title":"Ausblick","text":""},{"location":"database/ausblick/#ausblick-weiterfuhrende-themen","title":"Ausblick &amp; Weiterf\u00fchrende Themen","text":"The Journey Is Not Over Yet Declan Donnelly GIFfrom The Journey Is Not Over Yet GIFs \"Die Reise geht weiter...\""},{"location":"database/ausblick/#fast-geschafft","title":"Fast geschafft...","text":"<p>In den vorherigen Kapiteln hast du die Grundlagen relationaler Datenbanken mit PostgreSQL kennengelernt. Du kannst jetzt:</p> <ul> <li>\u2705 Datenbanken modellieren und entwerfen</li> <li>\u2705 Tabellen erstellen und Beziehungen definieren</li> <li>\u2705 Daten einf\u00fcgen, \u00e4ndern und l\u00f6schen</li> <li>\u2705 Komplexe Abfragen mit Joins und Aggregationen schreiben</li> <li>\u2705 Datenintegrit\u00e4t mit Constraints sicherstellen</li> <li>\u2705 Transaktionen f\u00fcr sichere Datenoperationen nutzen</li> </ul> <p>Doch die Welt der Datenbanken ist viel gr\u00f6\u00dfer als das, was wir bisher gesehen haben. In diesem abschlie\u00dfenden Kapitel werfen wir einen Blick \u00fcber den Tellerrand und schauen uns weiterf\u00fchrende Themen an, die in professionellen Umgebungen wichtig sind.</p> Wichtiger Hinweis <p>In diesem Kapitel wird ein Ausblick auf weiterf\u00fchrende Themen gegeben. Alle Code Snippets k\u00f6nnen wie bisher ausgef\u00fchrt und getestet werden. Eine detailierte Beschreibung und Erkl\u00e4rung der einzelnen Themen gibt es in diesem Kapitel nicht. Trotzdem kann jeder versuchen den Code nachzuvollziehen und gegebenenfalls mittels Recherche eine Erkl\u00e4rung zu finden. </p> Datenbank-Setup <p>F\u00fcr die folgenden Beispiele erstellen wir eine E-Commerce/Online-Shop-Datenbank. In dieser Datenbank werden Produkte, Bestellungen und Lagerbest\u00e4nde verwaltet.</p> <pre><code>-- Datenbank erstellen\nCREATE DATABASE shop_db;\n\n-- Zur Datenbank wechseln\n\\c shop_db\n\n-- Tabelle: Produkte\nCREATE TABLE produkte (\n    produkt_id SERIAL PRIMARY KEY,\n    produktname VARCHAR(200) NOT NULL,\n    kategorie VARCHAR(100),\n    preis NUMERIC(10, 2) NOT NULL CHECK (preis &gt;= 0),\n    lagerbestand INTEGER NOT NULL DEFAULT 0 CHECK (lagerbestand &gt;= 0),\n    aktiv BOOLEAN DEFAULT TRUE,\n    erstellt_am TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\n    letzte_aenderung TIMESTAMP\n);\n\n-- Tabelle: Bestellungen\nCREATE TABLE bestellungen (\n    bestell_id SERIAL PRIMARY KEY,\n    kunde VARCHAR(200) NOT NULL,\n    bestelldatum TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\n    status VARCHAR(50) DEFAULT 'offen',\n    gesamtbetrag NUMERIC(12, 2)\n);\n\n-- Tabelle: Bestellpositionen\nCREATE TABLE bestellpositionen (\n    position_id SERIAL PRIMARY KEY,\n    bestell_id INTEGER REFERENCES bestellungen(bestell_id) ON DELETE CASCADE,\n    produkt_id INTEGER REFERENCES produkte(produkt_id),\n    menge INTEGER NOT NULL CHECK (menge &gt; 0),\n    einzelpreis NUMERIC(10, 2) NOT NULL\n);\n\n-- Testdaten: Produkte\nINSERT INTO produkte (produktname, kategorie, preis, lagerbestand) VALUES\n('Laptop ThinkPad X1', 'Elektronik', 1299.99, 15),\n('Wireless Mouse MX3', 'Zubeh\u00f6r', 79.99, 50),\n('USB-C Hub 7-Port', 'Zubeh\u00f6r', 49.99, 30),\n('Monitor 27\" 4K', 'Elektronik', 449.99, 8),\n('Mechanische Tastatur', 'Zubeh\u00f6r', 129.99, 20),\n('Webcam HD Pro', 'Elektronik', 89.99, 0),\n('Laptop-Tasche Premium', 'Zubeh\u00f6r', 59.99, 25);\n\n-- Testdaten: Bestellungen\nINSERT INTO bestellungen (kunde, status, gesamtbetrag) VALUES\n('Anna Schmidt', 'abgeschlossen', 1429.98),\n('Thomas Weber', 'in_bearbeitung', 179.98),\n('Lisa Miller', 'offen', 449.99);\n\n-- Testdaten: Bestellpositionen\nINSERT INTO bestellpositionen (bestell_id, produkt_id, menge, einzelpreis) VALUES\n(1, 1, 1, 1299.99),  -- Anna: Laptop\n(1, 2, 1, 79.99),     -- Anna: Mouse\n(1, 3, 1, 49.99),     -- Anna: Hub\n(2, 2, 1, 79.99),     -- Thomas: Mouse\n(2, 5, 1, 129.99),    -- Thomas: Tastatur\n(3, 4, 1, 449.99);    -- Lisa: Monitor\n</code></pre>"},{"location":"database/ausblick/#views-sichten","title":"Views (Sichten)","text":"<p>Eine View ist eine virtuelle Tabelle, die auf einer oder mehreren echten Tabellen basiert. Views speichern keine eigenen Daten, sondern definieren eine gespeicherte Abfrage, die bei jedem Aufruf ausgef\u00fchrt wird. Allgemein lautet der Syntax</p> <pre><code>CREATE VIEW view_name AS\nSELECT spalte1, spalte2, ...\nFROM tabelle\nWHERE bedingung;\n</code></pre> <p>Betrachten wir das ganze anhand eines Beispiels.</p> View f\u00fcr verf\u00fcgbare Produkte <p>Wir erstellen eine View, die nur verf\u00fcgbare Produkte zeigt (auf Lager und aktiv):</p> <pre><code>CREATE VIEW verfuegbare_produkte AS\nSELECT\n    produkt_id,\n    produktname,\n    kategorie,\n    preis,\n    lagerbestand\nFROM produkte\nWHERE aktiv = TRUE\n  AND lagerbestand &gt; 0\nORDER BY produktname;\n</code></pre> <p>Anschlie\u00dfend k\u00f6nnen wir die View verwenden:</p> <pre><code>-- View verwenden wie eine normale Tabelle\nSELECT * FROM verfuegbare_produkte;\n</code></pre> Output<pre><code> produkt_id |      produktname      | kategorie  |  preis  | lagerbestand\n------------+-----------------------+------------+---------+--------------\n          7 | Laptop-Tasche Premium | Zubeh\u00f6r    |   59.99 |           25\n          1 | Laptop ThinkPad X1    | Elektronik | 1299.99 |           15\n          5 | Mechanische Tastatur  | Zubeh\u00f6r    |  129.99 |           20\n          4 | Monitor 27\" 4K        | Elektronik |  449.99 |            8\n          3 | USB-C Hub 7-Port      | Zubeh\u00f6r    |   49.99 |           30\n          2 | Wireless Mouse MX3    | Zubeh\u00f6r    |   79.99 |           50\n(6 rows)\n</code></pre> weitere Beispiele <p>Eine komplexere View kann mehrere Tabellen kombinieren:</p> <pre><code>CREATE VIEW bestelluebersicht AS\nSELECT\n    b.bestell_id,\n    b.kunde,\n    b.bestelldatum,\n    b.status,\n    COUNT(bp.position_id) AS anzahl_artikel,\n    SUM(bp.menge * bp.einzelpreis) AS gesamtbetrag\nFROM bestellungen b\nLEFT JOIN bestellpositionen bp ON b.bestell_id = bp.bestell_id\nGROUP BY b.bestell_id, b.kunde, b.bestelldatum, b.status\nORDER BY b.bestelldatum DESC;\n</code></pre> <pre><code>SELECT * FROM bestelluebersicht;\n</code></pre> Output<pre><code> bestell_id |    kunde     |        bestelldatum        |     status     | anzahl_artikel | gesamtbetrag\n------------+--------------+----------------------------+----------------+----------------+--------------\n          3 | Lisa Miller  | 2025-11-26 09:45:08.313595 | offen          |              1 |       449.99\n          2 | Thomas Weber | 2025-11-26 09:45:08.313595 | in_bearbeitung |              2 |       209.98\n          1 | Anna Schmidt | 2025-11-26 09:45:08.313595 | abgeschlossen  |              3 |      1429.97\n(3 rows)\n</code></pre> <p>Views haben wir nahezu alles im Leben Vor- und Nachteile.  Diese wind nachfolgend aufgelistet. </p> Vorteile Nachteile \u2705 Vereinfachung komplexer Joins \u274c Performance-Einbu\u00dfen bei komplexen Views \u2705 Sicherheit durch Datenbeschr\u00e4nkung \u274c Eingeschr\u00e4nkte Daten\u00e4nderung (UPDATE/INSERT) \u2705 Konsistente Abfragelogik \u274c Abh\u00e4ngigkeit von Basistabellen \u2705 Abstraktion der Datenstruktur View l\u00f6schen <p>Views k\u00f6nnen nat\u00fcrlich auch wieder gel\u00f6scht werden mit folgendem Syntax:</p> <pre><code>DROP VIEW IF EXISTS verfuegbare_produkte;\nDROP VIEW IF EXISTS bestelluebersicht;\n</code></pre> Output<pre><code>DROP VIEW\nDROP VIEW\n</code></pre>"},{"location":"database/ausblick/#stored-procedures-functions","title":"Stored Procedures &amp; Functions","text":"<p>Stored Procedures (gespeicherte Prozeduren) und Functions sind vordefinierte SQL-Programme, die in der Datenbank gespeichert werden.</p> <p>Die Unterschiede zwischen Prozeduren und Funktionen sind:</p> Eigenschaft Function Procedure R\u00fcckgabewert Muss einen Wert zur\u00fcckgeben Kein oder mehrere Werte Verwendung In SELECT-Statements Mit CALL aufgerufen Daten\u00e4nderung Sollte keine Daten \u00e4ndern Darf Daten \u00e4ndern Funktion f\u00fcr Produktverf\u00fcgbarkeit <pre><code>CREATE OR REPLACE FUNCTION ist_verfuegbar(p_produkt_id INTEGER, p_menge INTEGER)\nRETURNS BOOLEAN AS $$\nBEGIN\n    RETURN EXISTS (\n        SELECT 1\n        FROM produkte\n        WHERE produkt_id = p_produkt_id\n          AND aktiv = TRUE\n          AND lagerbestand &gt;= p_menge\n    );\nEND;\n$$ LANGUAGE plpgsql;\n</code></pre> <p>Verwendung:</p> <pre><code>-- Pr\u00fcfen, ob 10 St\u00fcck Laptop verf\u00fcgbar sind\nSELECT produktname, ist_verfuegbar(produkt_id, 10) AS verfuegbar\nFROM produkte;\n</code></pre> Output<pre><code>      produktname      | verfuegbar\n-----------------------+------------\n Laptop ThinkPad X1    | t\n Wireless Mouse MX3    | t\n USB-C Hub 7-Port      | t\n Monitor 27\" 4K        | f\n Mechanische Tastatur  | t\n Webcam HD Pro         | f\n Laptop-Tasche Premium | t\n(7 rows)\n</code></pre> Procedure f\u00fcr Bestellung erstellen <pre><code>CREATE OR REPLACE PROCEDURE erstelle_bestellung(\n    p_kunde VARCHAR,\n    p_produkt_id INTEGER,\n    p_menge INTEGER\n)\nLANGUAGE plpgsql AS $$\nDECLARE\n    v_bestell_id INTEGER;\n    v_preis NUMERIC;\nBEGIN\n    -- Preis holen\n    SELECT preis INTO v_preis FROM produkte WHERE produkt_id = p_produkt_id;\n\n    -- Bestellung erstellen\n    INSERT INTO bestellungen (kunde, status, gesamtbetrag)\n    VALUES (p_kunde, 'offen', v_preis * p_menge)\n    RETURNING bestell_id INTO v_bestell_id;\n\n    -- Bestellposition erstellen\n    INSERT INTO bestellpositionen (bestell_id, produkt_id, menge, einzelpreis)\n    VALUES (v_bestell_id, p_produkt_id, p_menge, v_preis);\n\n    -- Lagerbestand reduzieren\n    UPDATE produkte\n    SET lagerbestand = lagerbestand - p_menge\n    WHERE produkt_id = p_produkt_id;\n\n    RAISE NOTICE 'Bestellung % fuer Kunde % erstellt', v_bestell_id, p_kunde;\nEND;\n$$;\n</code></pre> <p>Verwendung:</p> <pre><code>CALL erstelle_bestellung('Max Mustermann', 1, 2);\n</code></pre> Output<pre><code>HINWEIS:  Bestellung 4 fuer Kunde Max Mustermann erstellt\n</code></pre>"},{"location":"database/ausblick/#trigger","title":"Trigger","text":"<p>Ein Trigger ist ein automatisch ausgef\u00fchrtes SQL-Programm, das bei bestimmten Ereignissen (INSERT, UPDATE, DELETE) aktiviert wird.</p> <p>Typische Anwendungsf\u00e4lle sind:</p> <ul> <li>Automatische Protokollierung von \u00c4nderungen</li> <li>Datenkonsistenz durch automatische Updates</li> <li>Durchsetzung von Gesch\u00e4ftsregeln</li> <li>Audit-Trails und Logging</li> </ul> Automatische Zeitstempel-Aktualisierung <pre><code>-- Trigger-Function erstellen\nCREATE OR REPLACE FUNCTION update_timestamp()\nRETURNS TRIGGER AS $$\nBEGIN\n    NEW.letzte_aenderung = CURRENT_TIMESTAMP;\n    RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n\n-- Trigger erstellen\nCREATE TRIGGER produkt_update_timestamp\nBEFORE UPDATE ON produkte\nFOR EACH ROW\nEXECUTE FUNCTION update_timestamp();\n</code></pre> <p>Wirkung: Jedes Mal, wenn ein Produkt ge\u00e4ndert wird, wird automatisch <code>letzte_aenderung</code> aktualisiert.</p> <pre><code>-- Produkt aktualisieren\nUPDATE produkte SET preis = 1199.99 WHERE produkt_id = 1;\n\n-- Zeitstempel wurde automatisch gesetzt\nSELECT produktname, preis, letzte_aenderung FROM produkte WHERE produkt_id = 1;\n</code></pre> Output<pre><code>    produktname     |  preis  |      letzte_aenderung\n--------------------+---------+----------------------------\n Laptop ThinkPad X1 | 1199.99 | 2025-11-26 09:55:40.404667\n(1 row)\n</code></pre> weitere Beispiele <p>Ein praktischeres Beispiel: Lagerbestand automatisch reduzieren, wenn eine Bestellposition erstellt wird.</p> <pre><code>-- Trigger-Function erstellen\nCREATE OR REPLACE FUNCTION reduziere_lagerbestand()\nRETURNS TRIGGER AS $$\nBEGIN\n    UPDATE produkte\n    SET lagerbestand = lagerbestand - NEW.menge\n    WHERE produkt_id = NEW.produkt_id;\n\n    -- Warnung, wenn Lagerbestand niedrig wird\n    IF (SELECT lagerbestand FROM produkte WHERE produkt_id = NEW.produkt_id) &lt; 5 THEN\n        RAISE NOTICE 'Warnung: Niedriger Lagerbestand fuer Produkt %', NEW.produkt_id;\n    END IF;\n\n    RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n\n-- Trigger erstellen\nCREATE TRIGGER nach_bestellposition_einfuegen\nAFTER INSERT ON bestellpositionen\nFOR EACH ROW\nEXECUTE FUNCTION reduziere_lagerbestand();\n</code></pre> <p>Wirkung: Bei jeder neuen Bestellposition wird automatisch der Lagerbestand reduziert.</p> <pre><code>-- Vor der Bestellung\nSELECT produktname, lagerbestand FROM produkte WHERE produkt_id = 4;\n</code></pre> Output<pre><code>  produktname   | lagerbestand\n----------------+--------------\n Monitor 27\" 4K |            8\n(1 row)\n</code></pre> <pre><code>-- Neue Bestellung erstellen\nINSERT INTO bestellungen (kunde, status) VALUES ('Peter Klein', 'offen');\nINSERT INTO bestellpositionen (bestell_id, produkt_id, menge, einzelpreis)\nVALUES (4, 4, 4, 449.99);\n\n-- Nach der Bestellung\nSELECT produktname, lagerbestand FROM produkte WHERE produkt_id = 4;\n</code></pre> Output<pre><code>HINWEIS:  Warnung: Niedriger Lagerbestand fuer Produkt 4\n\n  produktname   | lagerbestand\n----------------+--------------\n Monitor 27\" 4K |            5\n(1 row)\n</code></pre> <p>Typische Befehle im Zusammen hang mit Trigger sind:</p> Typ Zeitpunkt Verwendung <code>BEFORE</code> Vor der Operation Daten noch \u00e4ndern/validieren <code>AFTER</code> Nach der Operation Logging, Benachrichtigungen <code>FOR EACH ROW</code> F\u00fcr jede Zeile Zeilen-spezifische Logik <code>FOR EACH STATEMENT</code> Einmal pro Statement Statement-Level Logging"},{"location":"database/ausblick/#json-support-in-postgresql","title":"JSON-Support in PostgreSQL","text":"<p>PostgreSQL bietet native Unterst\u00fctzung f\u00fcr JSON-Daten, was flexible, semi-strukturierte Datenspeicherung erm\u00f6glicht.</p> Typ Speicherung Performance <code>JSON</code> Als Text Langsamer <code>JSONB</code> Bin\u00e4r (komprimiert) Schneller (empfohlen \u2705) Produkte mit flexiblen Attributen <pre><code>CREATE TABLE produkte_extended (\n    produkt_id SERIAL PRIMARY KEY,\n    produktname VARCHAR(200) NOT NULL,\n    kategorie VARCHAR(100),\n    preis NUMERIC(10, 2) NOT NULL,\n    attribute JSONB  -- Flexible zus\u00e4tzliche Produkteigenschaften\n);\n\nINSERT INTO produkte_extended (produktname, kategorie, preis, attribute) VALUES\n('Laptop ThinkPad X1', 'Elektronik', 1299.99,\n '{\"bildschirm\": \"14 Zoll\", \"prozessor\": \"Intel i7\", \"ram_gb\": 16, \"ssd_gb\": 512, \"farben\": [\"Schwarz\", \"Silber\"]}'::jsonb),\n('Wireless Mouse MX3', 'Zubeh\u00f6r', 79.99,\n '{\"dpi\": 4000, \"kabellos\": true, \"batterielaufzeit_tage\": 70, \"farben\": [\"Schwarz\", \"Wei\u00df\", \"Grau\"]}'::jsonb),\n('Monitor 27\" 4K', 'Elektronik', 449.99,\n '{\"aufloesung\": \"3840x2160\", \"bildwiederholrate_hz\": 60, \"panel_typ\": \"IPS\", \"hdr\": true}'::jsonb);\n</code></pre> <p>JSON-Abfragen:</p> <pre><code>-- Zugriff auf JSON-Felder\nSELECT produktname, attribute-&gt;&gt;'bildschirm' AS bildschirm, attribute-&gt;&gt;'prozessor' AS prozessor\nFROM produkte_extended\nWHERE attribute ? 'bildschirm';  -- Nur Produkte mit Bildschirm-Attribut\n</code></pre> Output<pre><code>    produktname     | bildschirm | prozessor\n--------------------+------------+-----------\n Laptop ThinkPad X1 | 14 Zoll    | Intel i7\n(1 row)\n</code></pre> <pre><code>-- Nach JSON-Werten filtern\nSELECT produktname, attribute-&gt;&gt;'ram_gb' AS ram\nFROM produkte_extended\nWHERE (attribute-&gt;&gt;'ram_gb')::integer &gt;= 16;\n</code></pre> Output<pre><code>    produktname     | ram\n--------------------+-----\n Laptop ThinkPad X1 | 16\n(1 row)\n</code></pre> <pre><code>-- JSON-Array durchsuchen\nSELECT produktname, attribute-&gt;'farben' AS verfuegbare_farben\nFROM produkte_extended\nWHERE attribute-&gt;'farben' ? 'Schwarz';  -- Produkte in Schwarz\n</code></pre> Output<pre><code>    produktname     |     verfuegbare_farben\n--------------------+-----------------------------\n Laptop ThinkPad X1 | [\"Schwarz\", \"Silber\"]\n Wireless Mouse MX3 | [\"Schwarz\", \"Wei\u00df\", \"Grau\"]\n(2 rows)\n</code></pre> Wann JSON verwenden? <p>Vorteile:</p> <ul> <li>\u2705 Flexibel f\u00fcr unterschiedliche Datenstrukturen</li> <li>\u2705 Keine Schema-\u00c4nderungen n\u00f6tig</li> <li>\u2705 Ideal f\u00fcr externe APIs und Logs</li> </ul> <p>Nachteile:</p> <ul> <li>\u274c Weniger performant als normale Spalten</li> <li>\u274c Schwieriger zu normalisieren</li> <li>\u274c Integrit\u00e4tspr\u00fcfungen komplizierter</li> </ul> <p>Faustregel: Verwende JSON f\u00fcr optionale, flexible Daten, aber nicht f\u00fcr kritische Gesch\u00e4ftslogik.</p> So accurate..!!\ud83d\ude13 byu/Abhi_mech007 inProgrammerHumor"},{"location":"database/ausblick/#backup-recovery","title":"Backup &amp; Recovery","text":"<p>Datenbanken speichern oft gesch\u00e4ftskritische Daten. Bei Hardware-Ausf\u00e4llen, Software-Fehlern oder menschlichen Fehlern ist ein Backup essentiell.</p> <p>Typische PostgreSQL Backup-Methoden sind:</p> Methode Beschreibung Anwendungsfall <code>pg_dump</code> Logisches Backup (SQL-Export) Einzelne Datenbank, portabel <code>pg_dumpall</code> Alle Datenbanken Kompletter Server-Export Physisches Backup Dateisystem-Level Kopie Gro\u00dfe Datenbanken, schnell Backup mit pg_dump verwenden <p>Folgende Befehle m\u00fcssen im Terminal (macOS) oder in der Powershell/CMD (Windows) eingegeben werden. Port (hier 5433) und Server (hier localhost) m\u00fcssen gegebenenfalls angepasst werden.</p> <p>Gesamte Datenbank sichern:</p> <pre><code>pg_dump -h localhost -p 5433 -U postgres shop_db &gt; shop_db_backup.sql\n</code></pre> <p>Nur Struktur (ohne Daten):</p> <pre><code>pg_dump -h localhost -p 5433 -U postgres --schema-only shop_db &gt; struktur.sql\n</code></pre> <p>Nur Daten (ohne Struktur):</p> <pre><code>pg_dump -h localhost -p 5433 -U postgres --data-only shop_db &gt; daten.sql\n</code></pre> <p>Bestimmte Tabelle sichern:</p> <pre><code>pg_dump -h localhost -p 5433 -U postgres -t produkte shop_db &gt; produkte_backup.sql\n</code></pre> <p>Wiederherstellen:</p> <pre><code>psql -h localhost -p 5433 -U postgres shop_db &lt; shop_db_backup.sql\n</code></pre>"},{"location":"database/ausblick/#zusammenfassung","title":"Zusammenfassung \ud83d\udccc","text":"<p>In diesem Kapitel haben wir einen Ausblick auf weiterf\u00fchrende Datenbankthemen erhalten:</p> <ul> <li>Views \u2013 Virtuelle Tabellen f\u00fcr vereinfachte Abfragen</li> <li>Stored Procedures &amp; Functions \u2013 Wiederverwendbare SQL-Programme</li> <li>Trigger \u2013 Automatische Aktionen bei Daten\u00e4nderungen</li> <li>JSON-Support \u2013 Flexible, semi-strukturierte Daten</li> <li>Backup &amp; Recovery \u2013 Datensicherung und -wiederherstellung</li> </ul>"},{"location":"database/ausblick/#abschlieende-gedanken","title":"Abschlie\u00dfende Gedanken \ud83c\udf89","text":"<p>Datenbanken sind das Herzst\u00fcck fast jeder modernen Anwendung. Egal ob Web-App, Mobile-App, Desktop-Software oder Data Science \u2013 \u00fcberall werden Daten gespeichert, verwaltet und analysiert.</p> <p>Das relationale Modell mit SQL ist seit \u00fcber 50 Jahren der Standard und wird auch in absehbarer Zukunft wichtig bleiben. Die Konzepte, die du gelernt hast \u2013 Normalisierung, Beziehungen, Joins, Transaktionen \u2013 sind universell anwendbar und werden dich in deiner gesamten IT-Karriere begleiten.</p> Gl\u00fcckwunsch! \ud83c\udf89 <p>Du hast das Ende dieses Kurses erreicht und alle wichtigen Grundlagen zu Datenbanken und SQL gelernt!</p> <p>Das hast du gemeistert:</p> <ul> <li>\u2705 Datenmodellierung und ER-Diagramme</li> <li>\u2705 SQL-Grundlagen (SELECT, INSERT, UPDATE, DELETE)</li> <li>\u2705 Komplexe Abfragen mit Joins und Aggregationen</li> <li>\u2705 Datenintegrit\u00e4t mit Constraints</li> <li>\u2705 Transaktionen und ACID-Prinzipien</li> <li>\u2705 Fortgeschrittene Konzepte und Ausblick</li> </ul> <p>Nutze dieses Wissen als Startpunkt f\u00fcr deine eigenen Datenbankprojekte!</p> <p>Viel Erfolg auf deiner Reise in die Welt der Datenbanken! \ud83d\ude80</p> Ende des Kurses \u2013 Aber nicht des Lernens!"},{"location":"database/einfuehrung/","title":"Einf\u00fchrung","text":""},{"location":"database/einfuehrung/#einfuhrung-in-datenbanken","title":"Einf\u00fchrung in Datenbanken","text":"<p>In den vorherigen Kapiteln haben wir uns mit Datenerfassung, -verarbeitung und -speicherung besch\u00e4ftigt. Wir haben gesehen, wie Daten von Sensoren erfasst, in bin\u00e4rer Form verarbeitet und auf verschiedenen Speichermedien wie RAM, SSD oder HDD gesichert werden.</p> <p>Doch was passiert, wenn wir gro\u00dfe Datenmengen strukturiert organisieren, effizient durchsuchen und gleichzeitig von mehreren Anwendungen nutzen m\u00f6chten? </p> <p>Hier sto\u00dfen einfache Dateisysteme schnell an ihre Grenzen.</p> <p>Die L\u00f6sung: Datenbanken - spezialisierte Systeme zur strukturierten Verwaltung von Daten.</p>"},{"location":"database/einfuehrung/#warum-datenbanken","title":"Warum Datenbanken?","text":"<p>Stellen wir uns vor, ein Produktionsbetrieb verwaltet seine Maschinendaten und Wartungsprotokolle in einer einfachen Excel-Tabelle oder einer CSV-Datei:</p> <pre><code>Maschinen-ID,Name,Standort,Anschaffungsjahr,Letzte_Wartung\nM001,CNC-Fr\u00e4se Alpha,Halle A,2019,2024-08-15\nM002,Drehbank Beta,Halle A,2021,2024-09-03\nM003,Schwei\u00dfroboter Gamma,Halle B,2020,2024-07-22\n</code></pre> <p>Das funktioniert am Anfang gut, aber sobald die Daten wachsen oder mehrere Personen gleichzeitig darauf zugreifen m\u00f6chten, treten Probleme auf:</p> <ul> <li>Keine Zugriffskontrolle - Jeder kann alle Daten sehen und \u00e4ndern (auch sensible Kostendaten)</li> <li>Datenverlust bei gleichzeitigem Schreiben - Wenn Wartungstechniker und Schichtleiter gleichzeitig Daten aktualisieren, k\u00f6nnen Informationen verloren gehen</li> <li>Inkonsistente Daten - Es gibt keine Regeln, die verhindern, dass ung\u00fcltige Daten eingegeben werden (z.B. Anschaffungsjahr = 2050)</li> <li>Schwierige Abfragen - Komplexe Fragen wie \"Welche Maschinen in Halle A ben\u00f6tigen in den n\u00e4chsten 30 Tagen eine Wartung?\" sind umst\u00e4ndlich</li> <li>Keine Beziehungen - Verbindungen zwischen Datens\u00e4tzen (z.B. Maschinen \u2194 Wartungsprotokolle \u2194 Ersatzteile) lassen sich kaum abbilden</li> </ul> <p>Datenbanken l\u00f6sen genau diese Probleme!</p> Snapchat gotta start learning SQL byu/Pranjaljhathegr8 incomputerscience"},{"location":"database/einfuehrung/#was-ist-eine-datenbank","title":"Was ist eine Datenbank?","text":"<p>Bevor wir tiefer einsteigen, kl\u00e4ren wir zun\u00e4chst die grundlegenden Begriffe:</p> Datenbank <p>Eine Datenbank ist eine organisierte Sammlung von strukturierten Daten, die elektronisch auf einem Computersystem gespeichert sind. Sie enth\u00e4lt die eigentlichen Informationen - die Inhalte.</p> <p>Beispiele aus dem industriellen Umfeld:</p> <ul> <li>Maschinendaten und Wartungsprotokolle in einer Produktionshalle</li> <li>Lagerbestandsdaten und Materialfluss in einem Logistikzentrum</li> <li>Produktionsdaten und Qualit\u00e4tskennzahlen (OEE, Ausschuss, Durchlaufzeiten)</li> <li>Lieferanten- und Bestelldaten im Einkauf</li> </ul> <p>Man kann sich eine Datenbank wie eine digitale Ablage vorstellen: Die Daten sind in einer bestimmten Struktur organisiert (z. B. in Tabellen, Dokumenten oder Graphen), damit sie effizient gespeichert, gefunden und verarbeitet werden k\u00f6nnen.</p> <p>Wichtig: Eine Datenbank ist nicht dasselbe wie eine einfache Datei (z. B. Excel, CSV). Sie ist speziell f\u00fcr die Verwaltung gro\u00dfer, komplexer Datenmengen konzipiert und bietet Funktionen wie:</p> <ul> <li>Strukturierte Organisation - Daten sind logisch geordnet (z. B. in Tabellen mit Spalten und Zeilen)</li> <li>Beziehungen - Verkn\u00fcpfungen zwischen verschiedenen Datens\u00e4tzen (z. B. Maschinen \u2194 Wartungsprotokolle \u2194 Ersatzteile)</li> <li>Persistenz - Daten bleiben dauerhaft erhalten, auch nach dem Neustart des Systems</li> </ul>"},{"location":"database/einfuehrung/#datenbank-vs-datenbankmanagementsystem","title":"Datenbank vs. Datenbankmanagementsystem","text":"<p>Die Begriffe Datenbank und Datenbankmanagementsystem werden oft synonym verwendet, haben aber eine wichtige Unterscheidung:</p> Datenbankmanagementsystem (DBMS) <p>Ein Datenbankmanagementsystem (DBMS) ist die Software, die Datenbanken erstellt, verwaltet und den Zugriff darauf erm\u00f6glicht. Es ist die \"Verwaltungszentrale\", die zwischen den Anwendungen und den Daten vermittelt.</p> <pre><code>flowchart TB\n    A[Benutzer / Anwendungen]:::peach --&gt; B[DBMS&lt;br/&gt;PostgreSQL, MySQL, MongoDB]:::teal\n    B --&gt; C[Datenbank 1&lt;br/&gt;produktions_db]:::peach\n    B --&gt; D[Datenbank 2&lt;br/&gt;lager_db]:::peach\n    B --&gt; E[Datenbank 3&lt;br/&gt;qualitaet_db]:::peach\n\n    classDef peach fill:#FFB482aa,stroke:#333,stroke-width:1px;\n    classDef teal fill:#009485aa,stroke:#333,stroke-width:2px;</code></pre> <p>Unterschied auf einen Blick:</p> Datenbank DBMS Was ist es? Die Daten selbst Die Software zur Verwaltung Beispiel <code>produktions_db</code>, <code>lager_db</code> PostgreSQL, MySQL, MongoDB Analogie Die Teile im Lager Das Lagerverwaltungssystem (ERP, Bestandsf\u00fchrung, Nachverfolgung) Funktion Speichert die Informationen Erm\u00f6glicht Zugriff, Sicherheit, Abfragen <p>Was macht ein DBMS?</p> <p>Ein DBMS bietet eine Vielzahl von Funktionen, die weit \u00fcber einfache Dateispeicherung hinausgehen:</p> <ul> <li>Datenverwaltung - Strukturiertes Speichern in Tabellen, Dokumenten oder Graphen</li> <li>Zugriffskontrolle - Wer darf welche Daten sehen oder \u00e4ndern?</li> <li>Konsistenzsicherung - Nur g\u00fcltige Daten werden gespeichert (z. B. keine negativen Semester)</li> <li>Mehrbenutzerzugriff - Mehrere Benutzer k\u00f6nnen gleichzeitig arbeiten, ohne sich gegenseitig zu st\u00f6ren</li> <li>Transaktionsverwaltung - \u00c4nderungen werden atomar durchgef\u00fchrt (alles oder nichts)</li> <li>Abfragesprache - SQL erm\u00f6glicht flexible und m\u00e4chtige Datenabfragen</li> <li>Datensicherheit - Backups, Wiederherstellung bei Fehlern</li> <li>Performance-Optimierung - Indizes und Caching f\u00fcr schnelle Abfragen</li> </ul> <p>Das DBMS ist die Vermittlungsschicht zwischen Anwendungen und den eigentlichen Daten. Es sorgt daf\u00fcr, dass alle Zugriffe koordiniert, sicher und effizient ablaufen.</p> Produktionsdatenbank <ul> <li>Die Datenbank (z.B. <code>produktions_db</code>) enth\u00e4lt alle Maschinendaten, Wartungsprotokolle, Produktionsauftr\u00e4ge etc.</li> <li>Das DBMS (z.B. PostgreSQL) verwaltet diese Datenbank:<ul> <li>Stellt sicher, dass keine ung\u00fcltigen Maschinen-IDs oder unm\u00f6gliche Wartungsdaten eingegeben werden</li> <li>Erlaubt der Instandhaltung, Wartungsprotokolle zu aktualisieren</li> <li>Erm\u00f6glicht dem Schichtleiter, Produktionsdaten abzurufen (aber keine Wartungskosten einzusehen!)</li> <li>Sorgt daf\u00fcr, dass bei gleichzeitigen Zugriffen von MES, ERP und Wartungs-Apps keine Daten verloren gehen</li> </ul> </li> </ul>"},{"location":"database/einfuehrung/#postgresql-unser-werkzeug","title":"PostgreSQL - Unser Werkzeug","text":"<p>In diesem Kurs verwenden wir PostgreSQL, eines der leistungsf\u00e4higsten und beliebtesten relationalen Datenbankmanagementsysteme (RDBMS) (was dies bedeutet, erfahren wir in einem sp\u00e4teren Kapitel).</p> Vorteile von PostgreSQL <ul> <li>Open Source &amp; kostenlos - Kann von jedem frei verwendet werden</li> <li>Plattformunabh\u00e4ngig - L\u00e4uft auf Windows, macOS und Linux</li> <li>Hohe Datenintegrit\u00e4t - Strenge Einhaltung von SQL-Standards</li> <li>Leistungsstark - Auch f\u00fcr gro\u00dfe Datenmengen geeignet</li> <li>Weit verbreitet - Wird in der Industrie h\u00e4ufig eingesetzt</li> </ul> <p>PostgreSQL speichert Daten in Tabellen - \u00e4hnlich wie Excel, aber mit viel mehr Funktionen und Sicherheit.</p>"},{"location":"database/einfuehrung/#installation-setup","title":"Installation &amp; Setup","text":"<p>Bevor wir mit Datenbanken arbeiten k\u00f6nnen, m\u00fcssen wir PostgreSQL und ein Client-Tool installieren.</p> Installation, Setup &amp; erster Test <p>Nachfolgend werden wir sehen, wie wir alle notwendigen Tools zum Umgang mit PostgreSQL aufsetzen und auch testen k\u00f6nnen. Folge der Anleitung und versuche alle Schritte erfolgreich durchzuf\u00fchren. </p>"},{"location":"database/einfuehrung/#schritt-1-postgresql-installieren","title":"Schritt 1: PostgreSQL installieren","text":"Windows macOS <ol> <li>Lade den Installer von postgresql.org/download/windows herunter (beim Erstellen der Unterlagen Version 18)</li> <li>F\u00fchre die Installation aus (alle Standardeinstellungen sind OK)</li> <li>Wichtig: Notiere dir das Passwort f\u00fcr den Benutzer <code>postgres</code>!</li> <li>Port: <code>5432</code> (Standard)</li> </ol> <p>Installationsschritte:</p> <p></p> ACHTUNG: Passwort merken \u2190 Zur\u00fcck Schritt 1 von 2 Weiter \u2192 \ud83d\udca1 Tipp: Nutze Pfeiltasten \u2190 \u2192 zum Navigieren Installation kontrollieren:<p></p> <ol> <li>Suche in der Windows Suchleiste nach psql. Es \u00f6ffnet sich ein Shell Fenster.</li> <li>Hier m\u00fcssen wir mehrere Informationen eingeben. Dabei k\u00f6nnen alle Standardeinstellungen \u00fcbernommen werden (einfach Enter klicken). Lediglich bei Password m\u00fcssen wir unser in der Installation gew\u00e4hltes Passwort eingeben. </li> <li>Anschlie\u00dfend geben wir folgenden Befehl ein <pre><code>SELECT version();\n</code></pre></li> <li>Als Ergebnis sollte die installierte Version wie nachfolgend angef\u00fchrt werden.</li> </ol> <p></p> <p></p> <ol> <li>Lade den Installer von postgresql.org/download/macosx herunter (beim Erstellen der Unterlagen Version 18)</li> <li>F\u00fchre die Installation aus (alle Standardeinstellungen sind OK)</li> <li>Wichtig: Notiere dir das Passwort f\u00fcr den Benutzer <code>postgres</code>!</li> <li>Port: <code>5432</code> (Standard)</li> </ol> <p>Installationsschritte:</p> <p></p> ACHTUNG: Passwort merken \u2190 Zur\u00fcck Schritt 1 von 2 Weiter \u2192 \ud83d\udca1 Tipp: Nutze Pfeiltasten \u2190 \u2192 zum Navigieren Installation kontrollieren:<p></p> <ol> <li>\u00d6ffne den Terminal (Cmd+Space, dann \"Terminal\" eingeben)</li> <li>F\u00fcge PostgreSQL zum PATH hinzu (damit du <code>psql</code> direkt aufrufen kannst):    <pre><code>echo 'export PATH=\"/Library/PostgreSQL/18/bin:$PATH\"' &gt;&gt; ~/.zshrc\nsource ~/.zshrc\n</code></pre></li> <li> <p>Pr\u00fcfe die Installation mit:    </p><pre><code>psql --version\n</code></pre>    Es sollte die installierte Version angezeigt werden (z.B. <code>psql (PostgreSQL) 18.x</code>)<p></p> </li> <li> <p>Verbinde dich mit der Datenbank:    </p><pre><code>psql -U postgres\n</code></pre><p></p> </li> <li>Gib dein bei der Installation gew\u00e4hltes Passwort ein und teste mit folgendem SQL-Befehl:    <pre><code>SELECT version();\n</code></pre></li> <li>Als Ergebnis sollte die installierte Version wie nachfolgend angef\u00fchrt werden.</li> </ol> <p></p> <p></p> Wichtig: Shell-Neustart <p>Falls <code>psql --version</code> nicht funktioniert, schlie\u00dfe das Terminal-Fenster komplett und \u00f6ffne ein neues. Alternativ kannst du auch <code>source ~/.zshrc</code> nochmals ausf\u00fchren.</p>"},{"location":"database/einfuehrung/#schritt-2-client-tool-installieren","title":"Schritt 2: Client-Tool installieren","text":"<p>Um mit PostgreSQL zu arbeiten, k\u00f6nnen wir neben der Komandozeile (CLI) auch ein Client-Tool verwenden. Der Vorteil besteht darin, dass das Client-Tool eine grafische Oberfl\u00e4che (GUI) besitzt und wir uns gewisse Dinge auch grafisch darstellen lassen k\u00f6nnen. Wir verwenden pgAdmin 4 - das offizielle, kostenlose PostgreSQL-Verwaltungstool. </p> CLI vs GUI <p>Wir werden in weiterer Folge vermehrt die Komandozeile verwenden. Dabei ist es uns m\u00f6glich, die ben\u00f6tigten Befehle kennenzulernen und diese auch besser zu verstehen. Sp\u00e4testens wenn man in Zukunft eine Software rund um die Datenbank bauen m\u00f6chte (sei es mit Python oder Javascript) werden diese Befehle ben\u00f6tigt. Das Client-Tool verwenden wir zur Kontrolle und zum besseren Verst\u00e4ndnis.</p> <p>pgAdmin 4 installieren</p>  Windows macOS <ol> <li>Gehe zu pgadmin.org/download</li> <li>W\u00e4hle dein Betriebssystem (Windows)</li> <li>Lade den Installer herunter (beim Erstellen der Unterlagen Version 9.9)</li> <li>F\u00fchre die Installation aus (alle Standardeinstellungen sind OK)</li> </ol> <p></p> \u2190 Zur\u00fcck Weiter \u2192 \ud83d\udca1 Tipp: Nutze Pfeiltasten \u2190 \u2192 zum Navigieren <p></p> <ol> <li>Gehe zu pgadmin.org/download</li> <li>W\u00e4hle dein Betriebssystem (macOS)</li> <li>Lade den Installer herunter (beim Erstellen der Unterlagen Version 9.9)</li> <li>F\u00fchre die Installation aus (alle Standardeinstellungen sind OK)</li> </ol> <p></p> \u2190 Zur\u00fcck Weiter \u2192 \ud83d\udca1 Tipp: Nutze Pfeiltasten \u2190 \u2192 zum Navigieren <p></p>"},{"location":"database/einfuehrung/#schritt-3-erste-verbindung-herstellen","title":"Schritt 3: Erste Verbindung herstellen","text":"<p>Jetzt verbinden wir pgAdmin mit unserer PostgreSQL-Datenbank.</p> <ol> <li>pgAdmin 4 \u00f6ffnen</li> <li>In der linken Sidebar: Bei \"Servers\" auf den Pfeil klicken, um bereits verf\u00fcgbare Server aufzulisten.</li> <li>Da wir bei der Installation von PostgreSQL bereits eine lokalen Server erzeugt haben, sollte hier nun bereits 'PostgreSQL 18' stehen. </li> <li> <p>Nach Eingabe des Passworts (welches wir bei der Installation gew\u00e4hlt haben) sind wir erfolgreich mit dem Server verbunden.</p> <p></p> \u2190 Zur\u00fcck Weiter \u2192 \ud83d\udca1 Tipp: Nutze Pfeiltasten \u2190 \u2192 zum Navigieren <p></p> </li> </ol> Verbindungsprobleme? <p>Wenn die Verbindung fehlschl\u00e4gt, pr\u00fcfe:</p> <ul> <li>L\u00e4uft PostgreSQL?<ul> <li>Windows: Task-Manager \u2192 Dienste \u2192 \"postgresql-x64-18\"</li> <li>macOS: Terminal \u00f6ffnen und eingeben: <code>pg_isready</code></li> </ul> </li> <li>Ist das PostgreSQL-Passwort korrekt</li> <li>Ist der Port (meistens 5432) frei und nicht von einer Firewall blockiert?</li> </ul>"},{"location":"database/einfuehrung/#deine-erste-datenbank","title":"Deine erste Datenbank","text":"<p>Jetzt erstellen wir unsere erste eigene Datenbank! </p> Quelle: blazesql <p>In pgAdmin klicken wir auf der linken Seite auf 'PSQL Tool Workspace' und w\u00e4hlen unseren bereits existierenden Server aus. Anschlie\u00dfend klicken wir auf 'Connect &amp; Open PSQL' (es kann sein, dass wir nochmals das Passwort eingeben m\u00fcssen)</p> <p>Nun sind wir wieder in unserer Komandozeilen Darstellung und k\u00f6nnen einen ersten SQL-Befehl kennenlernen: </p> <pre><code>CREATE DATABASE produktions_db;\n</code></pre> Was ist SQL? <p>SQL (Structured Query Language) ist die Sprache, mit der wir mit Datenbanken kommunizieren. Alle Befehle - vom Erstellen einer Tabelle bis zur Abfrage von Daten - werden in SQL geschrieben.</p> <p>Wenn man sich den Befehl ansieht, erkennt man, dass eine neue Datenbank erzeugt werden soll und diese den namen <code>produktions_db</code> haben soll. Wenn wir diesen Befehl in die Komandozeile eingeben, wird die neue Datenbank erstellt. </p> <p>Wenn wir wieder in die vorige Darstellung von pgAdmin wechseln (Default Workspace) sollen wir nun unter PostgreSQL 18 &gt; Databases unsere neue Datenbank sehen. </p> Refresh <p>Wenn die neu erzeugte Datenbank nicht angezeigt wird, kann es daran liegen, dass die Darstellung noch nicht aktualisiert wurde. Durch Rechtsklick auf PostgreSQL 18 kann man Refresh ausw\u00e4hlen (oder Taste F5)</p> <p>\ud83c\udf89 Gratulation: Du hast nun deine erste Datenbank erstellt. </p>"},{"location":"database/einfuehrung/#zusammenfassung","title":"Zusammenfassung \ud83d\udccc","text":"<ul> <li>Datenbanken l\u00f6sen die Probleme einfacher Dateispeicherung: strukturierte Datenhaltung, Zugriffskontrolle, Konsistenz, gleichzeitige Zugriffe</li> <li>Ein DBMS (Datenbankmanagementsystem) verwaltet und koordiniert alle Zugriffe auf die Daten</li> <li>PostgreSQL ist ein m\u00e4chtiges, kostenloses und weit verbreitetes relationales DBMS</li> <li>pgAdmin 4 ist das offizielle PostgreSQL-Verwaltungstool mit grafischer Oberfl\u00e4che und Query-Editor</li> <li>SQL ist die Sprache, mit der wir Datenbanken abfragen und manipulieren</li> <li>Du hast PostgreSQL und pgAdmin installiert, eine Verbindung hergestellt und deine erste Datenbank erstellt</li> </ul> <p>Im n\u00e4chsten Kapitel lernen wir das relationale Modell kennen - wie Daten in Tabellen organisiert werden und welche Datentypen PostgreSQL bietet. Wir werden unsere erste Tabelle erstellen und Daten einf\u00fcgen!</p>"},{"location":"database/fortgeschritten/","title":"Fortgeschrittene Techniken","text":""},{"location":"database/fortgeschritten/#fortgeschrittene-abfragen","title":"Fortgeschrittene Abfragen","text":"<p>In den vorangegangenen Kapiteln haben wir die Grundlagen von SQL kennengelernt: Vom Erstellen von Tabellen, \u00fcber das Abfragen und Manipulieren von Daten, bis hin zur Modellierung von Beziehungen und dem Verkn\u00fcpfen mehrerer Tabellen mit JOINs. Die Grundlagen sind gelegt!</p> <p>Jetzt wird es Zeit f\u00fcr fortgeschrittene SQL-Techniken, die unsere Abfragen noch m\u00e4chtiger machen. Diese Techniken werden uns helfen, komplexe Anfragen elegant zu l\u00f6sen und unsere Daten auf neue Art und Weise zu analysieren.</p> <p>In diesem Kapitel lernen wir:</p> <ul> <li>Unterabfragen (Subqueries) \u2013 Abfragen in Abfragen</li> <li>String-Funktionen \u2013 Texte manipulieren</li> <li>Datumsfunktionen \u2013 Mit Datum und Zeit arbeiten</li> <li>CASE-WHEN \u2013 Bedingte Logik in SQL</li> <li>COALESCE \u2013 <code>NULL</code>-Werte elegant behandeln</li> </ul>"},{"location":"database/fortgeschritten/#unterabfragen","title":"Unterabfragen","text":"<p>Eine Unterabfrage (Subquery) ist eine <code>SELECT</code>-Abfrage innerhalb einer anderen Abfrage. Diese Technik erlaubt es uns, komplexe Fragestellungen in einem einzigen SQL-Statement zu l\u00f6sen, ohne tempor\u00e4re Ergebnisse manuell weiterverarbeiten zu m\u00fcssen. Unterabfragen sind besonders n\u00fctzlich, wenn wir das Ergebnis einer Berechnung direkt in einer anderen Abfrage verwenden m\u00f6chten.</p> Datenbank-Setup <p>F\u00fcr die Beispiele in diesem Kapitel verwenden wir eine Personal-Datenbank (<code>personal_db</code>), die ein typisches HR-System eines Unternehmens abbildet. Diese Datenbank hilft uns, fortgeschrittene SQL-Techniken praxisnah zu \u00fcben.</p> <pre><code>-- Datenbank erstellen\nCREATE DATABASE personal_db;\n\n-- Zur Datenbank wechseln\n\\c personal_db\n\n-- Tabelle: Abteilungen\nCREATE TABLE abteilungen (\n    abteilung_id SERIAL PRIMARY KEY,\n    abteilungsname VARCHAR(100) NOT NULL,\n    standort VARCHAR(100),\n    budget NUMERIC(12, 2)\n);\n\n-- Tabelle: Mitarbeiter\nCREATE TABLE mitarbeiter (\n    mitarbeiter_id SERIAL PRIMARY KEY,\n    vorname VARCHAR(50) NOT NULL,\n    nachname VARCHAR(50) NOT NULL,\n    email VARCHAR(100),\n    eintrittsdatum DATE NOT NULL,\n    gehalt NUMERIC(10, 2) NOT NULL,\n    bonus NUMERIC(10, 2),\n    abteilung_id INTEGER,\n    geburtstag DATE,\n    FOREIGN KEY (abteilung_id) REFERENCES abteilungen(abteilung_id)\n);\n\n-- Testdaten: Abteilungen\nINSERT INTO abteilungen (abteilungsname, standort, budget)\nVALUES\n    ('Produktion', 'Halle A', 500000.00),\n    ('Entwicklung', 'Gebaeude Nord', 800000.00),\n    ('Vertrieb', 'Gebaeude Sued', 600000.00),\n    ('Verwaltung', 'Hauptgebaeude', 400000.00),\n    ('Qualitaetssicherung', 'Halle B', 350000.00);\n\n-- Testdaten: Mitarbeiter\nINSERT INTO mitarbeiter (vorname, nachname, email, eintrittsdatum, gehalt, bonus, abteilung_id, geburtstag)\nVALUES\n    ('Thomas', 'Mueller', 'thomas.mueller@firma.de', '2018-03-15', 65000.00, 5000.00, 1, '1985-06-20'),\n    ('Sandra', 'Schmidt', 'sandra.schmidt@firma.de', '2019-07-01', 72000.00, 6000.00, 2, '1987-11-12'),\n    ('Klaus', 'Weber', 'klaus.weber@firma.de', '2015-01-10', 58000.00, NULL, 1, '1980-04-08'),\n    ('Anna', 'Fischer', 'anna.fischer@firma.de', '2020-09-01', 68000.00, 4500.00, 2, '1990-09-25'),\n    ('Michael', 'Becker', 'michael.becker@firma.de', '2021-02-15', 55000.00, 3000.00, 3, '1992-02-14'),\n    ('Julia', 'Wagner', 'julia.wagner@firma.de', '2017-11-20', 62000.00, NULL, 4, '1988-07-30'),\n    ('Peter', 'Hoffmann', 'peter.hoffmann@firma.de', '2022-05-01', 51000.00, 2000.00, 3, '1995-03-18'),\n    ('Lisa', 'Schulz', 'lisa.schulz@firma.de', '2016-08-12', 70000.00, 7000.00, 5, '1984-12-05'),\n    ('Martin', 'Koch', 'martin.koch@firma.de', '2023-01-15', 48000.00, NULL, 1, '1998-05-22'),\n    ('Sarah', 'Zimmermann', 'sarah.zimmermann@firma.de', '2019-04-20', 66000.00, 5500.00, 2, '1989-10-11');\n</code></pre> <p>Diese Tabellen enthalten typische HR-Daten: Mitarbeiterinformationen, Geh\u00e4lter, Bonuszahlungen und Abteilungszuordnungen.</p> <p>Um uns Unterabfragen besser vorstellen zu k\u00f6nnen, betrachten wir folgendes Beispiel. Stellen wir uns vor, wir haben folgende Frage:</p> <p>Welche Mitarbeiter verdienen mehr als das durchschnittliche Gehalt?</p> <p>Die Frage an sich ist relativ einfach zu beantworten. Wir k\u00f6nnen den Durchschnitt der Geh\u00e4lter berechnen und dann die Mitarbeiter filtern, die mehr verdienen. In einem zweistufigen Vorgehen k\u00f6nnte dies so aussehen:</p> Zweistufiges Vorgehen <pre><code>-- 1. Durchschnitt berechnen\nSELECT AVG(gehalt) FROM mitarbeiter;  -- Ergebnis: 61500.00\n\n-- 2. Dann das Ergebnis manuell verwenden\nSELECT vorname, nachname, gehalt\nFROM mitarbeiter\nWHERE gehalt &gt; 61500.00;\n</code></pre> Output<pre><code> vorname |  nachname  |  gehalt\n---------+------------+----------\n Thomas  | Mueller    | 65000.00\n Sandra  | Schmidt    | 72000.00\n Anna    | Fischer    | 68000.00\n Julia   | Wagner     | 62000.00\n Lisa    | Schulz     | 70000.00\n Sarah   | Zimmermann | 66000.00\n(6 rows)\n</code></pre> <p>So w\u00fcrden wir in der ersten Abfrage das Durchschnittsgehalt berechnen und in einer zweiten Abfrage schlussendlich das eigentliche Ergebnis erhalten - die Mitarbeiter, die \u00fcberdurchschnittlich verdienen.</p> <p>Da Programmierer von Haus aus faul sind, wollen wir diese Aufgabe nat\u00fcrlich in einem Schritt l\u00f6sen. Dazu verwenden wir eine Unterabfrage.</p> Unterabfrage <pre><code>SELECT vorname, nachname, gehalt\nFROM mitarbeiter\nWHERE gehalt &gt; (SELECT AVG(gehalt) FROM mitarbeiter)\nORDER BY gehalt DESC;\n</code></pre> Output<pre><code> vorname |  nachname  |  gehalt\n---------+------------+----------\n Sandra  | Schmidt    | 72000.00\n Lisa    | Schulz     | 70000.00\n Anna    | Fischer    | 68000.00\n Sarah   | Zimmermann | 66000.00\n Thomas  | Mueller    | 65000.00\n Julia   | Wagner     | 62000.00\n(6 rows)\n</code></pre> <p>Die innere Abfrage <code>(SELECT AVG(gehalt) FROM mitarbeiter)</code> wird zuerst ausgef\u00fchrt und liefert einen Wert (61500.00), der dann in der \u00e4u\u00dferen Abfrage verwendet wird. Das ist der gro\u00dfe Vorteil von Unterabfragen: Wir m\u00fcssen nicht erst manuell den Durchschnitt berechnen und dann in eine zweite Abfrage einsetzen - SQL erledigt dies automatisch f\u00fcr uns in einem einzigen Schritt.</p>"},{"location":"database/fortgeschritten/#in-und-not-in","title":"<code>IN</code> und <code>NOT IN</code>","text":"Quelle: imgflip <p>Eine besondere Art von Unterabfrage sind die <code>IN</code>- und <code>NOT IN</code>-Operatoren. Diese Operatoren erlauben es uns, zu pr\u00fcfen, ob ein Wert in einer Menge von Werten (aus einer Unterabfrage) enthalten ist. Dies ist besonders n\u00fctzlich, wenn die Unterabfrage mehrere Ergebniszeilen liefert und wir pr\u00fcfen wollen, ob unser Wert in dieser Liste vorkommt. Statt eines einzelnen Wertes wie beim einfachen Vergleich, gibt die Unterabfrage hier unter Umst\u00e4nden eine ganze Liste von Werten zur\u00fcck.</p> Mitarbeiter in technischen Abteilungen <p>Schauen wir uns das Ganze wieder anhand eines Beispiels an. Wir m\u00f6chten gerne wissen, welche Mitarbeiter in den technischen Abteilungen (Produktion, Entwicklung, Qualit\u00e4tssicherung) arbeiten.</p> <pre><code>-- Mitarbeiter in technischen Abteilungen\nSELECT vorname, nachname\nFROM mitarbeiter\nWHERE abteilung_id IN (\n    SELECT abteilung_id\n    FROM abteilungen\n    WHERE abteilungsname IN ('Produktion', 'Entwicklung', 'Qualitaetssicherung')\n);\n</code></pre> Output<pre><code> vorname |  nachname\n---------+------------\n Thomas  | Mueller\n Sandra  | Schmidt\n Klaus   | Weber\n Anna    | Fischer\n Lisa    | Schulz\n Martin  | Koch\n Sarah   | Zimmermann\n(7 rows)\n</code></pre> <p>Der Ablauf dieser Abfrage kann man wie folgt beschreiben:</p> <ol> <li>Innere Abfrage:<ul> <li>filtert die Abteilungen nach Namen (Produktion, Entwicklung, Qualit\u00e4tssicherung)</li> <li>liefert eine Liste von <code>abteilung_id</code> zur\u00fcck (z.B. 1, 2, 5)</li> </ul> </li> <li>\u00c4u\u00dfere Abfrage:<ul> <li>filtert die Mitarbeiter, deren <code>abteilung_id</code> in der Liste der inneren Abfrage ist</li> <li>liefert Vor- und Nachnamen der Mitarbeiter zur\u00fcck</li> </ul> </li> </ol> <p>Neben dem <code>IN</code>-Operator gibt es auch den <code>NOT IN</code>-Operator. Dieser Operator \u00fcberpr\u00fcft, ob ein Wert NICHT in einer Menge von Werten (aus einer Unterabfrage) enthalten ist. Das Vorgehen und deren Verwendung ist analog.</p> Mitarbeiter NICHT in technischen Abteilungen <pre><code>-- Mitarbeiter NICHT in technischen Abteilungen\nSELECT vorname, nachname\nFROM mitarbeiter\nWHERE abteilung_id NOT IN (\n    SELECT abteilung_id\n    FROM abteilungen\n    WHERE abteilungsname IN ('Produktion', 'Entwicklung', 'Qualitaetssicherung')\n);\n</code></pre> Output<pre><code> vorname | nachname\n---------+----------\n Michael | Becker\n Julia   | Wagner\n Peter   | Hoffmann\n(3 rows)\n</code></pre>"},{"location":"database/fortgeschritten/#exists-und-not-exists","title":"EXISTS und NOT EXISTS","text":"<p>EXISTS pr\u00fcft, ob eine Unterabfrage mindestens ein Ergebnis liefert. Im Gegensatz zu <code>IN</code>, das die gesamte Ergebnisliste der Unterabfrage durchgeht, stoppt <code>EXISTS</code> bereits, sobald das erste passende Ergebnis gefunden wurde. Das macht <code>EXISTS</code> oft performanter, besonders bei gro\u00dfen Datenmengen. </p> <code>EXISTS</code> vs <code>NOT IN</code> <p>Ein weiterer Vorteil: <code>EXISTS</code> hat keine Probleme mit <code>NULL</code>-Werten, die bei <code>NOT IN</code> zu unerwartetem Verhalten f\u00fchren k\u00f6nnen.</p> <p>Betrachten wir die Operatoren wieder anhand von Beispielen: </p> <ul> <li> <p>EXISTS</p> Mindestens einen Mitarbeiter <pre><code>-- Welche Abteilungen haben mindestens einen Mitarbeiter?\nSELECT abteilungsname, standort\nFROM abteilungen a\nWHERE EXISTS (\n    SELECT 1\n    FROM mitarbeiter m\n    WHERE m.abteilung_id = a.abteilung_id\n);\n</code></pre> Output<pre><code>   abteilungsname    |   standort\n---------------------+---------------\n Produktion          | Halle A\n Entwicklung         | Gebaeude Nord\n Vertrieb            | Gebaeude Sued\n Verwaltung          | Hauptgebaeude\n Qualitaetssicherung | Halle B\n(5 rows)\n</code></pre> <p>Erkl\u00e4rung: F\u00fcr jede Abteilung pr\u00fcft die Unterabfrage, ob es zugeordnete Mitarbeiter gibt. <code>EXISTS</code> ist wahr, sobald mindestens eine Zeile gefunden wird.</p> </li> <li> <p>NOT EXISTS</p> Abteilungen ohne Mitarbeiter <pre><code>-- Abteilungen OHNE Mitarbeiter finden\n-- (Beispiel: Wenn wir eine leere Abteilung einf\u00fcgen)\nINSERT INTO abteilungen (abteilungsname, standort, budget)\nVALUES ('Forschung', 'Gebaeude West', 1000000.00);\n\n-- Jetzt suchen wir leere Abteilungen\nSELECT abteilungsname, standort\nFROM abteilungen a\nWHERE NOT EXISTS (\n    SELECT 1\n    FROM mitarbeiter m\n    WHERE m.abteilung_id = a.abteilung_id\n);\n</code></pre> Output<pre><code> abteilungsname |   standort\n----------------+---------------\n Forschung      | Gebaeude West\n(1 row)\n</code></pre> <p>Erkl\u00e4rung: F\u00fcr jede Abteilung pr\u00fcft die Unterabfrage, ob es keine zugeordneten Mitarbeiter gibt. <code>NOT EXISTS</code> ist wahr, sobald keine Zeile gefunden wird.</p> </li> </ul>"},{"location":"database/fortgeschritten/#unterabfragen-in-from","title":"Unterabfragen in <code>FROM</code>","text":"<p>Man kann eine Unterabfrage auch in der <code>FROM</code>-Klausel verwenden \u2013 als w\u00e4re sie eine Tabelle! Diese sogenannten \"Derived Tables\" oder \"Inline Views\" sind besonders n\u00fctzlich, wenn wir mit aggregierten Daten weiterarbeiten m\u00f6chten. Da wir in der <code>WHERE</code>-Klausel keine Aggregatfunktionen direkt verwenden k\u00f6nnen, erstellen wir eine Unterabfrage, die die Aggregation durchf\u00fchrt, und k\u00f6nnen dann auf deren Ergebnis filtern.</p> Unterabfragen in <code>FROM</code> <pre><code>-- Durchschnittliches Gehalt pro Abteilung, aber nur Abteilungen mit Durchschnitt &gt; 60000\nSELECT abteilung, avg_gehalt\nFROM (\n    SELECT\n        a.abteilungsname AS abteilung,\n        AVG(m.gehalt) AS avg_gehalt\n    FROM mitarbeiter m\n    INNER JOIN abteilungen a ON m.abteilung_id = a.abteilung_id\n    GROUP BY a.abteilungsname\n) AS abteilungs_gehaelter\nWHERE avg_gehalt &gt; 60000\nORDER BY avg_gehalt DESC;\n</code></pre> Output<pre><code>      abteilung      |     avg_gehalt\n---------------------+--------------------\n Qualitaetssicherung | 70000.000000000000\n Entwicklung         | 68666.666666666667\n Verwaltung          | 62000.00000000000\n(3 rows)\n</code></pre> Wichtig <p>Die Unterabfrage muss einen Alias haben (hier: <code>AS abteilungs_gehaelter</code>)!</p>"},{"location":"database/fortgeschritten/#string-funktionen","title":"String-Funktionen","text":"<p>SQL bietet viele Funktionen zur Textverarbeitung. Diese sind besonders n\u00fctzlich, um Daten zu bereinigen, zu formatieren oder f\u00fcr Reports aufzubereiten. Ob wir Texte zusammenf\u00fcgen, Gro\u00df-/Kleinschreibung \u00e4ndern oder Teile eines Strings extrahieren m\u00f6chten - f\u00fcr fast jede Anforderung gibt es eine passende Funktion.</p> <p>Die wichtigsten String-Funktionen sind nachfolgend aufgelistet:</p> Funktion Beschreibung Beispiel <code>CONCAT(s1, s2, ...)</code> Strings zusammenf\u00fcgen <code>CONCAT('Max', ' ', 'M\u00fcller')</code> \u2192 'Max M\u00fcller' <code>UPPER(s)</code> In Gro\u00dfbuchstaben <code>UPPER('Anna')</code> \u2192 'ANNA' <code>LOWER(s)</code> In Kleinbuchstaben <code>LOWER('LISA')</code> \u2192 'lisa' <code>SUBSTRING(s, start, len)</code> Teil eines Strings <code>SUBSTRING('Hallo', 1, 3)</code> \u2192 'Hal' <code>LENGTH(s)</code> L\u00e4nge eines Strings <code>LENGTH('Hallo')</code> \u2192 5 <code>TRIM(s)</code> Leerzeichen entfernen <code>TRIM('  Hi  ')</code> \u2192 'Hi' <code>REPLACE(s, von, zu)</code> Text ersetzen <code>REPLACE('Hallo', 'a', 'e')</code> \u2192 'Hello' <p>Nun schauen wir uns an, wie wir diese String-Funktionen in der Praxis einsetzen k\u00f6nnen. Die folgenden Beispiele zeigen typische Anwendungsf\u00e4lle aus dem Alltag:</p> Vollst\u00e4ndiger Name <pre><code>-- Vollst\u00e4ndiger Name aus Vor- und Nachname\nSELECT\n    CONCAT(vorname, ' ', nachname) AS vollstaendiger_name,\n    email\nFROM mitarbeiter;\n</code></pre> Output<pre><code> vollstaendiger_name |           email\n---------------------+---------------------------\n Thomas Mueller      | thomas.mueller@firma.de\n Sandra Schmidt      | sandra.schmidt@firma.de\n Klaus Weber         | klaus.weber@firma.de\n Anna Fischer        | anna.fischer@firma.de\n Michael Becker      | michael.becker@firma.de\n Julia Wagner        | julia.wagner@firma.de\n Peter Hoffmann      | peter.hoffmann@firma.de\n Lisa Schulz         | lisa.schulz@firma.de\n Martin Koch         | martin.koch@firma.de\n Sarah Zimmermann    | sarah.zimmermann@firma.de\n(10 rows)\n</code></pre> <p>Erkl\u00e4rung: Wir f\u00fcgen Vor- und Nachname mit einem Leerzeichen zusammen zu einem vollst\u00e4ndigen Namen.</p> Weitere Beispiele Kombination mehrerer Funktionen <pre><code>-- Mitarbeiter-Codes generieren (Format: INITIALEN-JAHR-ID)\nSELECT\n    vorname,\n    nachname,\n    CONCAT(\n        UPPER(SUBSTRING(vorname, 1, 1)),\n        UPPER(SUBSTRING(nachname, 1, 1)),\n        '-',\n        EXTRACT(YEAR FROM eintrittsdatum),\n        '-',\n        LPAD(mitarbeiter_id::TEXT, 3, '0')\n    ) AS mitarbeitercode\nFROM mitarbeiter\nORDER BY mitarbeiter_id;\n</code></pre> Output<pre><code> vorname |  nachname  | mitarbeitercode\n---------+------------+-----------------\n Thomas  | Mueller    | TM-2018-001\n Sandra  | Schmidt    | SS-2019-002\n Klaus   | Weber      | KW-2015-003\n Anna    | Fischer    | AF-2020-004\n Michael | Becker     | MB-2021-005\n Julia   | Wagner     | JW-2017-006\n Peter   | Hoffmann   | PH-2022-007\n Lisa    | Schulz     | LS-2016-008\n Martin  | Koch       | MK-2023-009\n Sarah   | Zimmermann | SZ-2019-010\n(10 rows)\n</code></pre> <p>Erkl\u00e4rung: Wir generieren einen Mitarbeitercode. Die Initialen (erster Buchstabe von Vor- und Nachname) werden in Gro\u00dfbuchstaben umgewandelt, das Eintrittsjahr und die ID (mit Nullen aufgef\u00fcllt auf 3 Stellen) werden angeh\u00e4ngt.</p> <p>Mit diesen String-Funktionen k\u00f6nnen wir also sehr einfach und effizient Texte verarbeiten und formatieren und m\u00fcssen dies nicht in der Anwendungsschicht tun. Und wie sieht es bei Daten im Datumsformat aus?</p>"},{"location":"database/fortgeschritten/#datumsfunktionen","title":"Datumsfunktionen","text":"<p>PostgreSQL bietet auch - neben den String-Funktionen - umfangreiche Funktionen f\u00fcr Datum und Zeit. Die Arbeit mit Datums- und Zeitwerten ist in vielen Anwendungen zentral - sei es f\u00fcr Protokolle, Zeitstempel, Berechnungen von Zeitr\u00e4umen oder f\u00fcr zeitbasierte Analysen. Mit den Datumsfunktionen k\u00f6nnen wir das aktuelle Datum abrufen, Teile eines Datums extrahieren oder Zeitdifferenzen berechnen. Die wichtigsten Datumsfunktionen sind nachfolgend aufgelistet:</p> Funktion Beschreibung Beispiel <code>CURRENT_DATE</code> Heutiges Datum <code>2024-03-15</code> <code>CURRENT_TIME</code> Aktuelle Uhrzeit <code>14:30:00</code> <code>NOW()</code> Datum und Zeit <code>2024-03-15 14:30:00</code> <code>EXTRACT(teil FROM datum)</code> Jahr, Monat, Tag extrahieren <code>EXTRACT(YEAR FROM datum)</code> <code>AGE(datum1, datum2)</code> Zeitunterschied <code>AGE('2024-01-01', '2020-01-01')</code> <p>Nun wollen wir uns praktische Anwendungsf\u00e4lle ansehen. Unsere Mitarbeitertabelle enth\u00e4lt bereits die Felder <code>eintrittsdatum</code> und <code>geburtstag</code>, mit denen wir arbeiten k\u00f6nnen. </p> EXTRACT &amp; AGE - Betriebszugeh\u00f6rigkeit <pre><code>-- Betriebszugeh\u00f6rigkeit in Jahren berechnen\nSELECT\n    vorname,\n    nachname,\n    eintrittsdatum,\n    EXTRACT(YEAR FROM AGE(CURRENT_DATE, eintrittsdatum)) AS jahre_im_unternehmen\nFROM mitarbeiter\nORDER BY jahre_im_unternehmen DESC;\n</code></pre> Output<pre><code> vorname |  nachname  | eintrittsdatum | jahre_im_unternehmen\n---------+------------+----------------+----------------------\n Klaus   | Weber      | 2015-01-10     |                   10\n Lisa    | Schulz     | 2016-08-12     |                    9\n Julia   | Wagner     | 2017-11-20     |                    8\n Thomas  | Mueller    | 2018-03-15     |                    7\n Sandra  | Schmidt    | 2019-07-01     |                    6\n Sarah   | Zimmermann | 2019-04-20     |                    6\n Anna    | Fischer    | 2020-09-01     |                    5\n Michael | Becker     | 2021-02-15     |                    4\n Peter   | Hoffmann   | 2022-05-01     |                    3\n Martin  | Koch       | 2023-01-15     |                    2\n(10 rows)\n</code></pre> <p>Erkl\u00e4rung: Wir berechnen die Betriebszugeh\u00f6rigkeit in Jahren, indem wir die Differenz zwischen dem aktuellen Datum und dem Eintrittsdatum berechnen. <code>AGE</code> gibt die Zeitdifferenz zur\u00fcck, aus der wir mit <code>EXTRACT(YEAR ...)</code> die Jahre extrahieren.</p> Weitere Beispiele Mitarbeiter, die diesen Monat Geburtstag haben <pre><code>-- Mitarbeiter, die diesen Monat Geburtstag haben\nSELECT\n    vorname,\n    nachname,\n    geburtstag,\n    EXTRACT(YEAR FROM AGE(CURRENT_DATE, geburtstag)) AS alter\nFROM mitarbeiter\nWHERE EXTRACT(MONTH FROM geburtstag) = EXTRACT(MONTH FROM CURRENT_DATE)\nORDER BY EXTRACT(DAY FROM geburtstag);\n</code></pre> Output<pre><code>vorname |  nachname  | geburtstag | alter\n---------+------------+------------+-------\nSandra  | Schmidt    | 1987-11-12 |    38\n(1 row)\n</code></pre> <p>Erkl\u00e4rung: Wir filtern Mitarbeiter, deren Geburtsmonat mit dem aktuellen Monat \u00fcbereinstimmt. Zus\u00e4tzlich berechnen wir das Alter und sortieren nach dem Geburtstag im Monat.</p>"},{"location":"database/fortgeschritten/#case-when-bedingte-logik","title":"<code>CASE WHEN</code> - Bedingte Logik","text":"<p>Mit <code>CASE WHEN</code> k\u00f6nnen wir bedingte Logik direkt in SQL einbauen \u2013 \u00e4hnlich wie <code>if-else</code> in Programmiersprachen. Dies ist besonders n\u00fctzlich, um Daten zu kategorisieren, Berechnungen basierend auf Bedingungen durchzuf\u00fchren oder benutzerdefinierte Ausgaben zu erzeugen. Statt die Logik in der Anwendungsschicht zu implementieren, k\u00f6nnen wir sie direkt in der Datenbankabfrage unterbringen, was oft effizienter und lesbarer ist.</p> <p>Der allgemeine Syntax ist wie folgt:</p> <pre><code>CASE\n    WHEN bedingung1 THEN ergebnis1\n    WHEN bedingung2 THEN ergebnis2\n    ELSE standard_ergebnis\nEND\n</code></pre> <p>Bei der Verwendung von <code>CASE</code> k\u00f6nnen wir beliebig viele Bedingungen angeben und ein Standardergebnis festlegen, das verwendet wird, wenn keine der Bedingungen erf\u00fcllt ist. Betrachten wir das wieder anhand eines praktischen Beispiels.</p> Gehaltsstufen kategorisieren <pre><code>SELECT\n    vorname,\n    nachname,\n    gehalt,\n    CASE\n        WHEN gehalt &gt;= 70000 THEN 'Senior'\n        WHEN gehalt &gt;= 60000 THEN 'Mid-Level'\n        WHEN gehalt &gt;= 50000 THEN 'Junior'\n        ELSE 'Einsteiger'\n    END AS gehaltsstufe\nFROM mitarbeiter\nORDER BY gehalt DESC;\n</code></pre> Output<pre><code> vorname |  nachname  |  gehalt  | gehaltsstufe\n---------+------------+----------+--------------\n Sandra  | Schmidt    | 72000.00 | Senior\n Lisa    | Schulz     | 70000.00 | Senior\n Anna    | Fischer    | 68000.00 | Mid-Level\n Sarah   | Zimmermann | 66000.00 | Mid-Level\n Thomas  | Mueller    | 65000.00 | Mid-Level\n Julia   | Wagner     | 62000.00 | Mid-Level\n Klaus   | Weber      | 58000.00 | Junior\n Michael | Becker     | 55000.00 | Junior\n Peter   | Hoffmann   | 51000.00 | Junior\n Martin  | Koch       | 48000.00 | Einsteiger\n(10 rows)\n</code></pre> <p>Erkl\u00e4rung: Wir kategorisieren Mitarbeiter nach ihrem Gehalt in Gehaltsstufen: Senior (\u226570.000\u20ac), Mid-Level (\u226560.000\u20ac), Junior (\u226550.000\u20ac) oder Einsteiger (&lt;50.000\u20ac).</p> Quelle: Medium"},{"location":"database/fortgeschritten/#case-in-aggregationen","title":"CASE in Aggregationen","text":"<p>CASE WHEN kann auch innerhalb von Aggregatfunktionen verwendet werden, um selektive Z\u00e4hlungen durchzuf\u00fchren. Dies ist besonders n\u00fctzlich f\u00fcr Auswertungen und Berichte:</p> Mitarbeiter pro Gehaltsstufe <pre><code>-- Wie viele Mitarbeiter gibt es pro Gehaltsstufe?\nSELECT\n    COUNT(CASE WHEN gehalt &gt;= 70000 THEN 1 END) AS senior,\n    COUNT(CASE WHEN gehalt &gt;= 60000 AND gehalt &lt; 70000 THEN 1 END) AS mid_level,\n    COUNT(CASE WHEN gehalt &gt;= 50000 AND gehalt &lt; 60000 THEN 1 END) AS junior,\n    COUNT(CASE WHEN gehalt &lt; 50000 THEN 1 END) AS einsteiger,\n    COUNT(*) AS gesamt\nFROM mitarbeiter;\n</code></pre> Output<pre><code> senior | mid_level | junior | einsteiger | gesamt\n--------+-----------+--------+------------+--------\n      2 |         4 |      3 |          1 |     10\n(1 row)\n</code></pre> <p>Erkl\u00e4rung: Wir z\u00e4hlen die Mitarbeiter pro Gehaltsstufe. Dies ist besonders n\u00fctzlich f\u00fcr HR-Berichte und Gehaltsanalysen.</p>"},{"location":"database/fortgeschritten/#coalesce-null-werte-behandeln","title":"COALESCE - NULL-Werte behandeln","text":"<p>COALESCE gibt den ersten nicht-NULL-Wert aus einer Liste zur\u00fcck. Diese Funktion ist extrem n\u00fctzlich im Umgang mit NULL-Werten, die in Datenbanken h\u00e4ufig vorkommen. Statt komplizierte CASE-WHEN-Konstrukte zu schreiben oder NULL-Werte in der Anwendung zu behandeln, bietet COALESCE eine elegante und lesbare L\u00f6sung, um Standardwerte f\u00fcr fehlende Daten bereitzustellen. Der Allgemeine Syntax ist wie folgt:</p> <pre><code>COALESCE(wert1, wert2, wert3, ..., standard)\n</code></pre> <p>Wir sehen, dass wir mehrere Werte (im Normalfall Funktionen oder andere Spaltenwerte) angeben k\u00f6nnen und der erste nicht-NULL-Wert wird zur\u00fcckgegeben. Wenn alle Werte NULL sind, wird der Standardwert zur\u00fcckgegeben. Betrachten wir wieder ein praktisches Beispiel. </p> Bonuszahlungen mit Standardwert <pre><code>-- Gesamtverg\u00fctung inklusive Bonus (NULL-Bonuswerte als 0 behandeln)\nSELECT\n    vorname,\n    nachname,\n    gehalt,\n    bonus,\n    COALESCE(bonus, 0) AS bonus_bereinigt,\n    gehalt + COALESCE(bonus, 0) AS gesamtverguetung\nFROM mitarbeiter\nORDER BY gesamtverguetung DESC;\n</code></pre> Output<pre><code> vorname |  nachname  |  gehalt  |  bonus  | bonus_bereinigt | gesamtverguetung\n---------+------------+----------+---------+-----------------+------------------\n Sandra  | Schmidt    | 72000.00 | 6000.00 |         6000.00 |         78000.00\n Lisa    | Schulz     | 70000.00 | 7000.00 |         7000.00 |         77000.00\n Anna    | Fischer    | 68000.00 | 4500.00 |         4500.00 |         72500.00\n Sarah   | Zimmermann | 66000.00 | 5500.00 |         5500.00 |         71500.00\n Thomas  | Mueller    | 65000.00 | 5000.00 |         5000.00 |         70000.00\n Julia   | Wagner     | 62000.00 |         |               0 |         62000.00\n Michael | Becker     | 55000.00 | 3000.00 |         3000.00 |         58000.00\n Klaus   | Weber      | 58000.00 |         |               0 |         58000.00\n Peter   | Hoffmann   | 51000.00 | 2000.00 |         2000.00 |         53000.00\n Martin  | Koch       | 48000.00 |         |               0 |         48000.00\n(10 rows)\n</code></pre> <p>Erkl\u00e4rung: <code>COALESCE(bonus, 0)</code> ersetzt NULL-Werte in der Bonus-Spalte durch 0. Dadurch k\u00f6nnen wir problemlos die Gesamtverg\u00fctung berechnen, ohne dass NULL-Werte die Berechnung st\u00f6ren. </p>"},{"location":"database/fortgeschritten/#mathematische-funktionen","title":"Mathematische Funktionen","text":"<p>Neben String- und Datumsfunktionen bietet SQL auch eine Vielzahl mathematischer Funktionen f\u00fcr numerische Werte. Diese sind besonders n\u00fctzlich f\u00fcr Berechnungen, Rundungen und statistische Auswertungen direkt in der Datenbank.</p> Funktion Beschreibung Beispiel <code>ROUND(x, n)</code> Runden auf n Nachkommastellen <code>ROUND(3.14159, 2)</code> \u2192 3.14 <code>CEIL(x)</code> Aufrunden <code>CEIL(3.2)</code> \u2192 4 <code>FLOOR(x)</code> Abrunden <code>FLOOR(3.8)</code> \u2192 3 <code>ABS(x)</code> Absolutwert <code>ABS(-5)</code> \u2192 5 <code>POWER(x, y)</code> x hoch y <code>POWER(2, 3)</code> \u2192 8 <code>SQRT(x)</code> Quadratwurzel <code>SQRT(16)</code> \u2192 4 <p>Ein h\u00e4ufiger Anwendungsfall f\u00fcr mathematische Funktionen ist das Runden von Berechnungsergebnissen f\u00fcr eine \u00fcbersichtliche Darstellung:</p> Gehaltsberechnungen runden <pre><code>-- Durchschnittsgehalt pro Abteilung gerundet\nSELECT\n    a.abteilungsname,\n    COUNT(m.mitarbeiter_id) AS anzahl_mitarbeiter,\n    ROUND(AVG(m.gehalt), 2) AS durchschnittsgehalt,\n    ROUND(MIN(m.gehalt), 2) AS min_gehalt,\n    ROUND(MAX(m.gehalt), 2) AS max_gehalt\nFROM abteilungen a\nLEFT JOIN mitarbeiter m ON a.abteilung_id = m.abteilung_id\nGROUP BY a.abteilungsname\nORDER BY durchschnittsgehalt DESC;\n</code></pre> Output<pre><code>   abteilungsname    | anzahl_mitarbeiter | durchschnittsgehalt | min_gehalt | max_gehalt\n---------------------+--------------------+---------------------+------------+------------\n Forschung           |                  0 |                     |            |\n Qualitaetssicherung |                  1 |            70000.00 |   70000.00 |   70000.00\n Entwicklung         |                  3 |            68666.67 |   66000.00 |   72000.00\n Verwaltung          |                  1 |            62000.00 |   62000.00 |   62000.00\n Produktion          |                  3 |            57000.00 |   48000.00 |   65000.00\n Vertrieb            |                  2 |            53000.00 |   51000.00 |   55000.00\n(6 rows)\n</code></pre> <p>Erkl\u00e4rung: Mit <code>ROUND()</code> k\u00f6nnen wir Berechnungsergebnisse auf 2 Nachkommastellen runden f\u00fcr eine \u00fcbersichtliche Darstellung in HR-Berichten. </p>"},{"location":"database/fortgeschritten/#ubung","title":"\u00dcbung \u270d\ufe0f","text":"<p>Nun wenden wir die fortgeschrittenen SQL-Techniken auf unser TecGuy GmbH Produktionsplanungssystem an! Die \u00dcbungen decken Unterabfragen, String-/Datumsfunktionen, CASE WHEN, COALESCE und komplexe Analysen ab.</p> <p>Im vorherigen Kapitel haben wir JOINs gelernt. Jetzt erweitern wir unser Wissen mit Subqueries, String-/Date-Funktionen und bedingter Logik.</p> \u00dcbungsvorbereitung - Datenbank zur\u00fccksetzen <p>Falls du das vorherige Kapitel nicht abgeschlossen hast oder neu starten m\u00f6chtest, f\u00fchre dieses Setup aus. Es l\u00f6scht alle bestehenden Daten und erstellt den korrekten Ausgangszustand f\u00fcr dieses Kapitel.</p> Setup <pre><code>-- Zu anderer Datenbank wechseln\n\\c postgres\n\n-- Zur Datenbank wechseln (oder neu erstellen)\nDROP DATABASE IF EXISTS produktionsplanung_db;\nCREATE DATABASE produktionsplanung_db;\n\\c produktionsplanung_db\n\n-- 1. Tabelle f\u00fcr Maschinen erstellen\nCREATE TABLE maschinen (\n    maschinen_id INTEGER PRIMARY KEY,\n    maschinenname VARCHAR(100),\n    maschinentyp VARCHAR(50),\n    produktionshalle VARCHAR(50),\n    anschaffungsjahr INTEGER,\n    maschinenstatus VARCHAR(20),\n    wartungsintervall_tage INTEGER\n);\n\n-- 2. Tabelle f\u00fcr Produktionsauftr\u00e4ge erstellen (MIT FK-Constraint)\nCREATE TABLE produktionsauftraege (\n    auftrag_id INTEGER PRIMARY KEY,\n    auftragsnummer VARCHAR(20),\n    kunde VARCHAR(100),\n    produkt VARCHAR(100),\n    menge INTEGER,\n    startdatum DATE,\n    lieferdatum DATE,\n    status VARCHAR(20),\n    maschinen_id INTEGER,\n    FOREIGN KEY (maschinen_id) REFERENCES maschinen(maschinen_id)\n        ON DELETE RESTRICT\n);\n\n-- 3. Tabelle f\u00fcr Wartungsprotokolle erstellen (MIT FK-Constraint)\nCREATE TABLE wartungsprotokolle (\n    wartungs_id SERIAL PRIMARY KEY,\n    wartungsdatum DATE NOT NULL,\n    beschreibung TEXT,\n    techniker VARCHAR(100),\n    kosten NUMERIC(10, 2),\n    maschinen_id INTEGER NOT NULL,\n    FOREIGN KEY (maschinen_id) REFERENCES maschinen(maschinen_id)\n        ON DELETE CASCADE\n);\n\n-- 4. Tabelle f\u00fcr Ersatzteile erstellen\nCREATE TABLE ersatzteile (\n    teil_id SERIAL PRIMARY KEY,\n    teilename VARCHAR(100) NOT NULL,\n    hersteller VARCHAR(100),\n    preis NUMERIC(10, 2)\n);\n\n-- 5. Junction Table f\u00fcr n:m Beziehung (Maschinen \u2194 Ersatzteile)\nCREATE TABLE maschinen_ersatzteile (\n    zuordnung_id SERIAL PRIMARY KEY,\n    maschinen_id INTEGER NOT NULL,\n    teil_id INTEGER NOT NULL,\n    benoetigte_anzahl INTEGER DEFAULT 1,\n    FOREIGN KEY (maschinen_id) REFERENCES maschinen(maschinen_id)\n        ON DELETE CASCADE,\n    FOREIGN KEY (teil_id) REFERENCES ersatzteile(teil_id)\n        ON DELETE CASCADE\n);\n\n-- Maschinen-Daten einf\u00fcgen\nINSERT INTO maschinen VALUES\n(1, 'CNC-Fraese Alpha', 'CNC-Fraese', 'Halle A', 2020, 'Aktiv', 90),\n(2, 'Drehbank Delta', 'Drehbank', 'Halle A', 2018, 'Aktiv', 120),\n(3, 'Presse Gamma', 'Presse', 'Halle B', 2019, 'Aktiv', 60),\n(4, 'Schweissroboter Beta', 'Schweissroboter', 'Halle C', 2021, 'Aktiv', 90);\n\n-- Produktionsauftr\u00e4ge-Daten einf\u00fcgen\nINSERT INTO produktionsauftraege VALUES\n(1, 'AUF-2024-001', 'BMW AG', 'Getriebegeh\u00e4use', 500, '2024-04-01', '2024-04-15', 'In Produktion', 1),\n(2, 'AUF-2024-002', 'Audi AG', 'Kurbelwelle', 200, '2024-04-10', '2024-04-20', 'In Produktion', 2),\n(3, 'AUF-2024-003', 'Mercedes-Benz', 'Pleuelstange', 350, '2024-04-05', '2024-04-18', 'In Produktion', 2),\n(4, 'AUF-2024-004', 'Porsche AG', 'Kolben', 150, '2024-04-12', '2024-04-25', 'In Vorbereitung', 4),\n(5, 'AUF-2024-005', 'BMW AG', 'Kurbelwelle', 300, '2024-04-15', '2024-04-22', 'In Produktion', 2),\n(6, 'AUF-2024-006', 'Volkswagen AG', 'Kolben', 400, '2024-04-20', '2024-04-28', 'In Vorbereitung', 1),\n(7, 'AUF-2024-009', 'Porsche AG', 'Kurbelwelle', 120, '2024-04-28', '2024-05-05', 'In Vorbereitung', 2),\n(8, 'AUF-2024-010', 'BMW AG', 'Kolben', 350, '2024-04-12', '2024-04-19', 'In Produktion', 4);\n\n-- Wartungsprotokolle-Daten einf\u00fcgen\nINSERT INTO wartungsprotokolle (wartungsdatum, beschreibung, techniker, kosten, maschinen_id)\nVALUES\n('2024-01-15', 'Routinewartung - Oelwechsel', 'M. Schneider', 250.00, 1),\n('2024-02-10', 'Reparatur Spindelmotor', 'L. Weber', 850.00, 1),\n('2024-01-20', 'Routinewartung - Kalibrierung', 'M. Schneider', 180.00, 2),\n('2024-03-05', 'Austausch Keilriemen', 'L. Weber', 120.00, 2);\n\n-- Ersatzteile-Daten einf\u00fcgen\nINSERT INTO ersatzteile (teilename, hersteller, preis)\nVALUES\n('Spindelmotor 5kW', 'MotorTech GmbH', 1850.00),\n('Kuehlmittelpumpe', 'PumpCo AG', 320.50),\n('Linearfuehrung 500mm', 'Precision Parts', 680.00),\n('Werkzeughalter ISO40', 'ToolSupply GmbH', 145.00),\n('Drehfutter 250mm', 'ChuckMaster', 890.00);\n\n-- Maschinen-Ersatzteile Zuordnungen einf\u00fcgen\nINSERT INTO maschinen_ersatzteile (maschinen_id, teil_id, benoetigte_anzahl)\nVALUES\n(1, 1, 1),  -- CNC-Fraese braucht 1x Spindelmotor\n(1, 2, 2),  -- CNC-Fraese braucht 2x Kuehlmittelpumpe\n(1, 3, 4),  -- CNC-Fraese braucht 4x Linearfuehrung\n(1, 4, 6),  -- CNC-Fraese braucht 6x Werkzeughalter\n(2, 2, 1),  -- Drehbank braucht 1x Kuehlmittelpumpe\n(2, 5, 1);  -- Drehbank braucht 1x Drehfutter\n</code></pre> <p>Hinweis: Alle Foreign Key Constraints sind aktiv. Die Tabellen sind nun vollst\u00e4ndig verkn\u00fcpft!</p> Aufgabe 1: Unterabfragen - \u00dcberdurchschnittliche Wartungskosten <p>Finde alle Wartungen, die teurer waren als die durchschnittlichen Wartungskosten.</p> <p>Anforderungen:</p> <ul> <li>Zeige: Maschinennamen (mit JOIN), Wartungsdatum, Beschreibung, Kosten</li> <li>Nur Wartungen \u00fcber dem Durchschnitt</li> <li>Sortiere nach Kosten absteigend</li> </ul> Aufgabe 2: IN - Maschinen mit bestimmten Ersatzteilen <p>Finde alle Maschinen, die entweder Spindelmotoren oder K\u00fchlmittelpumpen ben\u00f6tigen.</p> <p>Anforderungen:</p> <ul> <li>Verwende IN mit Unterabfrage</li> <li>Zeige: Maschinenname, Maschinentyp</li> <li>Keine Duplikate (DISTINCT)</li> </ul> Aufgabe 3: EXISTS - Maschinen mit Wartungsprotokollen <p>Finde alle Maschinen, die mindestens eine Wartung haben.</p> <p>Anforderungen:</p> <ul> <li>Verwende EXISTS</li> <li>Zeige: Maschinenname, Maschinentyp, Anzahl Wartungen</li> <li>Sortiere nach Anzahl Wartungen absteigend</li> </ul> Aufgabe 4: String-Funktionen - Maschinencodes generieren <p>Erstelle Maschinencodes im Format: <code>TYP-ID</code> (z.B. \"CNC-001\")</p> <p>Anforderungen:</p> <ul> <li>Erste 3 Buchstaben des Maschinentyps in Gro\u00dfbuchstaben</li> <li>Maschinen-ID mit f\u00fchrenden Nullen auf 3 Stellen</li> <li>Verwende: UPPER, SUBSTRING, LPAD</li> </ul> Aufgabe 5: Datumsfunktionen - Wartungsalter <p>Berechne, wie viele Tage seit der letzten Wartung jeder Maschine vergangen sind. Zeige nur Maschinen, die l\u00e4nger als 90 Tage keine Wartung hatten.</p> <p>Anforderungen:</p> <ul> <li>Berechne Tage seit letzter Wartung mit CURRENT_DATE</li> <li>Filtere: Nur Maschinen mit letzter Wartung &gt; 90 Tage</li> <li>Zeige auch Maschinen ohne Wartungen</li> <li>Sortiere nach Tagen absteigend</li> </ul> Aufgabe 6: CASE WHEN - Produktionsauftragskategorien <p>Kategorisiere Produktionsauftr\u00e4ge nach Menge: Klein (&lt;200), Mittel (200-400), Gro\u00df (&gt;400).</p> <p>Anforderungen:</p> <ul> <li>Verwende CASE WHEN</li> <li>Zeige: Auftragsnummer, Kunde, Produkt, Menge, Kategorie</li> <li>Z\u00e4hle Auftr\u00e4ge pro Kategorie (zweite Abfrage)</li> </ul> Aufgabe 7: COALESCE - Wartungsintervalle <p>Zeige alle Maschinen mit ihrem Wartungsintervall. Falls NULL, zeige \"Nicht definiert\".</p> <p>Anforderungen:</p> <ul> <li>Verwende COALESCE f\u00fcr wartungsintervall_tage</li> <li>Zeige: Maschinenname, Wartungsintervall (oder \"Nicht definiert\")</li> <li>Berechne n\u00e4chste Wartung basierend auf letzter Wartung + Intervall</li> </ul>"},{"location":"database/fortgeschritten/#zusammenfassung","title":"Zusammenfassung \ud83d\udccc","text":"<p>Mit den fortgeschrittenen SQL-Techniken aus diesem Kapitel haben wir unser Werkzeugkasten deutlich erweitert. Diese Techniken erlauben es uns, komplexe Abfragen elegant zu formulieren und Daten direkt in der Datenbank zu transformieren und zu analysieren, ohne auf Anwendungslogik zur\u00fcckgreifen zu m\u00fcssen.</p> <p>Die wichtigsten Erkenntnisse:</p> <ul> <li>Unterabfragen erlauben Abfragen innerhalb von Abfragen und machen komplexe Fragestellungen in einem Statement l\u00f6sbar</li> <li>IN / NOT IN pr\u00fcft Mitgliedschaft in einer Menge, aber Achtung bei NULL-Werten</li> <li>EXISTS / NOT EXISTS pr\u00fcft, ob eine Unterabfrage Ergebnisse liefert - oft schneller als IN und ohne NULL-Probleme</li> <li>String-Funktionen (CONCAT, UPPER, LOWER, SUBSTRING, LENGTH, TRIM, REPLACE) zur Textverarbeitung</li> <li>Datumsfunktionen (CURRENT_DATE, NOW, EXTRACT, AGE) f\u00fcr zeitbasierte Analysen</li> <li>CASE WHEN bringt if-else-Logik nach SQL und erm\u00f6glicht Kategorisierungen</li> <li>COALESCE behandelt NULL-Werte elegant ohne komplizierte Konstrukte</li> <li>Mathematische Funktionen (ROUND, CEIL, FLOOR, ABS, POWER, SQRT) f\u00fcr Berechnungen</li> </ul> <p>Im n\u00e4chsten Kapitel lernen wir \u00fcber Datenintegrit\u00e4t &amp; Constraints \u2013 wie wir sicherstellen, dass nur g\u00fcltige Daten in unsere Datenbank gelangen! Mit den hier gelernten Techniken k\u00f6nnen wir nun auch komplexe Abfragen formulieren, doch die Qualit\u00e4t unserer Daten ist ebenso wichtig wie unsere F\u00e4higkeit, sie abzufragen.</p>"},{"location":"database/integritaet/","title":"Datenintegrit\u00e4t","text":""},{"location":"database/integritaet/#datenintegritat-constraints","title":"Datenintegrit\u00e4t &amp; Constraints","text":"<p>Stell dir vor, jemand gibt in deine Datenbank ein: <code>pruefergebnis = 150</code> (bei einer Skala von 0-100) oder <code>temperatur = -500</code>. Dies w\u00e4ren offensichtlich unsinnige Daten! Wie k\u00f6nnen wir solche Datenfehler verhindern?</p> <p>Die Antwort: Constraints (Integrit\u00e4tsbedingungen)!</p> Quelle: Despair <p>Constraints sind Regeln, die sicherstellen, dass nur g\u00fcltige Daten in die Datenbank gelangen. Sie sind die erste Verteidigungslinie gegen fehlerhafte Daten.</p>"},{"location":"database/integritaet/#warum-ist-datenintegritat-wichtig","title":"Warum ist Datenintegrit\u00e4t wichtig","text":"<p>Garbage In, Garbage Out \u2013 Diesen Spruch h\u00f6rt man sehr h\u00e4ufig im Zusammenhang mit Daten. Und auch wenn er unscheinbar klingen mag, so steckt doch viel Wahrheit in ihm. Schlechte Daten f\u00fchren immer zu schlechten Ergebnissen. Und schlechte Ergebnisse f\u00fchren zu schlechten Entscheidungen. Beispiele f\u00fcr schlechte Daten sind</p> <ul> <li>\u274c Ein negatives Alter</li> <li>\u274c Ein leerer Name bei einem Pflichtfeld</li> <li>\u274c Eine ung\u00fcltige E-Mail-Adresse</li> <li>\u274c Ein Fremdschl\u00fcssel, der auf nichts verweist</li> </ul> <p>Constraints verhindern diese Probleme automatisch auf Datenbankebene \u2013 unabh\u00e4ngig davon, welche Anwendung auf die Datenbank zugreift.</p>"},{"location":"database/integritaet/#die-wichtigsten-constraints","title":"Die wichtigsten Constraints","text":"<p>Nachfolgende Tabelle gibt einen \u00dcberblick \u00fcber die wichtigsten und g\u00e4ngisten Constraints.</p> Constraint Bedeutung Beispiel <code>NOT NULL</code> Darf nicht leer sein Name, E-Mail <code>UNIQUE</code> Muss eindeutig sein Seriennummer, Teilnummer <code>PRIMARY KEY</code> NOT NULL + UNIQUE ID-Spalten <code>FOREIGN KEY</code> Verweist auf andere Tabelle techniker_id <code>CHECK</code> Eigene Bedingung alter &gt;= 0 <code>DEFAULT</code> Standardwert 'Aktiv', 'Unbekannt' <p>Wollen uns nun einige der Constraints genauer ansehen.</p> <p>Prinzipiell ist es so, dass Constraints beim Erstellen einer Tabelle definiert werden. Damit wird sichergestellt, dass von Anfang an alle Daten die gew\u00fcnschten Eigenschaften haben. Es gibt aber auch die M\u00f6glichkeit, Constraints nachtr\u00e4glich zu einer bestehenden Tabelle hinzuzuf\u00fcgen. Wir werden uns dies sp\u00e4ter noch genauer ansehen. Die zwei Constraints <code>NOT NULL</code> und <code>DEFAULT</code> haben wir bereits im Kapitel Daten Manipulieren kennengelernt. Daher werden wir uns in diesem Kapitel auf die anderen Constraints konzentrieren.</p> Datenbank-Setup <p>F\u00fcr die folgenden Beispiele erstellen wir eine Qualit\u00e4tskontroll-Datenbank. In dieser Datenbank werden Produkte und ihre Pr\u00fcfungen verwaltet.</p> <pre><code>-- Datenbank erstellen\nCREATE DATABASE qualitaetskontrolle_db;\n\n-- Zur Datenbank wechseln\n\\c qualitaetskontrolle_db\n\n-- Tabelle: Produkte\nCREATE TABLE produkte (\n    produkt_id SERIAL PRIMARY KEY,\n    produktname VARCHAR(100) NOT NULL,\n    produktcode VARCHAR(20) UNIQUE NOT NULL,\n    kategorie VARCHAR(50) NOT NULL,\n    mindestqualitaet INTEGER CHECK (mindestqualitaet &gt;= 0 AND mindestqualitaet &lt;= 100)\n);\n\n-- Tabelle: Pr\u00fcfungen\nCREATE TABLE pruefungen (\n    pruefung_id SERIAL PRIMARY KEY,\n    produkt_id INTEGER NOT NULL,\n    pruefdatum DATE NOT NULL,\n    pruefergebnis INTEGER CHECK (pruefergebnis &gt;= 0 AND pruefergebnis &lt;= 100),\n    status VARCHAR(20) DEFAULT 'ausstehend',\n    temperatur NUMERIC(4,1) CHECK (temperatur &gt;= -20 AND temperatur &lt;= 50),\n    luftfeuchtigkeit INTEGER CHECK (luftfeuchtigkeit &gt;= 0 AND luftfeuchtigkeit &lt;= 100),\n    pruefername VARCHAR(100),\n    FOREIGN KEY (produkt_id) REFERENCES produkte(produkt_id) ON DELETE CASCADE\n);\n\n-- Testdaten: Produkte\nINSERT INTO produkte (produktname, produktcode, kategorie, mindestqualitaet) VALUES\n('Smartphone X500', 'SP-X500', 'Elektronik', 95),\n('Laptop Pro 15', 'LP-PRO15', 'Elektronik', 90),\n('Tablet Ultra', 'TB-ULTRA', 'Elektronik', 92),\n('Gaming Monitor', 'GM-4K', 'Elektronik', 88),\n('Mechanische Tastatur', 'KB-MECH', 'Peripherie', 85);\n\n-- Testdaten: Pr\u00fcfungen\nINSERT INTO pruefungen (produkt_id, pruefdatum, pruefergebnis, status, temperatur, luftfeuchtigkeit, pruefername) VALUES\n(1, '2025-11-01', 98, 'bestanden', 22.5, 45, 'Anna Schmidt'),\n(1, '2025-11-15', 96, 'bestanden', 23.0, 48, 'Thomas Weber'),\n(2, '2025-11-02', 92, 'bestanden', 21.8, 50, 'Anna Schmidt'),\n(3, '2025-11-03', 85, 'nachpruefung', 22.0, 52, 'Thomas Weber'),\n(4, '2025-11-05', 91, 'bestanden', 22.3, 47, 'Anna Schmidt'),\n(5, '2025-11-10', NULL, 'ausstehend', NULL, NULL, 'Thomas Weber');\n</code></pre>"},{"location":"database/integritaet/#eindeutigkeit-erzwingen-unique","title":"Eindeutigkeit erzwingen (<code>UNIQUE</code>)","text":"<p>Die <code>UNIQUE</code> Bedingung stellt sicher, dass ein Wert in einer Spalte nur einmal vorkommt. Generell liest sich der Syntax:</p> <pre><code>CREATE TABLE tabellenname (\n    spalte DATENTYP UNIQUE\n);\n</code></pre> Eindeutigkeit mit <code>UNIQUE</code> <p>Zuerst erstellen wir eine neue Tabelle mit einer Spalte, die eindeutig sein muss.</p> <pre><code>CREATE TABLE produkte_test (\n    produkt_id SERIAL PRIMARY KEY,\n    produktname VARCHAR(100) NOT NULL,\n    produktcode VARCHAR(20) UNIQUE,      -- Jeder Produktcode nur einmal!\n    kategorie VARCHAR(50)\n);\n</code></pre> <p>Was passiert nun, wenn wir versuchen, ein Produkt mit demselben Produktcode zu erstellen, wie ein bereits existierendes Produkt?</p> <pre><code>-- Erste Einf\u00fcgung: OK\nINSERT INTO produkte_test (produktname, produktcode, kategorie)\nVALUES ('Smartphone Alpha', 'SP-2025-001', 'Elektronik');\n\n-- Zweite Einf\u00fcgung mit gleichem Produktcode: FEHLER!\nINSERT INTO produkte_test (produktname, produktcode, kategorie)\nVALUES ('Smartphone Beta', 'SP-2025-001', 'Elektronik');\n</code></pre> Output<pre><code>FEHLER:  doppelter Schl\u00fcsselwert verletzt Unique-Constraint \u00bbprodukte_test_produktcode_key\u00ab\nDETAIL:  Schl\u00fcssel \u00bb(produktcode)=(SP-2025-001)\u00ab existiert bereits.\n</code></pre> <p>Wir sehen also, dass die Einf\u00fcgung fehlschl\u00e4gt und wir eine Fehlermeldung erhalten. Dem User ist es also nicht m\u00f6glich, ein Produkt mit demselben Produktcode zu erstellen, wie ein bereits existierendes Produkt.</p> <p><code>UNIQUE</code> kann auch mit mehreren Spalten definiert werden. Dies ist beispielsweise dann sinnvoll, wenn wir eine Kombination aus zwei Spalten als eindeutig erkennen m\u00f6chten.</p> <code>UNIQUE</code> mit mehreren Spalten <pre><code>CREATE TABLE pruefungen_test (\n    pruefung_id SERIAL PRIMARY KEY,\n    produkt_id INTEGER,\n    pruefdatum DATE,\n    pruefername VARCHAR(100),\n    UNIQUE (produkt_id, pruefdatum, pruefername)  -- Diese Kombination muss eindeutig sein\n);\n</code></pre> <p>Das erlaubt mehrere Pr\u00fcfungen f\u00fcr ein Produkt, aber nicht zweimal am selben Tag vom selben Pr\u00fcfer.</p>"},{"location":"database/integritaet/#eigene-regeln-definieren-check","title":"Eigene Regeln definieren (<code>CHECK</code>)","text":"<p>Die <code>CHECK</code> Bedingung erlaubt es uns, beliebige Bedingungen zu definieren, die erf\u00fcllt sein m\u00fcssen. Auch hier beginnen wir wieder mit dem generellen Aufbau der Befehle.</p> <pre><code>CREATE TABLE tabellenname (\n    spalte DATENTYP CHECK (bedingung)\n);\n</code></pre> <p>Wie man erkennt, wird lediglich eine Bedingung nach dem <code>CHECK</code> Schl\u00fcsselwort definiert. Schauen wir uns wieder ein Beispiel an. </p> Wertebereich pr\u00fcfen <p>Wir erstellen eine neue Tabelle mit einer oder mehreren Spalten, die einen Wertebereich pr\u00fcfen m\u00fcssen.</p> <pre><code>CREATE TABLE qualitaetsmessungen (\n    messung_id SERIAL PRIMARY KEY,\n    produkt_id INTEGER NOT NULL,\n    messdatum DATE NOT NULL,\n    pruefergebnis INTEGER CHECK (pruefergebnis &gt;= 0 AND pruefergebnis &lt;= 100),\n    temperatur NUMERIC(4,1) CHECK (temperatur &gt;= -20 AND temperatur &lt;= 50),\n    luftfeuchtigkeit INTEGER CHECK (luftfeuchtigkeit &gt;= 0 AND luftfeuchtigkeit &lt;= 100)\n);\n</code></pre> <p>Nun erstellen wir eine Messung mit einem Pr\u00fcfergebnis von 150 (ung\u00fcltig).</p> <pre><code>-- Fehler: Pr\u00fcfergebnis 150 ist ung\u00fcltig!\nINSERT INTO qualitaetsmessungen (produkt_id, messdatum, pruefergebnis, temperatur, luftfeuchtigkeit)\nVALUES (1, '2025-11-25', 150, 22.0, 50);\n</code></pre> Output<pre><code>FEHLER:  neue Zeile f\u00fcr Relation \u00bbqualitaetsmessungen\u00ab verletzt Check-Constraint \u00bbqualitaetsmessungen_pruefergebnis_check\u00ab\nDETAIL:  Fehlgeschlagene Zeile enth\u00e4lt (1, 1, 2025-11-25, 150, 22.0, 50).\n</code></pre> <p>Wir sehen also, dass die Einf\u00fcgung fehlschl\u00e4gt und wir eine Fehlermeldung erhalten. Dem User ist es also nicht m\u00f6glich, eine Messung mit einem Pr\u00fcfergebnis von 150 zu erstellen.</p> Weitere Beispiele CHECK mit Status-Werten <p>CHECK kann auch verwendet werden, um nur bestimmte Werte zuzulassen:</p> <pre><code>CREATE TABLE pruefungen_mit_status (\n    pruefung_id SERIAL PRIMARY KEY,\n    produkt_id INTEGER NOT NULL,\n    pruefdatum DATE NOT NULL,\n    pruefergebnis INTEGER,\n    status VARCHAR(20) CHECK (status IN ('ausstehend', 'bestanden', 'durchgefallen', 'nachpruefung'))\n);\n</code></pre> <p>Versuchen wir nun einen ung\u00fcltigen Status einzuf\u00fcgen:</p> <pre><code>-- Fehler: 'pending' ist kein g\u00fcltiger Status\nINSERT INTO pruefungen_mit_status (produkt_id, pruefdatum, status)\nVALUES (1, '2025-11-25', 'pending');\n</code></pre> Output<pre><code>FEHLER:  neue Zeile f\u00fcr Relation \u00bbpruefungen_mit_status\u00ab verletzt Check-Constraint \u00bbpruefungen_mit_status_status_check\u00ab\nDETAIL:  Fehlgeschlagene Zeile enth\u00e4lt (1, 1, 2025-11-25, null, pending).\n</code></pre>"},{"location":"database/integritaet/#praktisches-arbeiten-mit-constraints","title":"Praktisches Arbeiten mit Constraints","text":"<p>Abschlie\u00dfend wollen wir uns noch einmal anschauen, wie wir mit Constraints in der Praxis arbeiten k\u00f6nnen.</p>"},{"location":"database/integritaet/#position-von-constraints","title":"Position von Constraints","text":"<p>Generell hat man bei <code>CHECK</code>-Constraints (und auch anderen) zwei M\u00f6glichkeiten, wo man sie platzieren kann:</p> Variante 1: Spalten-Constraint (inline) <p>Die Bedingung wird direkt bei der Spalte definiert:</p> <pre><code>CREATE TABLE messungen (\n    messung_id SERIAL PRIMARY KEY,\n    produkt_id INTEGER NOT NULL,\n    pruefergebnis INTEGER CHECK (pruefergebnis &gt;= 0 AND pruefergebnis &lt;= 100)\n);\n</code></pre> <p>Vorteil: \u00dcbersichtlich bei einfachen Regeln, die nur eine Spalte betreffen.</p> Variante 2: Tabellen-Constraint (separate Zeile) <p>Der Constraint wird am Ende der Tabelle als eigene Zeile definiert. Der Vorteil ist, dass man mehrere Spalten gleichzeitig pr\u00fcfen kann.</p> <pre><code>CREATE TABLE pruefperioden (\n    periode_id SERIAL PRIMARY KEY,\n    produkt_id INTEGER,\n    startdatum DATE,\n    enddatum DATE,\n    kosten NUMERIC(10,2),\n    CHECK (startdatum &lt; enddatum)  -- Pr\u00fcft 2 Spalten!\n);\n</code></pre> Wann welche Variante? <p>Inline (bei der Spalte):</p> <ul> <li>F\u00fcr einfache Regeln, die nur eine Spalte betreffen</li> <li>Wenn du die Regel direkt bei der Spaltendefinition sehen m\u00f6chtest</li> <li>Beispiel: <code>pruefergebnis INTEGER CHECK (pruefergebnis &gt;= 0 AND pruefergebnis &lt;= 100)</code></li> </ul> <p>Separate Zeile (Tabellen-Constraint):</p> <ul> <li>Wenn du mehrere Spalten gleichzeitig pr\u00fcfen musst</li> <li>F\u00fcr komplexere Bedingungen, die mehrere Felder vergleichen</li> <li>Beispiel: <code>CHECK (startdatum &lt; enddatum)</code></li> </ul> <p>Fazit: Beides ist erlaubt! W\u00e4hle die Variante, die f\u00fcr deine Situation am \u00fcbersichtlichsten ist.</p>"},{"location":"database/integritaet/#constraints-benennen","title":"Constraints benennen","text":"<p>Constraints k\u00f6nnen von uns auch einen eigenen Namen bekommen, um sie sp\u00e4ter leichter zu identifizieren:</p> Benannte Constraints <p>Wir erstellen wieder eine neue Tabelle mit benannten Constraints.</p> <pre><code>CREATE TABLE produkte_benannt (\n    produkt_id INTEGER,\n    produktcode VARCHAR(20),\n    mindestqualitaet INTEGER,\n\n    CONSTRAINT pk_produkte PRIMARY KEY (produkt_id),\n    CONSTRAINT uq_produktcode UNIQUE (produktcode),\n    CONSTRAINT ck_mindestqualitaet CHECK (mindestqualitaet &gt;= 0 AND mindestqualitaet &lt;= 100)\n);\n</code></pre> <p>Nun versuchen wir absichtlich einen Fehler bei der Bedingung <code>ck_mindestqualitaet</code> hervorzurufen indem wir einen Wert von <code>150</code> einf\u00fcgen.</p> <pre><code>INSERT INTO produkte_benannt (produkt_id, produktcode, mindestqualitaet)\nVALUES (1, 'SP-2025-001', 150);\n</code></pre> Output<pre><code>FEHLER:  neue Zeile f\u00fcr Relation \u00bbprodukte_benannt\u00ab verletzt Check-Constraint \u00bbck_mindestqualitaet\u00ab\nDETAIL:  Fehlgeschlagene Zeile enth\u00e4lt (1, SP-2025-001, 150).\n</code></pre> <p>Wir sehen also, dass die Einf\u00fcgung fehlschl\u00e4gt und wir erhalten bei der Fehlermeldung den Namen des Constraints <code>ck_mindestqualitaet</code>.</p>"},{"location":"database/integritaet/#nachtraglichs-hinzufugen","title":"Nachtr\u00e4glichs hinzuf\u00fcgen","text":"<p>Wie bereits erw\u00e4hnt, sollten wir Constraints bereits bei der Erstellung der Tabelle definieren. Doch was passiert, wenn wir sp\u00e4ter feststellen, dass wir ein Constraint ben\u00f6tigen?</p> <p>Es gibt auch die M\u00f6glichkeit, Constraints zu bestehenden Tabellen nachtr\u00e4glich hinzuzuf\u00fcgen. Dies passiert allemein mit dem <code>ALTER TABLE</code> Befehl welchen wir bereits im Kapitel Datenbanken manipulieren kennengelernt haben.</p> Constraints mit ALTER TABLE <p>NOT NULL hinzuf\u00fcgen: </p><pre><code>ALTER TABLE pruefungen\nALTER COLUMN pruefername SET NOT NULL;\n</code></pre><p></p> <p>UNIQUE hinzuf\u00fcgen: </p><pre><code>ALTER TABLE produkte\nADD CONSTRAINT produktcode_unique UNIQUE (produktcode);\n</code></pre><p></p> <p>CHECK hinzuf\u00fcgen: </p><pre><code>ALTER TABLE pruefungen\nADD CONSTRAINT pruefergebnis_check CHECK (pruefergebnis &gt;= 0 AND pruefergebnis &lt;= 100);\n</code></pre><p></p> <p>DEFAULT hinzuf\u00fcgen: </p><pre><code>ALTER TABLE pruefungen\nALTER COLUMN status SET DEFAULT 'ausstehend';\n</code></pre><p></p> <p>Constraint entfernen: </p><pre><code>ALTER TABLE produkte\nDROP CONSTRAINT produktcode_unique;\n</code></pre><p></p>"},{"location":"database/integritaet/#ubung","title":"\u00dcbung \u270d\ufe0f","text":"<p>Nun wenden wir Constraints auf unser TecGuy GmbH Produktionsplanungssystem an! Die \u00dcbungen decken alle wichtigen Constraint-Typen ab und helfen dir, Datenintegrit\u00e4t in der Praxis durchzusetzen.</p> \u00dcbungsvorbereitung - Datenbank zur\u00fccksetzen <p>Falls du das vorherige Kapitel nicht abgeschlossen hast oder neu starten m\u00f6chtest, f\u00fchre dieses Setup aus. Es l\u00f6scht alle bestehenden Daten und erstellt den korrekten Ausgangszustand f\u00fcr dieses Kapitel.</p> Setup <pre><code>-- Zu anderer Datenbank wechseln\n\\c postgres\n\n-- Zur Datenbank wechseln (oder neu erstellen)\nDROP DATABASE IF EXISTS produktionsplanung_db;\nCREATE DATABASE produktionsplanung_db;\n\\c produktionsplanung_db\n\n-- 1. Tabelle f\u00fcr Maschinen erstellen\nCREATE TABLE maschinen (\n    maschinen_id INTEGER PRIMARY KEY,\n    maschinenname VARCHAR(100),\n    maschinentyp VARCHAR(50),\n    produktionshalle VARCHAR(50),\n    anschaffungsjahr INTEGER,\n    maschinenstatus VARCHAR(20),\n    wartungsintervall_tage INTEGER\n);\n\n-- 2. Tabelle f\u00fcr Produktionsauftr\u00e4ge erstellen (MIT FK-Constraint)\nCREATE TABLE produktionsauftraege (\n    auftrag_id INTEGER PRIMARY KEY,\n    auftragsnummer VARCHAR(20),\n    kunde VARCHAR(100),\n    produkt VARCHAR(100),\n    menge INTEGER,\n    startdatum DATE,\n    lieferdatum DATE,\n    status VARCHAR(20),\n    maschinen_id INTEGER,\n    FOREIGN KEY (maschinen_id) REFERENCES maschinen(maschinen_id)\n        ON DELETE RESTRICT\n);\n\n-- 3. Tabelle f\u00fcr Wartungsprotokolle erstellen (MIT FK-Constraint)\nCREATE TABLE wartungsprotokolle (\n    wartungs_id SERIAL PRIMARY KEY,\n    wartungsdatum DATE NOT NULL,\n    beschreibung TEXT,\n    techniker VARCHAR(100),\n    kosten NUMERIC(10, 2),\n    maschinen_id INTEGER NOT NULL,\n    FOREIGN KEY (maschinen_id) REFERENCES maschinen(maschinen_id)\n        ON DELETE CASCADE\n);\n\n-- 4. Tabelle f\u00fcr Ersatzteile erstellen\nCREATE TABLE ersatzteile (\n    teil_id SERIAL PRIMARY KEY,\n    teilename VARCHAR(100) NOT NULL,\n    hersteller VARCHAR(100),\n    preis NUMERIC(10, 2)\n);\n\n-- 5. Junction Table f\u00fcr n:m Beziehung (Maschinen \u2194 Ersatzteile)\nCREATE TABLE maschinen_ersatzteile (\n    zuordnung_id SERIAL PRIMARY KEY,\n    maschinen_id INTEGER NOT NULL,\n    teil_id INTEGER NOT NULL,\n    benoetigte_anzahl INTEGER DEFAULT 1,\n    FOREIGN KEY (maschinen_id) REFERENCES maschinen(maschinen_id)\n        ON DELETE CASCADE,\n    FOREIGN KEY (teil_id) REFERENCES ersatzteile(teil_id)\n        ON DELETE CASCADE\n);\n\n-- Maschinen-Daten einf\u00fcgen\nINSERT INTO maschinen VALUES\n(1, 'CNC-Fraese Alpha', 'CNC-Fraese', 'Halle A', 2020, 'Aktiv', 90),\n(2, 'Drehbank Delta', 'Drehbank', 'Halle A', 2018, 'Aktiv', 120),\n(3, 'Presse Gamma', 'Presse', 'Halle B', 2019, 'Aktiv', 60),\n(4, 'Schweissroboter Beta', 'Schweissroboter', 'Halle C', 2021, 'Aktiv', 90);\n\n-- Produktionsauftr\u00e4ge-Daten einf\u00fcgen\nINSERT INTO produktionsauftraege VALUES\n(1, 'AUF-2024-001', 'BMW AG', 'Getriebegeh\u00e4use', 500, '2024-04-01', '2024-04-15', 'In Produktion', 1),\n(2, 'AUF-2024-002', 'Audi AG', 'Kurbelwelle', 200, '2024-04-10', '2024-04-20', 'In Produktion', 2),\n(3, 'AUF-2024-003', 'Mercedes-Benz', 'Pleuelstange', 350, '2024-04-05', '2024-04-18', 'In Produktion', 2),\n(4, 'AUF-2024-004', 'Porsche AG', 'Kolben', 150, '2024-04-12', '2024-04-25', 'In Vorbereitung', 4),\n(5, 'AUF-2024-005', 'BMW AG', 'Kurbelwelle', 300, '2024-04-15', '2024-04-22', 'In Produktion', 2),\n(6, 'AUF-2024-006', 'Volkswagen AG', 'Kolben', 400, '2024-04-20', '2024-04-28', 'In Vorbereitung', 1),\n(7, 'AUF-2024-009', 'Porsche AG', 'Kurbelwelle', 120, '2024-04-28', '2024-05-05', 'In Vorbereitung', 2),\n(8, 'AUF-2024-010', 'BMW AG', 'Kolben', 350, '2024-04-12', '2024-04-19', 'In Produktion', 4);\n\n-- Wartungsprotokolle-Daten einf\u00fcgen\nINSERT INTO wartungsprotokolle (wartungsdatum, beschreibung, techniker, kosten, maschinen_id)\nVALUES\n('2024-01-15', 'Routinewartung - Oelwechsel', 'M. Schneider', 250.00, 1),\n('2024-02-10', 'Reparatur Spindelmotor', 'L. Weber', 850.00, 1),\n('2024-01-20', 'Routinewartung - Kalibrierung', 'M. Schneider', 180.00, 2),\n('2024-03-05', 'Austausch Keilriemen', 'L. Weber', 120.00, 2);\n\n-- Ersatzteile-Daten einf\u00fcgen\nINSERT INTO ersatzteile (teilename, hersteller, preis)\nVALUES\n('Spindelmotor 5kW', 'MotorTech GmbH', 1850.00),\n('Kuehlmittelpumpe', 'PumpCo AG', 320.50),\n('Linearfuehrung 500mm', 'Precision Parts', 680.00),\n('Werkzeughalter ISO40', 'ToolSupply GmbH', 145.00),\n('Drehfutter 250mm', 'ChuckMaster', 890.00);\n\n-- Maschinen-Ersatzteile Zuordnungen einf\u00fcgen\nINSERT INTO maschinen_ersatzteile (maschinen_id, teil_id, benoetigte_anzahl)\nVALUES\n(1, 1, 1),  -- CNC-Fraese braucht 1x Spindelmotor\n(1, 2, 2),  -- CNC-Fraese braucht 2x Kuehlmittelpumpe\n(1, 3, 4),  -- CNC-Fraese braucht 4x Linearfuehrung\n(1, 4, 6),  -- CNC-Fraese braucht 6x Werkzeughalter\n(2, 2, 1),  -- Drehbank braucht 1x Kuehlmittelpumpe\n(2, 5, 1);  -- Drehbank braucht 1x Drehfutter\n</code></pre> <p>Hinweis: Alle Foreign Key Constraints sind aktiv. Die Tabellen sind nun vollst\u00e4ndig verkn\u00fcpft!</p> Aufgabe 1: NOT NULL Constraints hinzuf\u00fcgen <p>Die Tabelle <code>produktionsauftraege</code> hat aktuell einige Spalten, die leer sein d\u00fcrfen, obwohl sie kritische Informationen enthalten. F\u00fcge folgende NOT NULL Constraints hinzu:</p> <ul> <li><code>auftragsnummer</code> soll nicht leer sein (jeder Auftrag braucht eine Nummer)</li> <li><code>startdatum</code> soll nicht leer sein (jeder Auftrag braucht ein Startdatum)</li> </ul> <p>Hinweis</p> <p>Mit dem Befehl <code>\\d produktionsauftraege</code> k\u00f6nnen wir die Struktur der Tabelle <code>produktionsauftraege</code> anzeigen und Beschr\u00e4nkungen anzeigen.</p> Aufgabe 2: CHECK Constraint f\u00fcr Wartungsintervalle <p>In der Tabelle <code>maschinen</code> gibt es eine Spalte <code>wartungsintervall_tage</code>, die angibt, nach wie vielen Tagen eine Wartung f\u00e4llig ist.</p> <p>F\u00fcge einen CHECK Constraint hinzu, der sicherstellt, dass das Wartungsintervall mindestens 30 Tage und maximal 365 Tage betr\u00e4gt.</p> <p>Tipp: Verwende einen aussagekr\u00e4ftigen Namen f\u00fcr den Constraint (z.B. <code>ck_wartungsintervall_gueltig</code>). Wieder k\u00f6nnen wir mit dem Befehl <code>\\d maschinen</code> die Struktur der Tabelle <code>maschinen</code> anzeigen und Beschr\u00e4nkungen anzeigen.</p> Aufgabe 3: Multi-Column UNIQUE Constraint <p>In der Tabelle <code>wartungsprotokolle</code> m\u00f6chtest du verhindern, dass dieselbe Maschine zweimal am selben Tag gewartet wird.</p> <p>F\u00fcge einen UNIQUE Constraint hinzu, der die Kombination aus <code>maschinen_id</code> und <code>wartungsdatum</code> eindeutig macht.</p>"},{"location":"database/integritaet/#zusammenfassung","title":"Zusammenfassung \ud83d\udccc","text":"<ul> <li>Constraints erzwingen Datenintegrit\u00e4t auf Datenbankebene</li> <li>NOT NULL \u2013 Verhindert leere Werte</li> <li>UNIQUE \u2013 Erzwingt Eindeutigkeit</li> <li>PRIMARY KEY \u2013 Kombination aus NOT NULL und UNIQUE</li> <li>FOREIGN KEY \u2013 Referenzielle Integrit\u00e4t</li> <li>CHECK \u2013 Eigene Validierungsregeln</li> <li>DEFAULT \u2013 Standardwerte bei fehlender Eingabe</li> <li>Constraints k\u00f6nnen mit <code>ALTER TABLE</code> nachtr\u00e4glich hinzugef\u00fcgt/entfernt werden</li> <li>Constraints sch\u00fctzen vor ung\u00fcltigen Daten, unabh\u00e4ngig von der Anwendung</li> </ul> <p>Im n\u00e4chsten Kapitel lernen wir \u00fcber Transaktionen &amp; ACID \u2013 wie wir Datenintegrit\u00e4t bei gleichzeitigen Zugriffen sicherstellen!</p>"},{"location":"database/join/","title":"Daten Zusammenf\u00fchren","text":""},{"location":"database/join/#joins-daten-aus-mehreren-tabellen-kombinieren","title":"Joins - Daten aus mehreren Tabellen kombinieren","text":"<p>Im vorherigen Kapitel \u00fcber Datenmodellierung haben wir gelernt, wie man Beziehungen zwischen Tabellen modelliert. Jetzt kommt der spannende Teil: Wie fragen wir Daten aus mehreren verkn\u00fcpften Tabellen ab?</p> <p>Die Antwort lautet: JOINs!</p> Quelle: imgflip <p>JOINs sind ein wichtiger Bestandteil relationaler Datenbanken. Sie erlauben es uns, Daten aus verschiedenen Tabellen zu kombinieren und als eine zusammenh\u00e4ngende Ergebnistabelle anzuzeigen. Ohne JOINs w\u00fcrden wir die Vorteile der Aufteilung in mehrere Tabellen nicht nutzen k\u00f6nnen - wir h\u00e4tten zwar sauber strukturierte Daten ohne Redundanz, k\u00f6nnten diese aber nicht sinnvoll miteinander verkn\u00fcpfen und auswerten.</p> <p>In diesem Kapitel lernen wir die verschiedenen JOIN-Typen kennen und verstehen, wann welcher JOIN-Typ die richtige Wahl ist. Dabei werden wir sehen, wie m\u00e4chtig relationale Datenbanken wirklich sind!</p> Beschaffungsmanagement Ausgangssituation <p>Um zu verstehen, warum JOINs so wichtig sind, betrachten wir ein konkretes Problem aus dem Beschaffungsmanagement:</p> Ausgangssituation: zwei getrennte Tabellen<pre><code>-- Tabelle: lieferanten\n lieferant_id | firmenname        | land        | bewertung\n--------------+-------------------+-------------+-----------\n            1 | Stahl GmbH        | Deutschland |       4.5\n            2 | MetalCorp         | Frankreich  |       4.2\n            3 | SteelWorld Inc    | USA         |       3.8\n\n-- Tabelle: bestellungen\n bestell_id | bestelldatum | lieferant_id | gesamtwert | status\n------------+--------------+--------------+------------+-----------\n        101 | 2024-01-15   |            1 |   12500.00 | Geliefert\n        102 | 2024-01-20   |            2 |    8300.00 | In Transit\n        103 | 2024-01-22   |            1 |   15600.00 | Geliefert\n</code></pre> <p>Problem: Wir wissen aus der Bestelltabelle nur die <code>lieferant_id</code>, aber nicht den Firmennamen. Wie zeigen wir Bestellungen mit den Lieferantennamen an?</p> Gew\u00fcnschtes Ergebnis: Gemeinsame Darstellung<pre><code> bestell_id | bestelldatum | firmenname   | gesamtwert | status\n------------+--------------+--------------+------------+-----------\n        101 | 2024-01-15   | Stahl GmbH   |   12500.00 | Geliefert\n        102 | 2024-01-20   | MetalCorp    |    8300.00 | In Transit\n        103 | 2024-01-22   | Stahl GmbH   |   15600.00 | Geliefert\n</code></pre> <p>Daf\u00fcr brauchen wir einen <code>JOIN</code>! Ein <code>JOIN</code> erm\u00f6glicht es uns, die verstreuten Informationen aus beiden Tabellen wieder zusammenzuf\u00fchren und in einer einzigen Ergebniszeile darzustellen. Die Verkn\u00fcpfung erfolgt dabei \u00fcber den Fremdschl\u00fcssel <code>lieferant_id</code> in der Bestellungen-Tabelle, der auf den Prim\u00e4rschl\u00fcssel <code>lieferant_id</code> in der Lieferanten-Tabelle verweist.</p>"},{"location":"database/join/#grundlagen","title":"Grundlagen","text":"<p>Bevor wir uns die verschiedenen JOIN-Typen im Detail ansehen, schauen wir uns die grundlegende Syntax an. Ein JOIN besteht immer aus mehreren Komponenten: der Auswahl der Tabellen (<code>FROM</code> und <code>JOIN</code>), der Verkn\u00fcpfungsbedingung (<code>ON</code>) und optional weiteren Filterbedingungen (<code>WHERE</code>).</p> <pre><code>SELECT spalten\nFROM haupttabelle\n[INNER|LEFT|RIGHT] JOIN andere_tabelle\n    ON haupttabelle.fk = andere_tabelle.pk\nWHERE filter_bedingung;\n</code></pre> <p>Bei der Spaltenauswahl im <code>SELECT</code> k\u00f6nnen wir auf alle Spalten aus beiden Tabellen zugreifen. Um eindeutig zu machen, von welcher Tabelle eine Spalte stammt, verwenden wir die Notation <code>tabellenname.spaltenname</code>. Das ist besonders wichtig, wenn beide Tabellen Spalten mit dem gleichen Namen haben (wie z.B. <code>lieferant_id</code> in beiden Tabellen).</p> <p>Ohne die explizite Angabe der Tabelle w\u00fcrde die Datenbank bei gleichnamigen Spalten (wie <code>lieferant_id</code>) einen Fehler werfen, da sie nicht wei\u00df, welche Spalte gemeint ist. Daher ist die Notation <code>tabellenname.spaltenname</code> bei JOINs nicht nur guter Stil, sondern oft auch notwendig. Sp\u00e4ter werden wir sehen, wie Aliasse diese Schreibweise deutlich verk\u00fcrzen.</p> <p>Es gibt verschiedene Arten von JOINs, die sich darin unterscheiden, welche Datens\u00e4tze sie zur\u00fcckgeben. Die Wahl des richtigen JOIN-Typs h\u00e4ngt davon ab, ob wir nur die Datens\u00e4tze wollen, die in beiden Tabellen vorhanden sind, oder ob wir auch Datens\u00e4tze ohne \u00dcbereinstimmung behalten m\u00f6chten. Die folgende Tabelle gibt einen \u00dcberblick \u00fcber die wichtigsten JOIN-Typen:</p> Join-Typ Was wird zur\u00fcckgegeben? Wann verwenden? <code>INNER JOIN</code> Nur Datens\u00e4tze mit \u00dcbereinstimmung in beiden Tabellen Standard f\u00fcr die meisten Abfragen <code>LEFT JOIN</code> Alle aus linker Tabelle + \u00dcbereinstimmungen rechts Wenn du alle aus Tabelle A willst, auch ohne Match <code>RIGHT JOIN</code> Alle aus rechter Tabelle + \u00dcbereinstimmungen links Selten \u2013 meist als LEFT JOIN umformuliert <code>FULL OUTER JOIN</code> Alle aus beiden Tabellen Sehr selten \u2013 PostgreSQL unterst\u00fctzt es <p>In der Praxis ist der INNER JOIN der am h\u00e4ufigsten verwendete JOIN-Typ, da wir meist nur die Datens\u00e4tze sehen m\u00f6chten, die tats\u00e4chlich miteinander verkn\u00fcpft sind. LEFT und RIGHT JOINs kommen zum Einsatz, wenn wir auch \"verwaiste\" Datens\u00e4tze behalten m\u00f6chten - also solche, die keine Entsprechung in der anderen Tabelle haben.</p> Quelle: LinkedIn Datenbank-Setup <p>F\u00fcr die Beispiele in diesem Kapitel verwenden wir eine Beschaffungs-Datenbank (<code>beschaffung_db</code>), die typische Einkaufsprozesse eines produzierenden Unternehmens abbildet. Diese Datenbank hilft uns, JOINs praxisnah zu \u00fcben.</p> <pre><code>-- Datenbank erstellen\nCREATE DATABASE beschaffung_db;\n\n-- Zur Datenbank wechseln\n\\c beschaffung_db\n\n-- Tabelle 1: Lieferanten\nCREATE TABLE lieferanten (\n    lieferant_id SERIAL PRIMARY KEY,\n    firmenname VARCHAR(100) NOT NULL,\n    land VARCHAR(50),\n    bewertung NUMERIC(2,1)\n);\n\n-- Tabelle 2: Artikel\nCREATE TABLE artikel (\n    artikel_id SERIAL PRIMARY KEY,\n    artikelname VARCHAR(100) NOT NULL,\n    kategorie VARCHAR(50),\n    einkaufspreis NUMERIC(10,2)\n);\n\n-- Tabelle 3: Bestellungen\nCREATE TABLE bestellungen (\n    bestell_id SERIAL PRIMARY KEY,\n    bestelldatum DATE NOT NULL,\n    lieferant_id INTEGER,\n    status VARCHAR(20),\n    FOREIGN KEY (lieferant_id) REFERENCES lieferanten(lieferant_id)\n);\n\n-- Tabelle 4: Bestellpositionen (Zwischentabelle f\u00fcr Bestellungen und Artikel)\nCREATE TABLE bestellpositionen (\n    position_id SERIAL PRIMARY KEY,\n    bestell_id INTEGER NOT NULL,\n    artikel_id INTEGER NOT NULL,\n    menge INTEGER NOT NULL,\n    einzelpreis NUMERIC(10,2),\n    FOREIGN KEY (bestell_id) REFERENCES bestellungen(bestell_id),\n    FOREIGN KEY (artikel_id) REFERENCES artikel(artikel_id)\n);\n\n-- Testdaten einf\u00fcgen\nINSERT INTO lieferanten (firmenname, land, bewertung)\nVALUES\n    ('Stahl GmbH', 'Deutschland', 4.5),\n    ('MetalCorp', 'Frankreich', 4.2),\n    ('SteelWorld Inc', 'USA', 3.8),\n    ('IronWorks AG', 'Deutschland', NULL);  -- Neuer Lieferant, noch keine Bewertung\n\nINSERT INTO artikel (artikelname, kategorie, einkaufspreis)\nVALUES\n    ('Stahlblech 2mm', 'Rohmaterial', 12.50),\n    ('Aluminiumprofile', 'Rohmaterial', 25.00),\n    ('Schrauben M8', 'Befestigung', 0.15),\n    ('Muttern M8', 'Befestigung', 0.08),\n    ('Dichtungsringe', 'Zubehoer', 1.20);\n\nINSERT INTO bestellungen (bestelldatum, lieferant_id, status)\nVALUES\n    ('2024-01-15', 1, 'Geliefert'),\n    ('2024-01-20', 2, 'In Transit'),\n    ('2024-01-22', 1, 'Geliefert'),\n    ('2024-01-25', 3, 'Bestellt'),\n    ('2024-01-28', NULL, 'Entwurf');  -- Bestellung ohne Lieferant (noch in Planung)\n\nINSERT INTO bestellpositionen (bestell_id, artikel_id, menge, einzelpreis)\nVALUES\n    (1, 1, 500, 12.50),   -- Bestell. 1: 500x Stahlblech\n    (1, 3, 5000, 0.15),   -- Bestell. 1: 5000x Schrauben\n    (2, 2, 200, 25.00),   -- Bestell. 2: 200x Aluminiumprofile\n    (3, 1, 300, 12.50),   -- Bestell. 3: 300x Stahlblech\n    (3, 4, 5000, 0.08),   -- Bestell. 3: 5000x Muttern\n    (4, 5, 800, 1.20);    -- Bestell. 4: 800x Dichtungsringe\n</code></pre> <p>Hinweis: Beachte, dass die Bestellung mit ID 5 bewusst keinen Lieferanten hat (<code>lieferant_id = NULL</code>) und der Lieferant \"IronWorks AG\" noch keine Bestellungen hat. Dies wird uns helfen, die Unterschiede zwischen INNER JOIN und LEFT JOIN zu verstehen.</p>"},{"location":"database/join/#join-typen","title":"JOIN-Typen","text":""},{"location":"database/join/#inner-join","title":"<code>INNER JOIN</code>","text":"<p>Der <code>INNER JOIN</code> ist der Standard-JOIN und bildet die Schnittmenge zweier Tabellen. Er gibt nur Datens\u00e4tze zur\u00fcck, die in beiden Tabellen eine \u00dcbereinstimmung haben. Stellen Sie sich zwei Kreise vor, die sich \u00fcberschneiden - der <code>INNER JOIN</code> liefert genau den Bereich, in dem sich beide Kreise treffen. Der Syntax f\u00fcr einen <code>INNER JOIN</code> ist wie folgt:</p> <pre><code>SELECT spalten\nFROM tabelle1\nINNER JOIN tabelle2 ON tabelle1.fremdschl\u00fcssel = tabelle2.prim\u00e4rschl\u00fcssel\nWHERE bedingung;\n</code></pre> <p>Nun f\u00fchren wir unseren ersten JOIN aus. </p> <code>INNER JOIN</code> - Bestellungen mit Lieferantennamen <p>Wir wollen alle Bestellungen mit den zugeh\u00f6rigen Lieferantennamen anzeigen. Die <code>ON</code>-Klausel verbindet die beiden Tabellen \u00fcber die Lieferanten-IDs:</p> <pre><code>SELECT\n    bestellungen.bestell_id,\n    bestellungen.bestelldatum,\n    lieferanten.firmenname,\n    bestellungen.status\nFROM bestellungen\nINNER JOIN lieferanten ON bestellungen.lieferant_id = lieferanten.lieferant_id;\n</code></pre> Output<pre><code> bestell_id | bestelldatum |   firmenname   |   status\n------------+--------------+----------------+------------\n          1 | 2024-01-15   | Stahl GmbH     | Geliefert\n          2 | 2024-01-20   | MetalCorp      | In Transit\n          3 | 2024-01-22   | Stahl GmbH     | Geliefert\n          4 | 2024-01-25   | SteelWorld Inc | Bestellt\n(4 rows)\n</code></pre> <p>Wir erkennen nun, dass die Bestellung Nr. 5 (Entwurf ohne Lieferant) und der Lieferant IronWorks AG (ohne Bestellungen) fehlen! Warum? Beide haben in der jeweils anderen Tabelle keinen passenden Datensatz gefunden. Da der <code>INNER JOIN</code> nur Zeilen zur\u00fcckgibt, bei denen in beiden Tabellen ein passender Datensatz existiert, werden diese Eintr\u00e4ge ignoriert. Dies ist ein wichtiges Verhalten: <code>INNER JOIN</code> ist restriktiv und zeigt nur vollst\u00e4ndige Verkn\u00fcpfungen.</p> Definition: <code>INNER JOIN</code> <p><code>INNER JOIN</code> zeigt nur Datens\u00e4tze, die in beiden Tabellen verkn\u00fcpft sind. Datens\u00e4tze ohne \u00dcbereinstimmung werden weggelassen.</p>"},{"location":"database/join/#exkurs-aliasse","title":"Exkurs: Aliasse","text":"<p>Bevor wir uns die weiteren JOIN-Typen ansehen, nehmen wir einen kleinen Exkurs und schauen uns an, wie wir Tabellennamen verk\u00fcrzen k\u00f6nnen mit Aliassen. Wir haben Aliasse bereits im Kapitel Abfragen von Daten kennengelernt.</p> <p>Je komplexer unsere Abfragen werden, desto un\u00fcbersichtlicher werden lange Tabellennamen wie <code>bestellungen.bestelldatum</code> und <code>lieferanten.firmenname</code>. Hier kommen Aliasse ins Spiel. Bei JOINs schreiben wir oft lange Tabellennamen - Aliasse (Abk\u00fcrzungen) machen das \u00fcbersichtlicher und sind in der Praxis absolut \u00fcblich. Fast jede JOIN-Abfrage, die Sie in der Realit\u00e4t sehen werden, verwendet Aliasse.</p> Aliasse bei JOINs <pre><code>SELECT\n    b.bestell_id,\n    b.bestelldatum,\n    l.firmenname,\n    l.land,\n    b.status\nFROM bestellungen AS b\nINNER JOIN lieferanten AS l ON b.lieferant_id = l.lieferant_id;\n</code></pre> <p>oder noch k\u00fcrzer (ohne <code>AS</code>):</p> <pre><code>SELECT\n    b.bestell_id,\n    b.bestelldatum,\n    l.firmenname,\n    b.status\nFROM bestellungen b\nINNER JOIN lieferanten l ON b.lieferant_id = l.lieferant_id;\n</code></pre> Best Practice <p>Verwende immer kurze, aussagekr\u00e4ftige Aliasse (z.B. <code>m</code>, <code>t</code>) bei JOINs \u2013 das macht die Abfrage viel lesbarer!</p>"},{"location":"database/join/#left-join","title":"<code>LEFT JOIN</code>","text":"<p>Was aber, wenn wir alle Bestellungen sehen wollen, unabh\u00e4ngig davon, ob sie bereits einem Lieferanten zugeordnet sind oder nicht? Hier kommt der <code>LEFT JOIN</code> (auch <code>LEFT OUTER JOIN</code>) ins Spiel. Er gibt alle Datens\u00e4tze der linken Tabelle zur\u00fcck, auch wenn sie keine \u00dcbereinstimmung in der rechten Tabelle haben.</p> <p>Der Unterschied zum <code>INNER JOIN</code> ist subtil aber wichtig: Beim LEFT JOIN ist die linke Tabelle (in unserem Fall <code>bestellungen</code>) die \"dominante\" Tabelle - alle ihre Zeilen erscheinen im Ergebnis. Gibt es f\u00fcr eine Bestellung keinen passenden Lieferanten, werden die Spalten aus der Lieferanten-Tabelle einfach mit <code>NULL</code> gef\u00fcllt.</p> <code>LEFT JOIN</code> - Bestellungen mit Lieferantennamen <pre><code>SELECT\n    b.bestell_id,\n    b.bestelldatum,\n    l.firmenname,\n    l.land,\n    b.status\nFROM bestellungen b\nLEFT JOIN lieferanten l ON b.lieferant_id = l.lieferant_id;\n</code></pre> Output<pre><code> bestell_id | bestelldatum |   firmenname   |    land     |   status\n------------+--------------+----------------+-------------+------------\n          1 | 2024-01-15   | Stahl GmbH     | Deutschland | Geliefert\n          2 | 2024-01-20   | MetalCorp      | Frankreich  | In Transit\n          3 | 2024-01-22   | Stahl GmbH     | Deutschland | Geliefert\n          4 | 2024-01-25   | SteelWorld Inc | USA         | Bestellt\n          5 | 2024-01-28   |                |             | Entwurf\n(5 rows)\n</code></pre> <p>Und nun sehen wir, dass Bestellung Nr. 5 dabei ist, obwohl kein Lieferant zugeordnet ist! An der Stelle, wo der Lieferantenname und das Land stehen sollten, steht <code>NULL</code>. Dies ist besonders n\u00fctzlich, wenn wir beispielsweise alle Bestellungen auflisten wollen, die noch keinen Lieferanten zugewiesen haben, oder wenn wir eine \u00dcbersicht aller Bestellungen brauchen, unabh\u00e4ngig von ihrem Bearbeitungsstatus.</p> <p><code>LEFT JOIN</code> wird in der Praxis oft verwendet, da es wichtig sein kann, auch \"unvollst\u00e4ndige\" Datens\u00e4tze zu sehen. Denken wir an Berichte oder \u00dcbersichten, wo wir nicht versehentlich Datens\u00e4tze verschweigen wollen, nur weil eine Verkn\u00fcpfung fehlt.</p> <code>LEFT JOIN</code>: Lieferanten ohne Bestellungen finden <p>Ein weiterer h\u00e4ufiger Anwendungsfall: Welche Lieferanten haben noch keine Bestellungen erhalten?</p> <pre><code>SELECT\n    l.firmenname,\n    l.land,\n    COUNT(b.bestell_id) AS anzahl_bestellungen\nFROM lieferanten l\nLEFT JOIN bestellungen b ON l.lieferant_id = b.lieferant_id\nGROUP BY l.firmenname, l.land\nHAVING COUNT(b.bestell_id) = 0;\n</code></pre> Output<pre><code>  firmenname  |    land     | anzahl_bestellungen\n--------------+-------------+---------------------\n IronWorks AG | Deutschland |                   0\n(1 row)\n</code></pre> <p>Mit LEFT JOIN und Aggregation k\u00f6nnen wir leicht herausfinden, welche Lieferanten noch nie eine Bestellung erhalten haben.</p>"},{"location":"database/join/#right-full-outer-join","title":"<code>RIGHT</code> &amp; <code>FULL OUTER JOIN</code>","text":"<p>Der <code>RIGHT JOIN</code> (auch <code>RIGHT OUTER JOIN</code>) ist das Spiegelbild des <code>LEFT JOIN</code>: Alle Datens\u00e4tze der rechten Tabelle werden zur\u00fcckgegeben. Anstatt dass die linke Tabelle dominant ist, ist nun die rechte Tabelle die f\u00fchrende - alle ihre Zeilen erscheinen im Ergebnis, auch wenn es keine \u00dcbereinstimmung in der linken Tabelle gibt.</p> <p>In der Praxis wird <code>RIGHT JOIN</code> jedoch sehr selten verwendet, da man das gleiche Ergebnis durch Vertauschen der Tabellen und Verwendung eines <code>LEFT JOIN</code> erreichen kann. Die meisten Entwickler bevorzugen <code>LEFT JOIN</code>, weil es intuitiver ist: Man liest von links nach rechts und die \"Haupttabelle\" steht links. Aus diesem Grund werden Sie in professionellem Code kaum RIGHT JOINs finden - es ist einfach eine Konventionsfrage, und die Konvention hat sich klar f\u00fcr LEFT JOIN entschieden.</p> <p>Der <code>FULL OUTER JOIN</code> vereint <code>LEFT</code> und <code>RIGHT JOIN</code>: Er gibt alle Datens\u00e4tze aus beiden Tabellen zur\u00fcck, unabh\u00e4ngig davon, ob eine Verkn\u00fcpfung existiert oder nicht. Fehlende Werte werden mit <code>NULL</code> gef\u00fcllt. Dieser JOIN-Typ ist noch seltener als <code>RIGHT JOIN</code> und wird nur in sehr spezifischen Szenarien ben\u00f6tigt - beispielsweise wenn man alle Datens\u00e4tze aus beiden Tabellen sehen m\u00f6chte, um Inkonsistenzen oder fehlende Verkn\u00fcpfungen zu identifizieren.</p> <p>F\u00fcr die allermeisten Anwendungsf\u00e4lle reichen <code>INNER JOIN</code> und <code>LEFT JOIN</code> vollkommen aus. Diese beiden sollten wir gut beherrschen, w\u00e4hrend <code>RIGHT JOIN</code> und <code>FULL OUTER JOIN</code> eher Randerscheinungen sind, die wir kennen, aber selten verwenden werden.</p>"},{"location":"database/join/#verbinde-mehrere-tabellen","title":"Verbinde mehrere Tabellen","text":"<p>Bisher haben wir in unseren Beispielen immer nur zwei Tabellen miteinander verkn\u00fcpft. In der Realit\u00e4t sind Datenbanken jedoch oft komplexer strukturiert, und wir m\u00fcssen Daten aus drei, vier oder sogar noch mehr Tabellen kombinieren. Die gute Nachricht: Man kann beliebig viele Tabellen in einer einzigen Abfrage joinen!</p> <p>Dies ist besonders bei komplexen Gesch\u00e4ftsprozessen wichtig. In unserem Beschaffungsszenario m\u00fcssen wir beispielsweise Bestellungen, Lieferanten, Artikel und Bestellpositionen zusammenf\u00fchren, um eine vollst\u00e4ndige \u00dcbersicht zu erhalten.</p> Verbinde mehrere Tabellen <p>Stellen wir uns vor, wir m\u00f6chten eine vollst\u00e4ndige \u00dcbersicht aller Bestellpositionen mit Lieferant, Artikel und Gesamtkosten:</p> <pre><code>-- Welche Artikel wurden von welchem Lieferanten bestellt?\nSELECT\n    l.firmenname AS lieferant,\n    b.bestelldatum,\n    a.artikelname,\n    bp.menge,\n    bp.einzelpreis,\n    (bp.menge * bp.einzelpreis) AS positionswert\nFROM bestellpositionen bp\nINNER JOIN bestellungen b ON bp.bestell_id = b.bestell_id\nINNER JOIN lieferanten l ON b.lieferant_id = l.lieferant_id\nINNER JOIN artikel a ON bp.artikel_id = a.artikel_id\nORDER BY b.bestelldatum, l.firmenname;\n</code></pre> Output<pre><code>   lieferant    | bestelldatum |   artikelname    | menge | einzelpreis | positionswert\n----------------+--------------+------------------+-------+-------------+---------------\n Stahl GmbH     | 2024-01-15   | Stahlblech 2mm   |   500 |       12.50 |       6250.00\n Stahl GmbH     | 2024-01-15   | Schrauben M8     |  5000 |        0.15 |        750.00\n MetalCorp      | 2024-01-20   | Aluminiumprofile |   200 |       25.00 |       5000.00\n Stahl GmbH     | 2024-01-22   | Stahlblech 2mm   |   300 |       12.50 |       3750.00\n Stahl GmbH     | 2024-01-22   | Muttern M8       |  5000 |        0.08 |        400.00\n SteelWorld Inc | 2024-01-25   | Dichtungsringe   |   800 |        1.20 |        960.00\n(6 rows)\n</code></pre> <p>Die Datenbank f\u00fchrt die JOINs sequenziell aus - erst wird das erste JOIN-Paar verarbeitet, dann das Ergebnis mit der n\u00e4chsten Tabelle verkn\u00fcpft:</p> <ol> <li><code>bestellpositionen</code> mit <code>bestellungen</code> joinen (\u00fcber <code>bestell_id</code>)</li> <li>Das Zwischenergebnis mit <code>lieferanten</code> joinen (\u00fcber <code>lieferant_id</code>)</li> <li>Das Zwischenergebnis mit <code>artikel</code> joinen (\u00fcber <code>artikel_id</code>)</li> </ol> <p>In diesem Beispiel nutzen wir ausschlie\u00dflich <code>INNER JOINs</code>, weil wir nur vollst\u00e4ndige Datens\u00e4tze sehen wollen. W\u00fcrden wir auch Bestellungen ohne Lieferanten oder Positionen ohne Artikel sehen wollen, m\u00fcssten wir <code>LEFT JOINs</code> verwenden.</p> Kombination aus mehreren JOINs und Aggregationen <p>Besonders m\u00e4chtig wird die Kombination aus mehreren JOINs und Aggregationen. Zum Beispiel: Welcher Lieferant hat das gr\u00f6\u00dfte Bestellvolumen?</p> <pre><code>SELECT\n    l.firmenname,\n    l.land,\n    COUNT(DISTINCT b.bestell_id) AS anzahl_bestellungen,\n    SUM(bp.menge * bp.einzelpreis) AS gesamtumsatz\nFROM lieferanten l\nLEFT JOIN bestellungen b ON l.lieferant_id = b.lieferant_id\nLEFT JOIN bestellpositionen bp ON b.bestell_id = bp.bestell_id\nGROUP BY l.firmenname, l.land\nORDER BY gesamtumsatz DESC NULLS LAST;\n</code></pre> Output<pre><code>   firmenname   |    land     | anzahl_bestellungen | gesamtumsatz\n----------------+-------------+---------------------+--------------\n Stahl GmbH     | Deutschland |                   2 |     11150.00\n MetalCorp      | Frankreich  |                   1 |      5000.00\n SteelWorld Inc | USA         |                   1 |       960.00\n IronWorks AG   | Deutschland |                   0 |\n(4 rows)\n</code></pre> <p>Hier verwenden wir <code>LEFT JOIN</code>, um auch Lieferanten ohne Bestellungen (wie IronWorks AG) anzuzeigen. Die Aggregation zeigt uns dann, welche Lieferanten am wichtigsten sind.</p>"},{"location":"database/join/#ubung","title":"\u00dcbung \u270d\ufe0f","text":"<p>Nun wenden wir das Erlernte auf unser TecGuy GmbH Produktionsplanungssystem an! Wir nutzen die in den vorherigen Kapiteln erstellten Tabellen und verkn\u00fcpfen sie mit JOINs, um aussagekr\u00e4ftige Berichte und Analysen zu erstellen.</p> <p>Im vorherigen Kapitel haben wir Foreign Keys und Beziehungen zwischen Tabellen erstellt. Jetzt lernen wir, wie man Daten aus mehreren verkn\u00fcpften Tabellen abfragt.</p> \u00dcbungsvorbereitung - Datenbank zur\u00fccksetzen <p>Falls du das vorherige Kapitel nicht abgeschlossen hast oder neu starten m\u00f6chtest, f\u00fchre dieses Setup aus. Es l\u00f6scht alle bestehenden Daten und erstellt den korrekten Ausgangszustand f\u00fcr dieses Kapitel.</p> Setup <pre><code>-- Zu anderer Datenbank wechseln\n\\c postgres\n\n-- Zur Datenbank wechseln (oder neu erstellen)\nDROP DATABASE IF EXISTS produktionsplanung_db;\nCREATE DATABASE produktionsplanung_db;\n\\c produktionsplanung_db\n\n-- 1. Tabelle f\u00fcr Maschinen erstellen\nCREATE TABLE maschinen (\n    maschinen_id INTEGER PRIMARY KEY,\n    maschinenname VARCHAR(100),\n    maschinentyp VARCHAR(50),\n    produktionshalle VARCHAR(50),\n    anschaffungsjahr INTEGER,\n    maschinenstatus VARCHAR(20),\n    wartungsintervall_tage INTEGER\n);\n\n-- 2. Tabelle f\u00fcr Produktionsauftr\u00e4ge erstellen (MIT FK-Constraint)\nCREATE TABLE produktionsauftraege (\n    auftrag_id INTEGER PRIMARY KEY,\n    auftragsnummer VARCHAR(20),\n    kunde VARCHAR(100),\n    produkt VARCHAR(100),\n    menge INTEGER,\n    startdatum DATE,\n    lieferdatum DATE,\n    status VARCHAR(20),\n    maschinen_id INTEGER,\n    FOREIGN KEY (maschinen_id) REFERENCES maschinen(maschinen_id)\n        ON DELETE RESTRICT\n);\n\n-- 3. Tabelle f\u00fcr Wartungsprotokolle erstellen (MIT FK-Constraint)\nCREATE TABLE wartungsprotokolle (\n    wartungs_id SERIAL PRIMARY KEY,\n    wartungsdatum DATE NOT NULL,\n    beschreibung TEXT,\n    techniker VARCHAR(100),\n    kosten NUMERIC(10, 2),\n    maschinen_id INTEGER NOT NULL,\n    FOREIGN KEY (maschinen_id) REFERENCES maschinen(maschinen_id)\n        ON DELETE CASCADE\n);\n\n-- 4. Tabelle f\u00fcr Ersatzteile erstellen\nCREATE TABLE ersatzteile (\n    teil_id SERIAL PRIMARY KEY,\n    teilename VARCHAR(100) NOT NULL,\n    hersteller VARCHAR(100),\n    preis NUMERIC(10, 2)\n);\n\n-- 5. Junction Table f\u00fcr n:m Beziehung (Maschinen \u2194 Ersatzteile)\nCREATE TABLE maschinen_ersatzteile (\n    zuordnung_id SERIAL PRIMARY KEY,\n    maschinen_id INTEGER NOT NULL,\n    teil_id INTEGER NOT NULL,\n    benoetigte_anzahl INTEGER DEFAULT 1,\n    FOREIGN KEY (maschinen_id) REFERENCES maschinen(maschinen_id)\n        ON DELETE CASCADE,\n    FOREIGN KEY (teil_id) REFERENCES ersatzteile(teil_id)\n        ON DELETE CASCADE\n);\n\n-- Maschinen-Daten einf\u00fcgen\nINSERT INTO maschinen VALUES\n(1, 'CNC-Fraese Alpha', 'CNC-Fraese', 'Halle A', 2020, 'Aktiv', 90),\n(2, 'Drehbank Delta', 'Drehbank', 'Halle A', 2018, 'Aktiv', 120),\n(3, 'Presse Gamma', 'Presse', 'Halle B', 2019, 'Aktiv', 60),\n(4, 'Schweissroboter Beta', 'Schweissroboter', 'Halle C', 2021, 'Aktiv', 90);\n\n-- Produktionsauftr\u00e4ge-Daten einf\u00fcgen\nINSERT INTO produktionsauftraege VALUES\n(1, 'AUF-2024-001', 'BMW AG', 'Getriebegeh\u00e4use', 500, '2024-04-01', '2024-04-15', 'In Produktion', 1),\n(2, 'AUF-2024-002', 'Audi AG', 'Kurbelwelle', 200, '2024-04-10', '2024-04-20', 'In Produktion', 2),\n(3, 'AUF-2024-003', 'Mercedes-Benz', 'Pleuelstange', 350, '2024-04-05', '2024-04-18', 'In Produktion', 2),\n(4, 'AUF-2024-004', 'Porsche AG', 'Kolben', 150, '2024-04-12', '2024-04-25', 'In Vorbereitung', 4),\n(5, 'AUF-2024-005', 'BMW AG', 'Kurbelwelle', 300, '2024-04-15', '2024-04-22', 'In Produktion', 2),\n(6, 'AUF-2024-006', 'Volkswagen AG', 'Kolben', 400, '2024-04-20', '2024-04-28', 'In Vorbereitung', 1),\n(7, 'AUF-2024-009', 'Porsche AG', 'Kurbelwelle', 120, '2024-04-28', '2024-05-05', 'In Vorbereitung', 2),\n(8, 'AUF-2024-010', 'BMW AG', 'Kolben', 350, '2024-04-12', '2024-04-19', 'In Produktion', 4);\n\n-- Wartungsprotokolle-Daten einf\u00fcgen\nINSERT INTO wartungsprotokolle (wartungsdatum, beschreibung, techniker, kosten, maschinen_id)\nVALUES\n('2024-01-15', 'Routinewartung - Oelwechsel', 'M. Schneider', 250.00, 1),\n('2024-02-10', 'Reparatur Spindelmotor', 'L. Weber', 850.00, 1),\n('2024-01-20', 'Routinewartung - Kalibrierung', 'M. Schneider', 180.00, 2),\n('2024-03-05', 'Austausch Keilriemen', 'L. Weber', 120.00, 2);\n\n-- Ersatzteile-Daten einf\u00fcgen\nINSERT INTO ersatzteile (teilename, hersteller, preis)\nVALUES\n('Spindelmotor 5kW', 'MotorTech GmbH', 1850.00),\n('Kuehlmittelpumpe', 'PumpCo AG', 320.50),\n('Linearfuehrung 500mm', 'Precision Parts', 680.00),\n('Werkzeughalter ISO40', 'ToolSupply GmbH', 145.00),\n('Drehfutter 250mm', 'ChuckMaster', 890.00);\n\n-- Maschinen-Ersatzteile Zuordnungen einf\u00fcgen\nINSERT INTO maschinen_ersatzteile (maschinen_id, teil_id, benoetigte_anzahl)\nVALUES\n(1, 1, 1),  -- CNC-Fraese braucht 1x Spindelmotor\n(1, 2, 2),  -- CNC-Fraese braucht 2x Kuehlmittelpumpe\n(1, 3, 4),  -- CNC-Fraese braucht 4x Linearfuehrung\n(1, 4, 6),  -- CNC-Fraese braucht 6x Werkzeughalter\n(2, 2, 1),  -- Drehbank braucht 1x Kuehlmittelpumpe\n(2, 5, 1);  -- Drehbank braucht 1x Drehfutter\n</code></pre> <p>Hinweis: Alle Foreign Key Constraints sind aktiv. Die Tabellen sind nun vollst\u00e4ndig verkn\u00fcpft!</p> Aufgabe 1: INNER JOIN - Produktionsauftr\u00e4ge mit Maschinen <p>Erstelle eine \u00dcbersicht aller Produktionsauftr\u00e4ge mit dem Namen der zugeordneten Maschine.</p> <p>Anforderungen:</p> <ul> <li>Zeige: Auftragsnummer, Kunde, Produkt, Maschinennamen, Status</li> <li>Sortiere nach Auftragsnummer</li> <li>Verwende Aliasse f\u00fcr bessere Lesbarkeit</li> </ul> Aufgabe 2: LEFT JOIN - Alle Maschinen und ihre Auftr\u00e4ge <p>Zeige alle Maschinen und die Anzahl ihrer zugeordneten Produktionsauftr\u00e4ge. Auch Maschinen ohne Auftr\u00e4ge sollen angezeigt werden.</p> <p>Anforderungen:</p> <ul> <li>Zeige: Maschinenname, Maschinentyp, Anzahl Auftr\u00e4ge</li> <li>Es sollen auch Maschinen ohne Auftr\u00e4ge erscheinen</li> <li>Gruppiere nach Maschine</li> <li>Sortiere nach Anzahl Auftr\u00e4ge (absteigend)</li> </ul> Aufgabe 3: INNER JOIN - Wartungsprotokolle mit Maschinen <p>Erstelle einen Wartungsbericht: Zeige alle Wartungen mit Maschinenname, sortiert nach Kosten (h\u00f6chste zuerst).</p> <p>Anforderungen:</p> <ul> <li>Zeige: Maschinenname, Wartungsdatum, Beschreibung, Techniker, Kosten</li> <li>Nur Wartungen, die tats\u00e4chlich einer Maschine zugeordnet sind</li> <li>Sortiere nach Kosten absteigend</li> <li>Filtere nur Wartungen mit Kosten &gt; 200 EUR</li> </ul> Aufgabe 4: Mehrere Tabellen - Ersatzteile f\u00fcr Maschinen (n:m) <p>Zeige, welche Maschinen welche Ersatzteile ben\u00f6tigen. Berechne au\u00dferdem die Gesamtkosten pro Maschine.</p> <p>Anforderungen:</p> <ul> <li>Verkn\u00fcpfe 3 Tabellen: <code>maschinen</code>, <code>maschinen_ersatzteile</code>, <code>ersatzteile</code></li> <li>Zeige: Maschinenname, Teilename, ben\u00f6tigte Anzahl, Einzelpreis, Gesamtpreis (Anzahl * Preis)</li> <li>Sortiere nach Maschine und Teilename</li> </ul> Aufgabe 5: Komplexe Abfrage - Produktions\u00fcbersicht <p>Erstelle eine umfassende \u00dcbersicht pro Maschine: Anzahl Auftr\u00e4ge, Anzahl Wartungen und Gesamtwartungskosten.</p> <p>Anforderungen:</p> <ul> <li>Zeige: Maschinenname, Anzahl Produktionsauftr\u00e4ge, Anzahl Wartungen, Gesamtwartungskosten</li> <li>Verwende LEFT JOINs f\u00fcr beide Verkn\u00fcpfungen</li> <li>Gruppiere nach Maschine</li> <li>Sortiere nach Maschinenname</li> </ul>"},{"location":"database/join/#zusammenfassung","title":"Zusammenfassung \ud83d\udccc","text":"<ul> <li>JOINs kombinieren Daten aus mehreren Tabellen</li> <li>INNER JOIN zeigt nur verkn\u00fcpfte Datens\u00e4tze (Schnittmenge)</li> <li>LEFT JOIN zeigt alle aus der linken Tabelle + Matches rechts</li> <li>RIGHT JOIN zeigt alle aus der rechten Tabelle + Matches links</li> <li>Aliasse (z.B. <code>AS a</code>) machen JOINs \u00fcbersichtlicher</li> <li>Man kann beliebig viele Tabellen joinen</li> </ul> <p>Im n\u00e4chsten Kapitel lernen wir fortgeschrittene SQL-Techniken: Unterabfragen, String-Funktionen und mehr! Mit den JOINs haben Sie nun das Fundament gelegt, um auch komplexe Datenbankstrukturen effizient abzufragen.</p> Quelle: blazesql"},{"location":"database/manipulieren/","title":"Daten Manipulieren","text":""},{"location":"database/manipulieren/#daten-manipulieren","title":"Daten manipulieren","text":"<p>In den vorangigen Kapiteln haben wir gelernt, wie man eine Datenbank erstellt, Daten einf\u00fcgt und abfragt.  Dabei haben wir speziell den Fokus auf die Abfrage von Daten gelegt und uns diese im Detail betrachtet.  Doch was passiert, wenn sich Daten \u00e4ndern m\u00fcssen? Wenn eine Maschine in die Wartung geht, der Standort wechselt oder ausgemustert wird?</p> <p>In der Welt der Datenbanken begegnet uns oft der Begriff CRUD. </p> <p></p> <p>CRUD ist ein Akronym und steht f\u00fcr die Grundoperationen der Datenverwaltung.</p> <ul> <li>Create \u2192 <code>CREATE</code> &amp; <code>INSERT</code> - Neue Tabellen und Datens\u00e4tze erstellen</li> <li>Read \u2192 <code>SELECT</code> - Datens\u00e4tze abfragen</li> <li>Update \u2192 <code>UPDATE</code> - Bestehende Datens\u00e4tze \u00e4ndern</li> <li>Delete \u2192 <code>DELETE</code> - Datens\u00e4tze l\u00f6schen</li> </ul> <p>Wie bereits erw\u00e4hnt, haben wir die Abfrage von Daten - und damit die Read-Operation - im vorherigen Kapitel bereits detailreichkennengelernt. Nun wollen wir uns den restlichen drei Operationen widmen.</p> Datenbank-Setup <p>F\u00fcr die Beispiele in diesem Kapitel verwenden wir eine Lagerverwaltungs-Datenbank (<code>lager_db</code>), die typische Artikel in einem Warenlager verwaltet. Diese Datenbank hilft uns, die verschiedenen Manipulationsoperationen praxisnah zu \u00fcben.</p> <pre><code>-- Datenbank erstellen\nCREATE DATABASE lager_db;\n\n-- Zur Datenbank wechseln\n\\c lager_db\n\n-- Tabelle f\u00fcr Artikel erstellen\nCREATE TABLE artikel (\n    artikel_id INTEGER PRIMARY KEY,\n    artikelname VARCHAR(100),\n    kategorie VARCHAR(50),\n    bestand INTEGER,\n    mindestbestand INTEGER,\n    preis NUMERIC(10,2),\n    lagerort VARCHAR(50)\n);\n\n-- Beispieldaten einf\u00fcgen\nINSERT INTO artikel (artikel_id, artikelname, kategorie, bestand, mindestbestand, preis, lagerort)\nVALUES\n    (1, 'Schrauben M6x20', 'Befestigungsmaterial', 5000, 1000, 0.05, 'Regal A1'),\n    (2, 'Muttern M6', 'Befestigungsmaterial', 4500, 1000, 0.03, 'Regal A1'),\n    (3, 'Kugellager 6201', 'Maschinenteile', 150, 50, 12.50, 'Regal B3'),\n    (4, 'Dichtungsring 50mm', 'Dichtungen', 800, 200, 1.20, 'Regal C2'),\n    (5, 'Hydraulikoel 5L', 'Betriebsstoffe', 45, 20, 25.00, 'Gefahrstofflager'),\n    (6, 'Schmierfett 1kg', 'Betriebsstoffe', 60, 15, 18.50, 'Regal D1'),\n    (7, 'Zahnriemen HTD-5M', 'Maschinenteile', 25, 10, 35.00, 'Regal B2'),\n    (8, 'Sicherungsring 25mm', 'Befestigungsmaterial', 1200, 300, 0.15, 'Regal A2');\n</code></pre> <p>Hinweis: Diese Lagerverwaltung wird f\u00fcr alle Beispiele in diesem Kapitel verwendet.</p>"},{"location":"database/manipulieren/#daten-einfugen-mit-insert","title":"Daten einf\u00fcgen mit <code>INSERT</code>","text":"<p>Wir kennen INSERT bereits aus dem vorherigen Kapitel, doch nun wollen wir hier nochmal die wichtigsten Grundlagen wiederholen und erweitern.</p> <p>Mit <code>INSERT</code> f\u00fcgen wir neue Datens\u00e4tze in eine Tabelle ein. Es gibt verschiedene Varianten, je nachdem wie viele Datens\u00e4tze wir einf\u00fcgen m\u00f6chten und welche Spalten wir bef\u00fcllen wollen.</p> <pre><code>INSERT INTO tabellenname (spalte1, spalte2, spalte3)\nVALUES (wert1, wert2, wert3);\n</code></pre> Mehrere Artikel gleichzeitig einf\u00fcgen <pre><code>-- Mehrere Artikel gleichzeitig einf\u00fcgen\nINSERT INTO artikel (artikel_id, artikelname, kategorie, bestand, mindestbestand, preis, lagerort)\nVALUES\n    (9, 'Keilriemen A-13', 'Maschinenteile', 80, 20, 8.50, 'Regal B2'),\n    (10, 'Gewindestange M10', 'Befestigungsmaterial', 300, 100, 2.40, 'Regal A3'),\n    (11, 'O-Ring 30mm', 'Dichtungen', 500, 150, 0.80, 'Regal C1');\n</code></pre> Output<pre><code>INSERT 0 3\n</code></pre> <p>Erkl\u00e4rung: Mehrere Datens\u00e4tze werden mit einem einzigen INSERT-Befehl eingef\u00fcgt - effizienter als einzelne INSERT-Befehle.</p> Fehlende Werte <p>Was passiert eigentlich, wenn man nicht alle Spalten bef\u00fcllt? Probieren wir es aus und sehen, was passiert:</p> <ol> <li> <p>Wir f\u00fcgen einen neuen Artikel hinzu, aber lassen die Spalte <code>lagerort</code> weg:    </p><pre><code>INSERT INTO artikel (artikel_id, artikelname, kategorie, bestand, mindestbestand, preis)\nVALUES (12, 'Distanzhuelse 15mm', 'Maschinenteile', 200, 50, 1.50);\n</code></pre><p></p> </li> <li> <p>Wir f\u00fcgen einen weiteren Artikel hinzu und setzen <code>lagerort</code> explizit auf NULL:    </p><pre><code>INSERT INTO artikel (artikel_id, artikelname, kategorie, bestand, mindestbestand, preis, lagerort)\nVALUES (13, 'Passfeder 8x7x28', 'Maschinenteile', 150, 40, 0.90, NULL);\n</code></pre><p></p> </li> <li> <p>Wir pr\u00fcfen mit <code>SELECT</code>, welche Werte die beiden Artikel f\u00fcr <code>lagerort</code> haben:    </p><pre><code>SELECT * FROM artikel WHERE artikel_id IN (12, 13);\n</code></pre><p></p> </li> </ol> <p>Fragen zum Nachdenken:</p> <ul> <li>Was steht in der <code>lagerort</code>-Spalte bei Artikel 12?</li> <li>Was steht in der <code>lagerort</code>-Spalte bei Artikel 13?</li> <li>Gibt es einen Unterschied? Warum (nicht)?</li> </ul> L\u00f6sung <p>Beobachtung: Beide Artikel haben wahrscheinlich <code>NULL</code> als Lagerort (es wird nichts angezeigt).</p> <p>Erkl\u00e4rung:</p> <ul> <li>Artikel 12: Die Spalte <code>lagerort</code> wurde weggelassen \u2192 Sie enth\u00e4lt den Wert <code>NULL</code></li> <li>Artikel 13: Die Spalte <code>lagerort</code> wurde explizit auf NULL gesetzt \u2192 Sie enth\u00e4lt den Wert <code>NULL</code></li> </ul> <p>Wir haben gesehen, dass in unserem Fall beide Vorgehen zum gleichen Ergebnis f\u00fchren. Doch gibt es auch einen Unterschied? Ja, den kann es geben. Doch daf\u00fcr m\u00fcssen wir uns nochmals genauer ansehen, wie wir die Tabelle erstellt haben.</p>"},{"location":"database/manipulieren/#default-werte","title":"<code>DEFAULT</code>-Werte","text":"<p>Beim Erstellen einer Tabelle k\u00f6nnen wir f\u00fcr Spalten Standardwerte definieren. Diese werden automatisch verwendet, wenn beim <code>INSERT</code> kein Wert angegeben wird.</p> <pre><code>CREATE TABLE tabellenname (\n    spalte1 typ PRIMARY KEY,\n    spalte2 typ,\n    spalte3 typ,\n    ...\n    spalteN typ DEFAULT 'Wert'  -- Standardwert definiert!\n);\n</code></pre> <p>Standardwerte sind besonders n\u00fctzlich f\u00fcr:</p> <ul> <li>Status-Felder (z.B. Standard: 'Aktiv')</li> <li>Zeitstempel (z.B. Standard: aktuelles Datum)</li> <li>Z\u00e4hler (z.B. Standard: 0)</li> <li>Flags (z.B. Standard: FALSE)</li> </ul> <code>DEFAULT</code>-Werte in Aktion <p>Probieren wir <code>DEFAULT</code>-Werte praktisch aus! Erstelle eine neue Tabelle <code>werkzeuge</code> mit <code>DEFAULT</code>-Werten:</p> <pre><code>-- Neue Tabelle mit DEFAULT-Werten erstellen\nCREATE TABLE werkzeuge (\n    werkzeug_id INTEGER PRIMARY KEY,\n    werkzeugname VARCHAR(100),\n    kategorie VARCHAR(50) DEFAULT 'Allgemein',\n    anzahl INTEGER DEFAULT 0,\n    status VARCHAR(20) DEFAULT 'Verfuegbar',\n    standort VARCHAR(50) DEFAULT 'Werkzeugausgabe'\n);\n</code></pre> <p>Testen wir nun wieder die verschiedene INSERT-Szenarien von zuvor: </p> <ol> <li> <p>Wir f\u00fcgen ein neues Werkzeug hinzu, aber lassen die Spalten <code>kategorie</code>, <code>anzahl</code>, <code>status</code> und <code>standort</code> weg.</p> <pre><code>-- Test 1: Alle Spalten weglassen (au\u00dfer Pflichtfelder)\nINSERT INTO werkzeuge (werkzeug_id, werkzeugname)\nVALUES (1, 'Akkuschrauber');\n</code></pre> </li> <li> <p>Wir f\u00fcgen ein weiteres Werkzeug hinzu und setzen die Spalte <code>anzahl</code> explizitauf <code>NULL</code>.</p> <pre><code>-- Test 2: Nur manche Spalten angeben\nINSERT INTO werkzeuge (werkzeug_id, werkzeugname, anzahl)\nVALUES (2, 'Hammer', NULL);\n</code></pre> </li> <li> <p>Wir pr\u00fcfen mit <code>SELECT</code>, welche Werte die beiden Werkzeuge f\u00fcr <code>anzahl</code> haben.</p> <pre><code>SELECT * FROM werkzeuge WHERE werkzeug_id IN (1, 2);\n</code></pre> </li> </ol> <p>Fragen zum Nachdenken:</p> <ul> <li>Wie sieht das Ergebnis nun aus?</li> <li>Wie unterscheidet es sich von dem, was wir zuvor gesehen haben?</li> </ul> L\u00f6sung <p></p> ID Werkzeugname Kategorie Anzahl Status Standort 1 Akkuschrauber Allgemein (DEFAULT) 0 (DEFAULT) Verfuegbar (DEFAULT) Werkzeugausgabe (DEFAULT) 2 Hammer Allgemein (DEFAULT) NULL Verfuegbar (DEFAULT) Werkzeugausgabe (DEFAULT) <p></p> <p>Beobachtungen:</p> <ul> <li>Zeile 1: Alle nicht angegebenen Spalten haben ihre DEFAULT-Werte bekommen</li> <li>Zeile 2: <code>anzahl</code> wurde explizit mit <code>NULL</code> angegeben, die restlichen Spalten bekamen DEFAULT-Werte</li> </ul> <p>Wir sehen also, dass es nun einen Unterschied macht, ob wir eine Spalte explizit mit <code>NULL</code> oder weglassen.</p> The Office Michael Scott GIFfrom The Office GIFs <p>Doch wenn wir uns ehrlich sind, dann haben wir uns mit der expliziten Angabe von <code>NULL</code> unsere sch\u00f6nen <code>DEFAULT</code>-Werte umgangen. Und da wir mit den <code>DEFAULT</code>-Werten ja vermeiden wollten, dass wir fehlende Werte in gewissen Spalten haben, sind wir noch nicht ganz zufrieden damit. </p>"},{"location":"database/manipulieren/#pflichtfeld-mit-not-null","title":"Pflichtfeld mit <code>NOT NULL</code>","text":"<p>Und genau an dieser Stelle kommt die Einschr\u00e4nkung <code>NOT NULL</code> ins Spiel. Mit <code>NOT NULL</code> k\u00f6nnen wir festlegen, dass eine Spalte niemals leer sein darf. Jede Zeile muss einen Wert in dieser Spalte haben. Man kann <code>NOT NULL</code> und <code>DEFAULT</code> auch kombinieren und dies macht in den meisten F\u00e4llen auch Sinn.</p> <pre><code>CREATE TABLE tabellenname (\n    spalte1 typ PRIMARY KEY,\n    spalte2 typ,\n    spalte3 typ,\n    ...\n    spalteN-1 typ NOT NULL, -- Pflichtfeld\n    spalteN typ NOT NULL DEFAULT 'Wert'  -- Pflicht + Standardwert\n);\n</code></pre> <p>Vorteile:</p> <ul> <li>Die Spalte darf nie <code>NULL</code> sein (Vorteil bei Datenqualit\u00e4t!)</li> <li>Wenn man die Spalte beim <code>INSERT</code> wegl\u00e4sst, wird der <code>DEFAULT</code>-Wert verwendet</li> <li>Man muss die Spalte beim <code>INSERT</code> nicht angeben</li> </ul> <code>NOT NULL</code> in Aktion <p>Probieren wir die <code>NOT NULL</code>-Einschr\u00e4nkung praktisch aus! Erstelle eine neue Tabelle <code>werkzeuge_clean</code> mit <code>DEFAULT</code>-Werten und <code>NOT NULL</code>-Einschr\u00e4nkungen:</p> <pre><code>-- Neue Tabelle mit DEFAULT-Werten erstellen\nCREATE TABLE werkzeuge_clean (\n    werkzeug_id INTEGER PRIMARY KEY,\n    werkzeugname VARCHAR(100),\n    kategorie VARCHAR(50) NOT NULL,\n    anzahl INTEGER NOT NULL DEFAULT 0,\n    status VARCHAR(20) DEFAULT 'Verfuegbar',\n    standort VARCHAR(50) DEFAULT 'Werkzeugausgabe'\n);\n</code></pre> <p>Testen wir nun wieder verschiedene INSERT-Szenarien von zuvor: </p> <ol> <li> <p>Wir f\u00fcgen ein neues Werkzeug hinzu, aber lassen die Spalten <code>kategorie</code>, <code>anzahl</code>, <code>status</code> und <code>standort</code> weg.</p> <pre><code>INSERT INTO werkzeuge_clean (werkzeug_id, werkzeugname)\nVALUES (1, 'Akkuschrauber');\n</code></pre> </li> <li> <p>Wir f\u00fcgen ein neues Werkzeug hinzu, aber lassen die Spalten <code>anzahl</code>, <code>status</code> und <code>standort</code> weg.</p> <pre><code>INSERT INTO werkzeuge_clean (werkzeug_id, werkzeugname, kategorie)\nVALUES (2, 'Schlagbohrmaschine', 'Elektrowerkzeug');\n</code></pre> </li> <li> <p>Wir f\u00fcgen ein weiteres Werkzeug hinzu und setzen die Spalte <code>anzahl</code> explizitauf <code>NULL</code>.</p> <pre><code>INSERT INTO werkzeuge_clean (werkzeug_id, werkzeugname, kategorie, anzahl)\nVALUES (3, 'Hammer', 'Handwerkzeug', NULL);\n</code></pre> </li> <li> <p>Wir pr\u00fcfen mit <code>SELECT</code>, welche Werte die beiden Werkzeuge f\u00fcr <code>anzahl</code> haben.</p> <pre><code>SELECT * FROM werkzeuge_clean;\n</code></pre> </li> </ol> <p>Fragen zum Nachdenken:</p> <ul> <li>Wie sieht das Ergebnis nun aus?</li> <li>Wie unterscheidet es sich von dem, was wir zuvor gesehen haben?</li> </ul> L\u00f6sung <p>Beobachtungen:</p> <ul> <li>Bei Aufgabe 1 erhalten wir einen Fehler, da wir die Spalte <code>kategorie</code> nicht angegeben haben, diese aber mit <code>NOT NULL</code> eingeschr\u00e4nkt ist. Auch <code>anzahl</code> wurde nicht angegeben und ist mit <code>NOT NULL</code> eingeschr\u00e4nkt. Aber, da wir hier einen <code>DEFAULT</code>-Wert haben, w\u00fcrde hier der Wert <code>0</code> eingetragen werden.</li> <li>Aufgabe 2 funktioniert, da wir auch die Spalte <code>kategorie</code> angegeben haben. Alle fehlenden Spalten besitzten einen <code>DEFAULT</code>-Wert und werden daher mit diesen Werten eingetragen.</li> <li>Aufgabe 3 bringt auch wieder einen Fehler. Dieses mal bewirkt die Spalte <code>anzahl</code> einen Fehler, da sie mit <code>NOT NULL</code> eingeschr\u00e4nkt ist und explizit mit <code>NULL</code> gesetzt wurde.</li> </ul> <p>Wir haben nun mit <code>DEFAULT</code> und <code>NOT NULL</code> zwei Werkzeuge kennengelernt, welche uns helfen unsere Datenbank konsistent und sauber zu halten. </p> Constraint Weggelassen beim INSERT Explizit NULL beim INSERT Keine <code>NULL</code> <code>NULL</code> <code>DEFAULT 'Wert'</code> <code>'Wert'</code> (Standard) <code>NULL</code> (\u00fcberschreibt Standard) <code>NOT NULL</code> \u274c Fehler \u274c Fehler <code>NOT NULL DEFAULT 'Wert'</code> <code>'Wert'</code> (Standard) \u274c Fehler"},{"location":"database/manipulieren/#daten-aktualisieren-mit-update","title":"Daten aktualisieren mit <code>UPDATE</code>","text":"<p>Nachdem wir die ersten zwei Buchstaben von CRUD gekl\u00e4rt haben, wollen wir uns nun dem dritten Buchstaben widmen. Mit Update \u00e4ndern wir bereits bestehende Datens\u00e4tze in einer Tabelle. Beispielsweise k\u00f6nnen wir den Status einer Maschine \u00e4ndern, wenn sie in die Wartung geht oder der Standort wechselt.</p> <pre><code>UPDATE tabellenname\nSET spalte1 = neuer_wert1,\n    spalte2 = neuer_wert2\nWHERE bedingung;\n</code></pre> <p>Wichtig ist hier, dass wir die <code>WHERE</code>-Klausel verwenden. Ohne diese, werden alle Datens\u00e4tze in der Tabelle ge\u00e4ndert.</p> Verlorene Daten! <p>Ohne eine Sicherungskopie (Backup) w\u00e4ren die urspr\u00fcnglichen Werte unwiderruflich verloren! Es gibt kein \"R\u00fcckg\u00e4ngig\" in SQL!</p> <p>Goldene Regel lautet demnach: Teste immer erst mit <code>SELECT</code>, ob deine WHERE-Bedingung die richtigen Zeilen findet und verwende anschlie\u00dfend das <code>UPDATE</code> in Kombination mit der <code>WHERE</code>-Klausel.</p> Quelle: blazesql Einzelner Datensatz \u00e4ndern <p></p><pre><code>-- Safety Check\nSELECT artikel_id, artikelname, lagerort FROM artikel WHERE artikel_id = 3;\n</code></pre> Output<pre><code> artikel_id |   artikelname   | lagerort\n------------+-----------------+----------\n          3 | Kugellager 6201 | Regal B3\n(1 row)\n</code></pre><p></p> <p>Wir \u00fcberpr\u00fcfen zuerst, ob wir wirklich den richtigen Artikel finden. Wenn ja, k\u00f6nnen wir mit dem <code>UPDATE</code> beginnen.</p> <pre><code>-- Kugellager 6201 wurde umgelagert und Bestand korrigiert\nUPDATE artikel\nSET lagerort = 'Regal B5',\n    bestand = 175\nWHERE artikel_id = 3;\n</code></pre> Output<pre><code>UPDATE 1\n</code></pre> <p>Erkl\u00e4rung: Mit Kommas getrennt k\u00f6nnen mehrere Spalten gleichzeitig ge\u00e4ndert werden.</p> weitere Beispiele <p>Mehrere Datens\u00e4tze \u00e4ndern</p> <pre><code>-- Alle Befestigungsmaterialien in Regal A1 auf Mindestbestand 800 setzen\nUPDATE artikel\nSET mindestbestand = 800\nWHERE kategorie = 'Befestigungsmaterial' AND lagerort = 'Regal A1';\n</code></pre> <p>Erkl\u00e4rung: Alle Datens\u00e4tze, die die WHERE-Bedingung erf\u00fcllen, werden ge\u00e4ndert - in diesem Fall alle Befestigungsmaterialien in Regal A1.</p>"},{"location":"database/manipulieren/#erweiterte-update-techniken","title":"Erweiterte <code>UPDATE</code>-Techniken","text":"<p>Neben einfachen Wertzuweisungen k\u00f6nnen wir in <code>UPDATE</code> auch Berechnungen durchf\u00fchren und String-Operationen anwenden.</p> <p>Numerische Berechnungen</p> <p>Wir k\u00f6nnen mit dem aktuellen Wert rechnen und daraus den neuen Wert berechnen:</p> Numerische Berechnungen im <code>UPDATE</code> <pre><code>-- Safety Check\nSELECT * FROM artikel WHERE kategorie = 'Maschinenteile';\n</code></pre> Output<pre><code> artikel_id |    artikelname     |   kategorie    | bestand | mindestbestand | preis | lagerort\n------------+--------------------+----------------+---------+----------------+-------+----------\n          7 | Zahnriemen HTD-5M  | Maschinenteile |      25 |             10 | 35.00 | Regal B2\n          9 | Keilriemen A-13    | Maschinenteile |      80 |             20 |  8.50 | Regal B2\n         12 | Distanzhuelse 15mm | Maschinenteile |     200 |             50 |  1.50 |\n         13 | Passfeder 8x7x28   | Maschinenteile |     150 |             40 |  0.90 |\n          3 | Kugellager 6201    | Maschinenteile |     175 |             50 | 12.50 | Regal B5\n(5 rows)\n</code></pre> <p>Nun k\u00f6nnen wir beispielsweise den Preis f\u00fcr alle Maschinenteile um 10% erh\u00f6hen.</p> <pre><code>-- Alle Preise um 10% erh\u00f6hen (z.B. Inflationsanpassung)\nUPDATE artikel\nSET preis = preis * 1.10\nWHERE kategorie = 'Maschinenteile';\n</code></pre> <p>Erkl\u00e4rung: Der neue Wert wird aus dem alten Wert * 1.10 berechnet (Erh\u00f6hung um 10%).</p> <p>String-Operationen</p> <p>SQL bietet verschiedene Funktionen zur Bearbeitung von Textwerten. Eine gute \u00dcbersicht findet man hier.</p> String-Operationen im <code>UPDATE</code> <p>Stellen wir uns vor, die Lagerorte haben neue Namen bekommen. Anstelle von \"Regal A1\" soll \"Lagerplatz A1\" stehen.</p> <pre><code>-- 'Regal' durch 'Lagerplatz' ersetzen\nUPDATE artikel\nSET lagerort = REPLACE(lagerort, 'Regal', 'Lagerplatz');\n</code></pre> <p>Mit einer kleinen Abfrage \u00fcberpr\u00fcfen wir, ob alle \u00c4nderungen richtig durchgef\u00fchrt wurden.</p> <pre><code>SELECT artikel_id, artikelname, lagerort FROM artikel;\n</code></pre> Output<pre><code> artikel_id |     artikelname     |     lagerort\n------------+---------------------+------------------\n          4 | Dichtungsring 50mm  | Lagerplatz C2\n          5 | Hydraulikoel 5L     | Gefahrstofflager\n          6 | Schmierfett 1kg     | Lagerplatz D1\n          8 | Sicherungsring 25mm | Lagerplatz A2\n         10 | Gewindestange M10   | Lagerplatz A3\n         11 | O-Ring 30mm         | Lagerplatz C1\n          1 | Schrauben M6x20     | Lagerplatz A1\n          2 | Muttern M6          | Lagerplatz A1\n          7 | Zahnriemen HTD-5M   | Lagerplatz B2\n          9 | Keilriemen A-13     | Lagerplatz B2\n         12 | Distanzhuelse 15mm  |\n         13 | Passfeder 8x7x28    |\n          3 | Kugellager 6201     | Lagerplatz B5\n(13 rows)\n</code></pre> weitere Beispiele <p>Kategorie-Prefix zum Artikelnamen hinzuf\u00fcgen</p> <pre><code>-- Kategorie-Prefix zum Artikelnamen hinzuf\u00fcgen\nUPDATE artikel\nSET artikelname = CONCAT(kategorie, ': ', artikelname)\nWHERE kategorie = 'Maschinenteile';\n</code></pre> <p>Erkl\u00e4rung: Der neue Wert wird aus dem alten Wert und der Kategorie berechnet.</p> <p>Kategorie in Gro\u00dfbuchstaben umwandeln</p> <pre><code>-- Kategorie in Gro\u00dfbuchstaben umwandeln\nUPDATE artikel\nSET kategorie = UPPER(kategorie);\n</code></pre> <p>Erkl\u00e4rung: Der neue Wert besteht aus dem alten Wert in Gro\u00dfbuchstaben.</p> <p>F\u00fchrende/abschlie\u00dfende Leerzeichen entfernen</p> <pre><code>-- F\u00fchrende/abschlie\u00dfende Leerzeichen entfernen\nUPDATE artikel\nSET artikelname = TRIM(artikelname);\n</code></pre> <p>Erkl\u00e4rung: Der neue Wert besteht aus dem alten Wert ohne f\u00fchrende und abschlie\u00dfende Leerzeichen.</p>"},{"location":"database/manipulieren/#daten-loschen-mit-delete","title":"Daten l\u00f6schen mit <code>DELETE</code>","text":"<p>Nun sind wir am Ende unserer CRUD-Reihe angelangt. Mit Delete lernen wir nun kennen, wie wir Datens\u00e4tze dauerhaft aus einer Tabelle l\u00f6schen k\u00f6nnen. </p> <pre><code>DELETE FROM tabellenname\nWHERE bedingung;\n</code></pre> <p>Wie auch bei <code>UPDATE</code> zuvor ist es extrem wichtig, dass wir <code>DELETE</code> in Kombination mit der <code>WHERE</code>-Klausel verwenden. Ohne diese, werden alle Datens\u00e4tze in der Tabelle gel\u00f6scht. Auch hier gibt es kein Zur\u00fcck.</p> Artikel l\u00f6schen <p>Wir m\u00f6chten nun den Artikel mit der ID 8 l\u00f6schen. Dazu \u00fcberpr\u00fcfen wir zuerst, ob wir wirklich den richtigen Artikel finden.</p> <pre><code>-- Safety Check\nSELECT artikel_id, artikelname, lagerort FROM artikel WHERE artikel_id = 8;\n</code></pre> Output<pre><code> artikel_id |     artikelname     |   lagerort\n------------+---------------------+---------------\n          8 | Sicherungsring 25mm | Lagerplatz A2\n(1 row)\n</code></pre> <p>Wenn wir wirklich den richtigen Artikel finden, k\u00f6nnen wir mit dem <code>DELETE</code> beginnen.</p> <pre><code>-- Artikel mit ID 8 l\u00f6schen (z.B. weil nicht mehr gef\u00fchrt)\nDELETE FROM artikel\nWHERE artikel_id = 8;\n</code></pre> Output<pre><code>DELETE 1\n</code></pre> <p>Erkl\u00e4rung: Die <code>WHERE</code>-Klausel sorgt daf\u00fcr, dass nur der Artikel mit ID 8 gel\u00f6scht wird. Da es sich bei der ID um den Prim\u00e4rschl\u00fcssel handelt, wird nur dieser Datensatz gel\u00f6scht. Dies ist der sicherste Weg, um einen Datensatz zu l\u00f6schen.</p> weitere Beispiele <p>Alle Artikel mit Bestand 0 l\u00f6schen</p> <pre><code>-- Alle Artikel mit Bestand 0 l\u00f6schen (z.B. ausgelaufene Artikel)\nDELETE FROM artikel\nWHERE bestand = 0;\n</code></pre> <p>Erkl\u00e4rung: Alle Datens\u00e4tze, die die WHERE-Bedingung erf\u00fcllen, werden gel\u00f6scht.</p> <p>Artikel in Regal C2 mit Bestand unter Mindestbestand l\u00f6schen</p> <pre><code>-- Artikel in Regal C2 mit Bestand unter Mindestbestand l\u00f6schen\nDELETE FROM artikel\nWHERE lagerort = 'Regal C2' AND bestand &lt; mindestbestand;\n</code></pre> <p>Erkl\u00e4rung: Beide Bedingungen m\u00fcssen erf\u00fcllt sein (<code>AND</code>), damit ein Datensatz gel\u00f6scht wird.</p> DELETE vs. DROP <p>Wichtiger Unterschied zwischen zwei \u00e4hnlich klingenden Befehlen:</p> <ul> <li> <p><code>DELETE FROM tabelle;</code> - L\u00f6scht alle Zeilen, die Tabellenstruktur bleibt bestehen</p> <pre><code>-- DELETE: Tabelle bleibt, aber ist leer\nDELETE FROM artikel;\nSELECT * FROM artikel;  -- Funktioniert, gibt 0 Zeilen zur\u00fcck\n</code></pre> Output<pre><code> artikel_id | artikelname | kategorie | bestand | mindestbestand | preis | lagerort\n------------+-------------+-----------+---------+----------------+-------+----------\n(0 rows)\n</code></pre> </li> <li> <p><code>DROP TABLE tabelle;</code> - L\u00f6scht die gesamte Tabelle inklusive Struktur und allen Daten     </p><pre><code>-- DROP: Tabelle existiert nicht mehr\nDROP TABLE artikel;\nSELECT * FROM artikel;  -- FEHLER: Tabelle existiert nicht\n</code></pre><p></p> Output<pre><code>FEHLER:  Relation \u00bbartikel\u00ab existiert nicht\nLINE 1: SELECT * FROM artikel;\n                    ^\n</code></pre> </li> </ul>"},{"location":"database/manipulieren/#exkurs-alter-tabellen-nachtraglich-andern","title":"Exkurs: <code>ALTER</code> - Tabellen nachtr\u00e4glich \u00e4ndern","text":"<p>Bisher haben wir gelernt, wie man Daten manipuliert (INSERT, UPDATE, DELETE). Doch was passiert, wenn sich die Anforderungen \u00e4ndern und wir die Tabellenstruktur selbst anpassen m\u00fcssen?</p> <p>Stell dir vor:</p> <ul> <li>Du m\u00f6chtest eine neue Spalte hinzuf\u00fcgen (z.B. \"email\" f\u00fcr Kunden)</li> <li>Du musst eine Spalte umbenennen (z.B. \"name\" \u2192 \"kundenname\")</li> <li>Du willst eine Spalte l\u00f6schen (z.B. nicht mehr ben\u00f6tigte Daten)</li> <li>Du musst den Datentyp \u00e4ndern (z.B. VARCHAR(50) \u2192 VARCHAR(100))</li> </ul> <p>F\u00fcr all diese \u00c4nderungen verwenden wir den <code>ALTER TABLE</code> Befehl.</p> Wichtiger Hinweis <p><code>ALTER TABLE</code> \u00e4ndert die Tabellenstruktur dauerhaft! Bei Produktivdatenbanken solltest du vorher Backups anlegen und \u00c4nderungen zun\u00e4chst in einer Testumgebung testen.</p>"},{"location":"database/manipulieren/#spalten-bearbeiten","title":"Spalten bearbeiten","text":"<p>Mit <code>ALTER TABLE</code> k\u00f6nnen wir nachtr\u00e4glich Spalten zu einer bestehenden Tabelle hinzuf\u00fcgen, l\u00f6schen oder umbenennen. Der Syntax ist wie folgt:</p> <pre><code>ALTER TABLE tabellenname\nADD | RENAME | DROP COLUMN spaltenname [datentyp | constraints];\n</code></pre> <p>Die Anweisung startet mit <code>ALTER TABLE</code> und dem Tabellennamen. Es folgt die Aktion (<code>ADD</code>, <code>RENAME</code>, <code>DROP</code>) inklusive <code>COLUMN</code> und der Spaltenname. Bei bedarf k\u00f6nnen auch noch der Datentyp und die Constraints angegeben werden.</p> Neue Spalte hinzuf\u00fcgen <p>Wir m\u00f6chten zu unseren Artikeln eine Email-Adresse des Lieferanten hinzuf\u00fcgen. Da wir die gesamte Tabelle zuvor bereits gel\u00f6scht haben, m\u00fcssen wir diese erneut erstellen (siehe Datenbank-Setup am Anfang des Kapitels).</p> <pre><code>-- Neue Spalte f\u00fcr Lieferanten-Email hinzuf\u00fcgen\nALTER TABLE artikel\nADD COLUMN lieferant_email VARCHAR(100);\n</code></pre> Output<pre><code>ALTER TABLE\n</code></pre> <p>Wir k\u00f6nnen die Tabellenstruktur mit folgendem psql Befehl \u00fcberpr\u00fcfen:</p> <pre><code>\\d artikel\n</code></pre> <p>Die neue Spalte <code>lieferant_email</code> ist jetzt sichtbar. Alle bestehenden Zeilen haben f\u00fcr diese Spalte den Wert <code>NULL</code>.</p> <p>Mit Constraints und DEFAULT:</p> <pre><code>-- Spalte mit DEFAULT-Wert hinzuf\u00fcgen\nALTER TABLE artikel\nADD COLUMN gepruefte_qualitaet BOOLEAN DEFAULT FALSE;\n\n-- Spalte mit NOT NULL und DEFAULT hinzuf\u00fcgen\nALTER TABLE artikel\nADD COLUMN hersteller VARCHAR(100) NOT NULL DEFAULT 'Unbekannt';\n</code></pre> weitere Beispiele Spalte umbenennen <p>Der Name \"artikelname\" ist zu generisch. Wir m\u00f6chten ihn in \"produktbezeichnung\" umbenennen:</p> <pre><code>-- Spaltenname \u00e4ndern\nALTER TABLE artikel\nRENAME COLUMN artikelname TO produktbezeichnung;\n</code></pre> Output<pre><code>ALTER TABLE\n</code></pre> <p>Wichtig: Alle Abfragen, die den alten Spaltennamen verwenden, funktionieren danach nicht mehr!</p> <pre><code>-- Funktioniert nicht mehr:\nSELECT artikelname FROM artikel;  -- \u274c FEHLER\n\n-- Funktioniert:\nSELECT produktbezeichnung FROM artikel;  -- \u2705\n</code></pre> Spalte l\u00f6schen <p>Die Spalte <code>lieferant_email</code> wird doch nicht ben\u00f6tigt:</p> <pre><code>-- Spalte l\u00f6schen\nALTER TABLE artikel\nDROP COLUMN lieferant_email;\n</code></pre> Output<pre><code>ALTER TABLE\n</code></pre> <p>Achtung: Alle Daten in dieser Spalte sind unwiederbringlich verloren!</p> CASCADE vs. RESTRICT <p>Wenn andere Tabellen auf diese Spalte verweisen (z.B. durch Foreign Keys), musst du entscheiden:</p> <pre><code>-- Fehler, wenn Abh\u00e4ngigkeiten bestehen (sicherer!)\nALTER TABLE artikel DROP COLUMN spalte RESTRICT;\n\n-- L\u00f6scht auch abh\u00e4ngige Objekte (gef\u00e4hrlich!)\nALTER TABLE artikel DROP COLUMN spalte CASCADE;\n</code></pre>"},{"location":"database/manipulieren/#datentyp-andern","title":"Datentyp \u00e4ndern","text":"<p>Mit <code>ALTER TABLE ... ALTER COLUMN ... TYPE</code> k\u00f6nnen wir den Datentyp einer Spalte \u00e4ndern.</p> <pre><code>ALTER TABLE tabellenname\nALTER COLUMN spaltenname TYPE neuer_datentyp;\n</code></pre> Datentyp \u00e4ndern <p>Die <code>kategorie</code>-Spalte ist aktuell <code>VARCHAR(50)</code>, aber wir brauchen mehr Platz:</p> <pre><code>-- Datentyp von VARCHAR(50) auf VARCHAR(150) \u00e4ndern\nALTER TABLE artikel\nALTER COLUMN kategorie TYPE VARCHAR(150);\n</code></pre> Output<pre><code>ALTER TABLE\n</code></pre> Datenkonvertierung <p>Wenn bereits Daten in der Spalte vorhanden sind, versucht die Datenbank, diese in den neuen Datentyp zu konvertieren. Dies kann zu Fehlern f\u00fchren, wenn die Daten nicht kompatibel sind (z.B. Text in eine Integer-Spalte umwandeln). Im Erfolgsfall werden die Daten entsprechend dem neuen Typ angepasst. Sei hier besonders vorsichtig und teste solche \u00c4nderungen immer zuerst in einer Testumgebung!</p>"},{"location":"database/manipulieren/#beschrankungen-andern","title":"Beschr\u00e4nkungen \u00e4ndern","text":"<p>Neben dem Datentyp k\u00f6nnen wir auch Beschr\u00e4nkungen welche wir in diesem Kapitel kennengelernt haben (<code>DEFAULT</code>, <code>NOT NULL</code>) \u00e4ndern.</p> <pre><code>-- NOT NULL hinzuf\u00fcgen\nALTER TABLE tabellenname\nALTER COLUMN spaltenname SET NOT NULL;\n\n-- NOT NULL entfernen\nALTER TABLE tabellenname\nALTER COLUMN spaltenname DROP NOT NULL;\n\n-- DEFAULT hinzuf\u00fcgen/\u00e4ndern\nALTER TABLE tabellenname\nALTER COLUMN spaltenname SET DEFAULT wert;\n\n-- DEFAULT entfernen\nALTER TABLE tabellenname\nALTER COLUMN spaltenname DROP DEFAULT;\n</code></pre> <p>Hierbei ist zu beachten, dass wenn wir ein <code>DEFAULT</code> hinzuf\u00fcgen oder \u00e4ndern, dieser nur f\u00fcr neue Zeilen gilt. Bestehende Zeilen werden nicht ge\u00e4ndert. Bei \u00c4nderungen von <code>NOT NULL</code> m\u00fcssen wir zuerst die NULL-Werte beheben. Ansonsten wird ein Fehler beim Hinzuf\u00fcgen der NOT NULL-Einschr\u00e4nkung auftreten.</p> NOT NULL hinzuf\u00fcgen <p>Wir m\u00f6chten sicherstellen, dass jeder Artikel eine Kategorie hat:</p> <pre><code>-- Erst pr\u00fcfen, ob NULL-Werte existieren\nSELECT COUNT(*) FROM artikel WHERE kategorie IS NULL;\n</code></pre> Output<pre><code> count\n-------\n     0\n</code></pre> <p>Wenn keine NULL-Werte vorhanden sind, k\u00f6nnen wir NOT NULL hinzuf\u00fcgen:</p> <pre><code>-- NOT NULL-Einschr\u00e4nkung hinzuf\u00fcgen\nALTER TABLE artikel\nALTER COLUMN kategorie SET NOT NULL;\n</code></pre> weitere Beispiele DEFAULT hinzuf\u00fcgen <pre><code>-- DEFAULT-Wert f\u00fcr mindestbestand setzen\nALTER TABLE artikel\nALTER COLUMN mindestbestand SET DEFAULT 100;\n</code></pre> <p>Wichtig: Der DEFAULT gilt nur f\u00fcr neue Zeilen! Bestehende Zeilen werden nicht ge\u00e4ndert.</p> <pre><code>-- Bestehende Zeilen behalten ihre Werte\nSELECT artikel_id, mindestbestand FROM artikel LIMIT 3;\n</code></pre> Output<pre><code>artikel_id | mindestbestand\n------------+----------------\n        1 |           1000\n        2 |           1000\n        3 |             50\n</code></pre> <pre><code>-- Neue Zeile bekommt DEFAULT-Wert\nINSERT INTO artikel (artikel_id, produktbezeichnung, kategorie, bestand, preis, lagerort)\nVALUES (20, 'Testprodukt', 'Test', 50, 10.00, 'Regal Z1');\n\nSELECT artikel_id, mindestbestand FROM artikel WHERE artikel_id = 20;\n</code></pre> Output<pre><code>artikel_id | mindestbestand\n------------+----------------\n        20 |            100\n</code></pre>"},{"location":"database/manipulieren/#tabelle-umbenennen","title":"Tabelle umbenennen","text":"<p>Mit <code>ALTER TABLE ... RENAME TO</code> k\u00f6nnen wir eine gesamte Tabelle umbenennen.</p> <pre><code>ALTER TABLE alter_tabellenname\nRENAME TO neuer_tabellenname;\n</code></pre> Tabelle umbenennen <pre><code>-- Tabelle \"artikel\" in \"lagerartikel\" umbenennen\nALTER TABLE artikel\nRENAME TO lagerartikel;\n</code></pre> Output<pre><code>ALTER TABLE\n</code></pre> <p>Ab jetzt m\u00fcssen alle Abfragen den neuen Namen verwenden:</p> <pre><code>SELECT * FROM lagerartikel;  \nSELECT * FROM artikel;       --  FEHLER: hei\u00dft jetzt lagerartikel\n</code></pre> Mehrere \u00c4nderungen kombinieren <p>Mehrere ALTER-Befehle k\u00f6nnen nicht in einem Statement kombiniert werden. Jede \u00c4nderung ben\u00f6tigt ein eigenes <code>ALTER TABLE</code>.</p> <pre><code>-- FALSCH: Funktioniert nicht!\nALTER TABLE artikel\n    ADD COLUMN neue_spalte VARCHAR(50),\n    DROP COLUMN alte_spalte;  -- \u274c Syntax-Fehler\n\n-- RICHTIG: Separate Befehle\nALTER TABLE artikel ADD COLUMN neue_spalte VARCHAR(50);\nALTER TABLE artikel DROP COLUMN alte_spalte;\n</code></pre> <p>In nachfolgender Tabelle findest du eine \u00dcbersicht g\u00e4ngiger ALTER-Befehle.</p> Operation Befehl Spalte hinzuf\u00fcgen <code>ALTER TABLE t ADD COLUMN c typ;</code> Spalte l\u00f6schen <code>ALTER TABLE t DROP COLUMN c;</code> Spalte umbenennen <code>ALTER TABLE t RENAME COLUMN alt TO neu;</code> Datentyp \u00e4ndern <code>ALTER TABLE t ALTER COLUMN c TYPE typ;</code> NOT NULL setzen <code>ALTER TABLE t ALTER COLUMN c SET NOT NULL;</code> NOT NULL entfernen <code>ALTER TABLE t ALTER COLUMN c DROP NOT NULL;</code> DEFAULT setzen <code>ALTER TABLE t ALTER COLUMN c SET DEFAULT wert;</code> DEFAULT entfernen <code>ALTER TABLE t ALTER COLUMN c DROP DEFAULT;</code> Tabelle umbenennen <code>ALTER TABLE alt RENAME TO neu;</code>"},{"location":"database/manipulieren/#ubung","title":"\u00dcbung \u270d\ufe0f","text":"<p>Nun \u00fcben wir wieder an unserem bestehenden Projekt. Die TecGuy GmbH m\u00f6chte ihr Produktionsplanungssystem weiter ausbauen und Daten pflegen.</p> <p>Im vorherigen Kapitel haben wir Daten abgefragt und analysiert. Jetzt lernen wir, wie man Daten \u00e4ndert, l\u00f6scht und Tabellenstrukturen anpasst.</p> \u00dcbungsvorbereitung - Datenbank zur\u00fccksetzen <p>Falls du das vorherige Kapitel nicht abgeschlossen hast oder neu starten m\u00f6chtest, f\u00fchre dieses Setup aus. Es l\u00f6scht alle bestehenden Daten und erstellt den korrekten Ausgangszustand f\u00fcr dieses Kapitel.</p> Setup <pre><code>-- Zu anderer Datenbank wechseln\n\\c postgres\n\n-- Zur Datenbank wechseln (oder neu erstellen)\nDROP DATABASE IF EXISTS produktionsplanung_db;\nCREATE DATABASE produktionsplanung_db;\n\\c produktionsplanung_db\n\n-- Tabelle f\u00fcr Maschinen erstellen\nCREATE TABLE maschinen (\n    maschinen_id INTEGER PRIMARY KEY,\n    maschinenname VARCHAR(100),\n    maschinentyp VARCHAR(50),\n    produktionshalle VARCHAR(50),\n    anschaffungsjahr INTEGER,\n    maschinenstatus VARCHAR(20),\n    wartungsintervall_tage INTEGER\n);\n\n-- Tabelle f\u00fcr Produktionsauftr\u00e4ge erstellen\nCREATE TABLE produktionsauftraege (\n    auftrag_id INTEGER PRIMARY KEY,\n    auftragsnummer VARCHAR(20),\n    kunde VARCHAR(100),\n    produkt VARCHAR(100),\n    menge INTEGER,\n    startdatum DATE,\n    lieferdatum DATE,\n    status VARCHAR(20),\n    maschinen_id INTEGER\n);\n\n-- Maschinen-Daten einf\u00fcgen (aus Kapitel 1 &amp; 2)\nINSERT INTO maschinen VALUES\n(1, 'CNC-Fraese Alpha', 'CNC-Fraese', 'Halle A', 2020, 'Aktiv', 90),\n(2, 'Drehbank Delta', 'Drehbank', 'Halle A', 2018, 'Aktiv', 120),\n(3, 'Presse Gamma', 'Presse', 'Halle B', 2019, 'Wartung', 60),\n(4, 'Schweissroboter Beta', 'Schweissroboter', 'Halle C', 2021, 'Aktiv', 90);\n\n-- Produktionsauftr\u00e4ge-Daten einf\u00fcgen (alle 10 aus Kapitel 2)\nINSERT INTO produktionsauftraege VALUES\n(1, 'AUF-2024-001', 'BMW AG', 'Getriebegeh\u00e4use', 500, '2024-04-01', '2024-04-15', 'In Produktion', 1),\n(2, 'AUF-2024-002', 'Audi AG', 'Kurbelwelle', 200, '2024-04-10', '2024-04-20', 'Geplant', 2),\n(3, 'AUF-2024-003', 'Mercedes-Benz', 'Pleuelstange', 350, '2024-04-05', '2024-04-18', 'In Produktion', 2),\n(4, 'AUF-2024-004', 'Porsche AG', 'Kolben', 150, '2024-04-12', '2024-04-25', 'Geplant', 4),\n(5, 'AUF-2024-005', 'BMW AG', 'Kurbelwelle', 300, '2024-04-15', '2024-04-22', 'In Produktion', 2),\n(6, 'AUF-2024-006', 'Volkswagen AG', 'Kolben', 400, '2024-04-20', '2024-04-28', 'Geplant', 4),\n(7, 'AUF-2024-007', 'Mercedes-Benz', 'Getriebegeh\u00e4use', 250, '2024-04-22', '2024-04-30', 'Abgeschlossen', 1),\n(8, 'AUF-2024-008', 'Audi AG', 'Pleuelstange', 180, '2024-04-08', '2024-04-16', 'Abgeschlossen', 2),\n(9, 'AUF-2024-009', 'Porsche AG', 'Kurbelwelle', 120, '2024-04-28', '2024-05-05', 'Geplant', 2),\n(10, 'AUF-2024-010', 'BMW AG', 'Kolben', 350, '2024-04-12', '2024-04-19', 'In Produktion', 4);\n</code></pre> Aufgabe 1: UPDATE - Produktionsauftr\u00e4ge aktualisieren <p>In der TecGuy GmbH haben sich \u00c4nderungen an Produktionsauftr\u00e4gen ergeben:</p> <ol> <li> <p>Auftrag AUF-2024-002 (Audi AG, Kurbelwelle) ist jetzt \"In Produktion\". \u00c4ndere den Status.</p> </li> <li> <p>Auftrag AUF-2024-007 (Mercedes-Benz, Getriebegeh\u00e4use) wurde mit Versp\u00e4tung geliefert. \u00c4ndere das Lieferdatum auf <code>'2024-05-02'</code>.</p> </li> <li> <p>Alle Auftr\u00e4ge mit Status \"Geplant\" sollen den Status \"In Vorbereitung\" bekommen.</p> </li> <li> <p>Der Auftrag AUF-2024-006 (VW, Kolben) wurde auf eine andere Maschine verlegt. \u00c4ndere <code>maschinen_id</code> auf <code>1</code>.</p> </li> </ol> <p>Wichtig: Pr\u00fcfe immer erst mit <code>SELECT</code>, bevor du <code>UPDATE</code> ausf\u00fchrst!</p> Aufgabe 2: UPDATE - Maschinen aktualisieren <p>In der TecGuy GmbH haben sich \u00c4nderungen an Maschinen ergeben:</p> <ol> <li> <p>Presse Gamma (ID 3) ist fertig gewartet. Setze den Status auf <code>'Aktiv'</code>.</p> </li> <li> <p>CNC-Fraese Alpha (ID 1) geht in Wartung. \u00c4ndere den Status auf <code>'Wartung'</code>.</p> </li> <li> <p>Drehbank Delta (ID 2) wird verlegt. \u00c4ndere die Halle auf <code>'Halle D'</code>.</p> </li> <li> <p>Alle Maschinen in Halle C sollen das Wartungsintervall auf <code>120</code> Tage verl\u00e4ngert bekommen.</p> </li> </ol> <p>Wichtig: Pr\u00fcfe immer erst mit <code>SELECT</code>, bevor du <code>UPDATE</code> ausf\u00fchrst!</p> Aufgabe 3: UPDATE mit Berechnungen und String-Operationen <p>Erweiterte UPDATE-Operationen mit Berechnungen und String-Funktionen:</p> <ol> <li> <p>Alle Auftr\u00e4ge mit einer Menge kleiner als 200 sollen um 50 St\u00fcck erh\u00f6ht werden. (Berechnung: <code>menge = menge + 50</code>)</p> </li> <li> <p>Alle Produktionshallen in der <code>maschinen</code> Tabelle sollen umbenannt werden: Ersetze <code>'Halle'</code> durch <code>'Produktionshalle'</code>.</p> </li> <li> <p>Das Wartungsintervall f\u00fcr Maschinen vom Typ <code>'Drehbank'</code> soll um 20 Tage verk\u00fcrzt werden.</p> </li> <li> <p>Alle Auftragsnummern sollen das Pr\u00e4fix <code>'TEC-'</code> bekommen (z.B. <code>'AUF-2024-001'</code> \u2192 <code>'TEC-AUF-2024-001'</code>).</p> </li> </ol> <p>Tipp: Nutze Berechnungen (<code>+</code>, <code>-</code>) und String-Funktionen (<code>REPLACE</code>, <code>CONCAT</code>).</p> Aufgabe 4: DELETE - Datens\u00e4tze l\u00f6schen <p>Die TecGuy GmbH muss Daten bereinigen:</p> <ol> <li> <p>Alle abgeschlossenen Auftr\u00e4ge (<code>status = 'Abgeschlossen'</code>) sollen aus der Datenbank gel\u00f6scht werden.</p> </li> <li> <p>L\u00f6sche die Maschine Presse Gamma (ID 3).</p> </li> <li> <p>L\u00f6sche alle Auftr\u00e4ge mit einer Menge kleiner als 100.</p> </li> </ol> <p>Goldene Regel: Immer erst <code>SELECT</code> mit der gleichen WHERE-Bedingung, dann <code>DELETE</code>!</p>"},{"location":"database/manipulieren/#zusammenfassung","title":"Zusammenfassung \ud83d\udccc","text":"<p>In diesem Kapitel haben wir das CRUD Konzept kennengelernt und dabei folgende Erkenntnisse gewonnen:</p> <ul> <li><code>INSERT</code> f\u00fcgt neue Datens\u00e4tze hinzu - entweder einzeln oder mehrere gleichzeitig</li> <li><code>UPDATE</code> \u00e4ndert bestehende Datens\u00e4tze - IMMER mit WHERE (au\u00dfer du willst wirklich alle \u00e4ndern)</li> <li><code>DELETE</code> l\u00f6scht Datens\u00e4tze dauerhaft - IMMER mit WHERE (au\u00dfer du willst wirklich alle l\u00f6schen)</li> <li><code>DEFAULT</code>-Werte helfen, Standardwerte automatisch zu setzen</li> <li><code>NOT NULL</code> stellt sicher, dass wichtige Felder niemals leer sind</li> <li>Es gibt kein \"R\u00fcckg\u00e4ngig\" bei UPDATE und DELETE - einmal ausgef\u00fchrt, sind die Daten verloren!</li> <li>WHERE-Klausel vergessen = potentielle Katastrophe!</li> </ul> <p>Nun geht es weiter! Im n\u00e4chsten Kapitel lernen wir Datenmodellierung &amp; Beziehungen kennen - wie man Daten in einer Datenbank organisiert und Beziehungen zwischen Tabellen herstellt!</p>"},{"location":"database/modellierung/","title":"Datenmodellierung","text":""},{"location":"database/modellierung/#datenmodellierung-beziehungen","title":"Datenmodellierung &amp; Beziehungen","text":"<p>Nachdem wir nun wissen, wie wir mit einzelnen Tabellen in Datenbanken umgehen (CRUD) ist es nun an der Zeit, einen Schritt weiter zu gehen.  Die wahre St\u00e4rke relationaler Datenbanken liegt n\u00e4mlich darin, Beziehungen zwischen Tabellen zu modellieren!</p> <p>Stellen wir uns vor:</p> <ul> <li>Eine Maschine hat mehrere Wartungen</li> <li>Ein Ersatzteil wird in mehreren Maschinen verwendet</li> <li>Ein Techniker f\u00fchrt viele Wartungen durch</li> </ul> <p>Wie modellieren wir solche Zusammenh\u00e4nge? Genau darum geht es in diesem Kapitel!</p>"},{"location":"database/modellierung/#das-problem","title":"Das Problem","text":"<p>Beginnen wir mit einem Gedankenexperiment: Was passiert, wenn wir versuchen, alle Informationen in einer einzigen Tabelle zu speichern?</p> <p>Versuchen wir, Maschinen und ihre Wartungen in einer einzigen Tabelle zu speichern:</p> Tabelle: maschinen_mit_wartungen<pre><code> maschinen_id |      name        |     typ     | wartungsdatum |   techniker   | kosten\n--------------+------------------+-------------+---------------+---------------+--------\n            1 | CNC-Fr\u00e4se Alpha  | CNC-Fr\u00e4se   | 2024-01-15    | M. Schneider  | 450.00\n            1 | CNC-Fr\u00e4se Alpha  | CNC-Fr\u00e4se   | 2024-06-20    | M. Schneider  | 320.00\n            2 | Drehbank Beta    | Drehbank    | 2024-01-15    | M. Schneider  | 280.00\n            2 | Drehbank Beta    | Drehbank    | 2024-03-10    | L. Weber      | 150.00\n</code></pre> <p>Doch wo liegt hier das Problem? </p> <ol> <li> <p>Redundanz - Daten werden unn\u00f6tig wiederholt</p> <p>Beispiel: Der Name \"CNC-Fr\u00e4se Alpha\" und \"CNC-Fr\u00e4se\" stehen mehrfach in der Tabelle - bei jeder Wartung wird die gesamte Maschineninformation wiederholt!</p> </li> <li> <p>Update-Anomalie - \u00c4nderungen m\u00fcssen mehrfach durchgef\u00fchrt werden</p> <p>\u00c4ndert sich der Maschinenname, m\u00fcssen wir mehrere Zeilen \u00e4ndern. Das ist fehleranf\u00e4llig und langsam.</p> </li> <li> <p>Inkonsistenz - Widerspr\u00fcchliche Daten m\u00f6glich</p> <p>Was, wenn wir den Namen nur in einer Zeile \u00e4ndern? Dann haben wir widerspr\u00fcchliche Daten: </p><pre><code>1 \u2502 CNC-Fr\u00e4se Alpha    \u2502 ...\n1 \u2502 CNC-Fr\u00e4se Alpha V2 \u2502 ...  -- Welcher Name stimmt jetzt?\n</code></pre><p></p> </li> <li> <p>Speicherverschwendung - Unn\u00f6tiger Speicherverbrauch</p> <p>Maschineninformationen wie der Name werden bei jeder Wartung neu gespeichert und ben\u00f6tigen daf\u00fcr Speicherplatz</p> </li> </ol> <p>Doch f\u00fcr unser Problem gibt es eine einfache L\u00f6sung: </p> Quelle: imgflip"},{"location":"database/modellierung/#die-losung","title":"Die L\u00f6sung","text":"<p>Anstelle aller Daten in einer einzelnen Tabelle zu sammeln, k\u00f6nnen wir die Informationen verteilt auf mehrere Tabellen speichern:</p> Tabelle: maschinen<pre><code> maschinen_id | name            | typ       \n--------------+-----------------+-----------\n            1 | CNC-Fr\u00e4se Alpha | CNC-Fr\u00e4se\n            2 | Drehbank Beta   | Drehbank  \n</code></pre> Tabelle: wartungsprotokolle<pre><code> wartungs_id | maschinen_id | wartungsdatum | techniker    | kosten\n-------------+--------------+---------------+--------------+--------\n        101  |      1       | 2024-01-15    | M. Schneider | 450.00\n        102  |      1       | 2024-06-20    | M. Schneider | 320.00\n        103  |      2       | 2024-01-15    | M. Schneider | 280.00\n        104  |      2       | 2024-03-10    | L. Weber     | 150.00\n</code></pre> <p>Alles was wir zuvor als Problem aufgelistet haben k\u00f6nnen wir nun als Vorteil sehen: </p> <ul> <li>Jede Information nur einmal gespeichert</li> <li>\u00c4nderungen nur an einer Stelle n\u00f6tig</li> <li>Keine Inkonsistenzen m\u00f6glich</li> <li>Geringerer Speicherverbrauch</li> </ul> <p>Mit dieser Aufteilung in mehrere Tabellen schaffen wir die Grundlage f\u00fcr eine strukturierte Datenorganisation. Doch wie \"findet\" die Datenbank eigentlich die Zusammenh\u00e4nge zwischen den Tabellen? </p> <p>Diesem Thema wollen wir uns nun widmen. Wir besch\u00e4ftigen uns mit sogenannten Schl\u00fcsseln (Prim\u00e4r- und Fremdschl\u00fcssel) und dem Entity-Relationship-Modell (ERM) die Beziehungen zwischen unseren Daten sauber modellieren. So stellen wir sicher, dass unsere Datenbank nicht nur effizient, sondern auch widerspruchsfrei bleibt!</p>"},{"location":"database/modellierung/#das-entity-relationship-modell-erm","title":"Das Entity-Relationship-Modell (ERM)","text":"<p>Nun k\u00f6nnen wir direkt mit dem erstellen von vielen Tabellen starten, oder? </p> Datenbankstrukturen k\u00f6nnen durchaus komplex werden  (Quelle: INF-Schule) <p>Man neigt h\u00e4ufig dazu, \u00fcberst\u00fcrzt in die Umsetzung zu gehen. Bevor wir aber loslegen, sollten wir einen wichtigen Schritt nicht \u00fcberspringen: die gedankliche Planung der Datenstruktur. Denn eine gute Datenbank entsteht nicht durch Zufall oder einfaches \"Losprogrammieren\", sondern durch sorgf\u00e4ltige \u00dcberlegung, wie die relevanten Informationen in Beziehung zueinander stehen. </p> <p>Zun\u00e4chst analysieren wir also: Welche \"Dinge\" (Objekte, Personen, Vorg\u00e4nge) gibt es in unserem System? Wie h\u00e4ngen sie zusammen? Welche Eigenschaften haben sie?</p> <p>Genau daf\u00fcr gibt es das Entity-Relationship-Modell (ERM), mit dem wir unsere Daten erst auf Papier bzw. am Whiteboard strukturieren, bevor wir sp\u00e4ter die Tabellen in SQL anlegen.</p>"},{"location":"database/modellierung/#die-grundelemente","title":"Die Grundelemente","text":"<p>Zum Modellieren der Beziehungen bzw. zum zeichnen des Entity-Relationship-Diagramms (ER-Diagramm) werden folgende Elemente ben\u00f6tigt:</p> ER-Diagramm <ul> <li> <p>Entit\u00e4t (Entity)</p> <p>Eine konkrete Instanz eines Objekts der realen Welt:</p> <p>Beispiele:</p> <ul> <li>Eine konkrete Maschine: \"CNC-Fr\u00e4se Alpha\"</li> <li>Ein konkretes Ersatzteil: \"Fr\u00e4skopf Standard\"</li> <li>Eine konkrete Wartung: \"Wartung Nr. 101\"</li> </ul> <p>\u279c Das sind die Zeilen in unseren Tabellen</p> </li> <li> <p>Entit\u00e4tstyp (Entity Type)</p> <p>Eine Kategorie gleichartiger Entit\u00e4ten:</p> <p>Beispiele:</p> <ul> <li>Maschinen (alle Maschinen)</li> <li>Ersatzteile (alle Ersatzteile)</li> <li>Wartungsprotokolle (alle Wartungen)</li> </ul> <p>Im ER-Diagramm als Rechteck dargestellt:</p> <pre><code>erDiagram\n    MASCHINEN {\n    }</code></pre> <p>\u279c Das sind unsere Tabellen</p> </li> <li> <p>Attribut</p> <p>Eine Eigenschaft einer Entit\u00e4t:</p> <p>Beispiele f\u00fcr Maschinen:</p> <ul> <li>name: \"CNC-Fr\u00e4se Alpha\"</li> <li>typ: \"CNC-Fr\u00e4se\"</li> <li>standort: \"Halle A\"</li> </ul> <p>Im ER-Diagramm als Attribute in der Entit\u00e4t dargestellt:</p> <pre><code>erDiagram\n    MASCHINEN {\n        int maschinen_id PK\n        string name\n        string typ\n        string standort\n    }</code></pre> <p>\u279c Das sind unsere Spalten</p> </li> <li> <p>Beziehung (Relationship)</p> <p>Eine Verbindung zwischen Entit\u00e4tstypen:</p> <p>Beispiele:</p> <ul> <li>Maschinen haben Wartungen</li> <li>Maschinen ben\u00f6tigen Ersatzteile</li> <li>Techniker f\u00fchren durch Wartungen</li> </ul> <p>Im ER-Diagramm als Verbindungslinie mit Beschriftung dargestellt:</p> <pre><code>erDiagram\n    MASCHINEN ||--o{ WARTUNGSPROTOKOLLE : haben</code></pre> <p>\u279c Das werden unsere Fremdschl\u00fcssel (mehr dazu sp\u00e4ter)</p> </li> </ul> Entit\u00e4t vs. Entit\u00e4tstyp <p>Technisch gesehen ist eine Entit\u00e4t eine konkrete Instanz (eine Zeile) eines Entit\u00e4tstyps (der Tabelle). Da die Modellierung sich aber die abstakte Beziehung zwischen einzelnen Tabellen abbilden soll, wird in der Praxis meist nur von Entit\u00e4t gesprochen, wenngleich man korrekterweise Entit\u00e4tstyp sagen m\u00fcsste. </p> <p>Nun schauen wir uns an, wie wir die Beziehungen zueinander im Detail darstellen k\u00f6nnen. </p>"},{"location":"database/modellierung/#kardinalitaten","title":"Kardinalit\u00e4ten","text":"<p>Kardinalit\u00e4ten beschreiben, wie viele Entit\u00e4ten an einer Beziehung beteiligt sein k\u00f6nnen. Das ist entscheidend f\u00fcr die Datenmodellierung, denn die Kardinalit\u00e4t bestimmt, wie wir die Beziehung in SQL umsetzen! Dabei verwendet man meist eine der drei nachfolgenden Beziehungstypen: </p>"},{"location":"database/modellierung/#1n-eins-zu-viele","title":"1:n (Eins-zu-Viele)","text":"<p>Eine Entit\u00e4t auf der einen Seite steht in Beziehung zu vielen Entit\u00e4ten auf der anderen Seite.</p> 1:n Beziehung <p>Eine Maschine hat viele Wartungen, aber jede Wartung geh\u00f6rt zu einer Maschine.</p> <pre><code>erDiagram\n    direction LR\n    MASCHINEN ||--o{ WARTUNGSPROTOKOLLE : \"haben\"\n    MASCHINEN {\n        int maschinen_id PK\n        string name\n    }\n    WARTUNGSPROTOKOLLE {\n        int wartungs_id PK\n        date wartungsdatum\n        int maschinen_id FK\n    }</code></pre> <p>Weitere Beispiele:</p> <ul> <li>Ein Standort hat viele Maschinen</li> <li>Ein Techniker f\u00fchrt viele Wartungen durch</li> <li>Eine Abteilung hat viele Mitarbeiter</li> </ul> <p>Bei 1:n-Beziehungen kommt der Fremdschl\u00fcssel auf die \"n\"-Seite (die \"viele\"-Seite). Im obigen Beispiel steht <code>maschinen_id</code> als Fremdschl\u00fcssel in der Tabelle <code>WARTUNGSPROTOKOLLE</code>, da eine Maschine viele Wartungen haben kann.</p>"},{"location":"database/modellierung/#nm-viele-zu-viele","title":"n:m (Viele-zu-Viele)","text":"<p>Viele Entit\u00e4ten auf der einen Seite stehen in Beziehung zu vielen Entit\u00e4ten auf der anderen Seite.</p> n:m Beziehung <p>Eine Maschine ben\u00f6tigt viele Ersatzteile, und ein Ersatzteil kann in vielen Maschinen verwendet werden.</p> <pre><code>erDiagram\n    direction LR\n    MASCHINEN }o--o{ ERSATZTEILE : \"ben\u00f6tigen\"\n    MASCHINEN {\n        int maschinen_id PK\n        string name\n    }\n    ERSATZTEILE {\n        int teil_id PK\n        string teilname\n    }</code></pre> <p>Weitere Beispiele:</p> <ul> <li>Studenten belegen viele Kurse, Kurse haben viele Studenten</li> <li>Autoren schreiben viele B\u00fccher, B\u00fccher haben viele Autoren</li> <li>Wartungen verwenden viele Ersatzteile, Ersatzteile werden in vielen Wartungen verwendet</li> </ul> <p>Im ER-Diagramm zeichnen wir die n:m-Beziehung direkt zwischen den beiden Entit\u00e4ten. In SQL k\u00f6nnen wir diese Beziehung aber nicht direkt umsetzen! Wir ben\u00f6tigen eine Zwischentabelle (auch Verbindungstabelle oder Junction Table genannt), die die Beziehung aufl\u00f6st.</p> <p>Die Zwischentabelle enth\u00e4lt zwei Fremdschl\u00fcssel: einen f\u00fcr jede der beiden Tabellen. So wird die n:m-Beziehung in zwei 1:n-Beziehungen aufgeteilt. Mehr dazu lernen wir etwas sp\u00e4ter.</p>"},{"location":"database/modellierung/#11-eins-zu-eins","title":"1:1 (Eins-zu-Eins)","text":"<p>Eine Entit\u00e4t auf der einen Seite steht in Beziehung zu genau einer Entit\u00e4t auf der anderen Seite.</p> 1:1 Beziehung <p>Jede Maschine hat ein Wartungshandbuch-PDF, und jedes Wartungshandbuch-PDF geh\u00f6rt zu einer Maschine.</p> <pre><code>erDiagram\n    direction LR\n    MASCHINEN ||--|| WARTUNGSHANDBUCH_PDF : \"hat\"\n    MASCHINEN {\n        int maschinen_id PK\n        string name\n    }\n    WARTUNGSHANDBUCH_PDF {\n        int handbuch_id PK\n        int maschinen_id FK\n        string dateipfad\n    }</code></pre> <p>Weitere Beispiele:</p> <ul> <li>Eine Person hat einen Personalausweis, ein Personalausweis geh\u00f6rt zu einer Person</li> <li>Ein Mitarbeiter hat einen Schreibtisch, ein Schreibtisch geh\u00f6rt zu einem Mitarbeiter</li> </ul> <p>Bei 1:1-Beziehungen kommt der Fremdschl\u00fcssel auf eine der beiden Seiten. Im obigen Beispiel steht <code>maschinen_id</code> als Fremdschl\u00fcssel in der Tabelle <code>WARTUNGSHANDBUCH_PDF</code>. Alternativ k\u00f6nnte man beide Tabellen auch zusammenf\u00fchren.</p> <p>Generell kommen 1:1-Beziehungen in der Praxis selten vor. Oft kann man die Informationen auch in einer einzigen Tabelle speichern. Doch wann machen 1:1-Beziehungen Sinn?</p> <ul> <li>Gro\u00dfe optionale Daten: z.B. ein Wartungshandbuch-PDF ist sehr gro\u00df und wird selten abgefragt</li> <li>Zugriffsrechte: Sensible Daten (z.B. Geh\u00e4lter) in separater Tabelle mit anderen Zugriffsrechten</li> <li>Historische Gr\u00fcnde: Altsysteme, die nicht ge\u00e4ndert werden k\u00f6nnen</li> </ul>"},{"location":"database/modellierung/#krahenfu-notation","title":"Kr\u00e4henfu\u00df-Notation","text":"<p>Zur Darstellung von ER-Diagrammen gibt es verschiedenste M\u00f6glichkeiten. Eine bekannte Notation ist die sogenannte Kr\u00e4henfu\u00df-Notation (engl. \"Crow's Foot Notation\"). Diese wurde auch bei den bereits gezeigten Beispielen verwendet.</p>      Kr\u00e4henfu\u00df-Notation     (Quelle: edraw)    Kr\u00e4henfu\u00df Notation <p>Die Notation kombiniert zwei Informationen auf jeder Seite der Beziehungslinie:</p> <p>Am \u00e4u\u00dferen Ende (n\u00e4her zur Entit\u00e4t):</p> <ul> <li>Kr\u00e4henfu\u00df <code>{</code> \u2192 Viele (many): Es k\u00f6nnen mehrere Datens\u00e4tze/Zeilen teilnehmen</li> <li>Einfacher Strich <code>|</code> \u2192 Eins (one): Genau ein Datensatz/eine Zeile nimmt teil</li> </ul> <p>Am inneren Ende (n\u00e4her zur Mitte):</p> <ul> <li>Einfacher Strich <code>|</code>\u2192 Verpflichtend (mandatory): Mindestens ein Datensatz muss teilnehmen</li> <li>Kreis <code>o</code>\u2192 Optional (optional): Null Datens\u00e4tze sind erlaubt (optional)</li> </ul> <p>Schauen wir uns ein Beispiel zum besseren Verst\u00e4ndnis an:</p> Kr\u00e4henfu\u00df-Notation <pre><code>MASCHINEN   ||-----o{   WARTUNGSPROTOKOLLE\n            \u2191\u2191     \u2191\u2191\n            \u2502\u2502     \u2502\u2514\u2500\u2500 Kr\u00e4henfu\u00df = viele\n            \u2502\u2502     \u2514\u2500\u2500\u2500 Kreis = optional (null ist erlaubt)\n            \u2502\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 Strich = verpflichtend (mindestens eine)\n            \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 Strich = genau eins\n</code></pre> <p>Bedeutung: Eine Maschine (genau eine, verpflichtend) kann null oder mehrere Wartungsprotokolle haben.</p> <p>In Worten:</p> <ul> <li>Von links nach rechts gelesen: \"Eine Maschine hat null oder viele Wartungsprotokolle\"</li> <li>Von rechts nach links gelesen: \"Jedes Wartungsprotokoll geh\u00f6rt zu genau einer Maschine\"</li> </ul> <p>Weitere Beispiele aus unserem Kapitel:</p> <ul> <li><code>||--||</code> bei \"Maschine hat Wartungshandbuch\": Jede Maschine hat genau ein Wartungshandbuch, und jedes Wartungshandbuch geh\u00f6rt zu genau einer Maschine</li> <li><code>}o--o{</code> bei \"Maschinen ben\u00f6tigen Ersatzteile\": Null oder mehrere Maschinen k\u00f6nnen null oder mehrere Ersatzteile haben (n:m-Beziehung)</li> </ul> <p>Diese Notation mag im ersten Moment etwas gew\u00f6hnungsbed\u00fcrftig sein. Mit etwas \u00dcbung stellt sie aber \u00fcberhaupt kein Problem dar und wir k\u00f6nnen ganz einfach komplexere Strukturen darstellen. </p>"},{"location":"database/modellierung/#fremdschlussel","title":"Fremdschl\u00fcssel","text":"<p>Ein Fremdschl\u00fcssel (Foreign Key, FK) ist eine Spalte, die auf den Prim\u00e4rschl\u00fcssel einer anderen Tabelle verweist. Damit stellen wir Beziehungen zwischen Tabellen her!</p> ER-Diagramm mit Fremdschl\u00fcssel <pre><code>erDiagram\n    direction LR\n    MASCHINEN ||--o{ WARTUNGSPROTOKOLLE : \"hat\"\n    MASCHINEN {\n        int maschinen_id PK\n        string name\n        string typ\n    }\n    WARTUNGSPROTOKOLLE {\n        int wartungs_id PK\n        date wartungsdatum\n        int maschinen_id FK \"verweist auf maschinen\"\n    }</code></pre> <p>Erkl\u00e4rung: Der Fremdschl\u00fcssel <code>maschinen_id</code> in der Tabelle <code>wartungsprotokolle</code> verweist auf den Prim\u00e4rschl\u00fcssel <code>maschinen_id</code> in der Tabelle <code>maschinen</code>.</p> Schl\u00fcsseltyp Beschreibung Beispiel Prim\u00e4rschl\u00fcssel (PK) Identifiziert eindeutig eine Zeile in der eigenen Tabelle <code>maschinen_id</code> in <code>maschinen</code> Fremdschl\u00fcssel (FK) Verweist auf einen Prim\u00e4rschl\u00fcssel in einer anderen Tabelle <code>maschinen_id</code> in <code>wartungsprotokolle</code> <p>Bevor wir mit der Implementierung in SQL beginnen, wollen wir das Erlente schon einmal \u00fcben.</p> Aufgabe: ER-Diagramm modellieren <p>Zeichne auf Papier ein ER-Diagramm f\u00fcr das folgende Szenario. Achte dabei auf:</p> <ul> <li>Korrekte Kardinalit\u00e4ten (1:1, 1:n)</li> <li>Prim\u00e4rschl\u00fcssel (PK) und Fremdschl\u00fcssel (FK)</li> <li>Alle relevanten Attribute</li> <li>Richtige Platzierung der Fremdschl\u00fcssel</li> </ul> <p>Szenario: Standorte, Maschinen und Wartungshandb\u00fccher</p> <p>Eine Produktionsfirma organisiert ihre Maschinen nach Standorten und verwaltet f\u00fcr jede Maschine ein digitales Wartungshandbuch.</p> <p>Anforderungen:</p> <ul> <li>Ein Standort hat viele Maschinen</li> <li>Jede Maschine steht an genau einem Standort</li> <li>Jede Maschine hat genau ein Wartungshandbuch </li> <li>Jedes Wartungshandbuch geh\u00f6rt zu genau einer Maschine</li> </ul> <p>Entit\u00e4ten und Attribute:</p> <ul> <li>Standort: Name, Adresse, Ansprechpartner</li> <li>Maschine: Name, Typ, Anschaffungsdatum</li> <li>Wartungshandbuch: Titel, Dateipfad, Version, Letztes Update</li> </ul> <p>Aufgabe: Zeichne das vollst\u00e4ndige ER-Diagramm mit allen drei Entit\u00e4ten, ihren Attributen, den Beziehungen und den Kardinalit\u00e4ten!</p> L\u00f6sung anzeigen <pre><code>erDiagram\n    STANDORTE ||--o{ MASCHINEN : \"hat\"\n    MASCHINEN ||--|| WARTUNGSHANDBUECHER : \"hat\"\n\n    STANDORTE {\n        int standort_id PK\n        string name\n        string adresse\n        string ansprechpartner\n    }\n\n    MASCHINEN {\n        int maschinen_id PK\n        string name\n        string typ\n        date anschaffungsdatum\n        int standort_id FK \"verweist auf standorte\"\n    }\n\n    WARTUNGSHANDBUECHER {\n        int handbuch_id PK\n        string titel\n        string dateipfad\n        string version\n        date letztes_update\n        int maschinen_id FK \"verweist auf maschinen\"\n    }</code></pre> <p>Erkl\u00e4rung:</p> <p>1:n-Beziehung (Standorte \u2192 Maschinen):</p> <ul> <li>Der Fremdschl\u00fcssel <code>standort_id</code> steht in der Tabelle <code>MASCHINEN</code> (die \"n\"-Seite)</li> <li>Kardinalit\u00e4t: <code>||--o{</code> (ein Standort hat null oder viele Maschinen)</li> <li>Damit kann jede Maschine eindeutig einem Standort zugeordnet werden</li> </ul> <p>1:1-Beziehung (Maschinen \u2192 Wartungshandb\u00fccher):</p> <ul> <li>Der Fremdschl\u00fcssel <code>maschinen_id</code> steht in der Tabelle <code>WARTUNGSHANDBUECHER</code></li> <li>Kardinalit\u00e4t: <code>||--||</code> (eine Maschine hat genau ein Wartungshandbuch)</li> <li>Alternativ k\u00f6nnte man Wartungshandbuch-Daten auch direkt in die Maschinen-Tabelle integrieren, aber die Trennung macht Sinn, da PDFs gro\u00df sein k\u00f6nnen und nicht bei jeder Maschinen-Abfrage mitgeladen werden m\u00fcssen</li> </ul>"},{"location":"database/modellierung/#implementierung-in-sql","title":"Implementierung in SQL","text":"<p>Nachdem wir nun ER-Diagramme zeichnen k\u00f6nnen, ist es nun unsere Aufgabe diese Modelle in echte SQL-Tabellen und damit in eine Datenbank umzusetzen!</p> Datenbank-Setup <p>F\u00fcr die Beispiele in diesem Kapitel verwenden wir eine Wartungs-Datenbank (<code>wartung_db</code>), die typische Wartungen von Maschinen verwaltet. Diese Datenbank hilft uns, die verschiedenen Manipulationsoperationen praxisnah zu \u00fcben.</p> <pre><code>-- Datenbank erstellen\nCREATE DATABASE wartung_db;\n\n-- Zur Datenbank wechseln\n\\c wartung_db\n</code></pre>"},{"location":"database/modellierung/#1n-beziehungen","title":"1:n Beziehungen","text":"<p>Die 1:n-Beziehung ist die h\u00e4ufigste Beziehungsart in relationalen Datenbanken.</p> Goldene Regel f\u00fcr 1:n <p>Der Fremdschl\u00fcssel kommt immer auf die n-Seite (die \"viele\"-Seite)!</p> <p>Wir wollen uns nun die Implementierungen anhand von Beispielen ansehen. Stellen wir uns vor, eine Maschine kann viele Wartungen haben und jede Wartung geh\u00f6rt zu genau einer Maschine (1:n)</p> 1:n Beziehung: Tabellen erstellen <pre><code>erDiagram\n    direction LR\n    MASCHINEN ||--o{ WARTUNGSPROTOKOLLE : \"haben\"\n    MASCHINEN {\n        int maschinen_id PK\n        string name\n    }\n    WARTUNGSPROTOKOLLE {\n        int wartungs_id PK\n        date wartungsdatum\n        int maschinen_id FK\n    }</code></pre> <p>Im ersten Schritt m\u00fcssen wir nun die ben\u00f6tigten Tabellen erstellen. Wichtig ist dabei, dass wir immer zuerst die referenzierte Tabelle (<code>maschinen</code>) erstellen, bevor wir die referenzierende Tabelle (<code>wartungsprotokolle</code>) erstellen.</p> <pre><code>-- Zuerst die \"1\"-Seite (Maschinen)\nCREATE TABLE maschinen (\n    maschinen_id SERIAL PRIMARY KEY, --(1)!\n    name VARCHAR(100) NOT NULL,\n    typ VARCHAR(50) NOT NULL,\n    standort VARCHAR(50)\n);\n\n-- Dann die \"n\"-Seite (Wartungsprotokolle) mit Fremdschl\u00fcssel\nCREATE TABLE wartungsprotokolle (\n    wartungs_id SERIAL PRIMARY KEY,\n    wartungsdatum DATE NOT NULL,\n    beschreibung TEXT,\n    kosten NUMERIC(10, 2),\n    maschinen_id INTEGER NOT NULL,\n    FOREIGN KEY (maschinen_id) REFERENCES maschinen(maschinen_id)\n);\n</code></pre> <ol> <li>Der Datentyp <code>SERIAL</code> ist autoinkrementierend (1,2,3,...)</li> </ol> <p>Wenn wir uns obenstehenden SQL Befehl ansehen, dann erkennen wir zwei neue Dinge</p> <ul> <li><code>FOREIGN KEY (maschinen_id)</code> - Definiert die Spalte als Fremdschl\u00fcssel</li> <li><code>REFERENCES maschinen(maschinen_id)</code> - Verweist auf den Prim\u00e4rschl\u00fcssel der <code>maschinen</code>-Tabelle</li> </ul> <p>Das hei\u00dft, die oben hervorgehobene Code Zeile besagt, dass der Wert in <code>wartungsprotokolle.maschinen_id</code> in der Tabelle <code>maschinen</code> existieren muss.</p> 1:n Beziehung: Daten einf\u00fcgen <p>Nun k\u00f6nnen wir beginnen, Daten in unsere Tabellen zu bef\u00fcllen.</p> <pre><code>-- Erst Maschinen einf\u00fcgen\nINSERT INTO maschinen (name, typ, standort)\nVALUES\n    ('CNC-Fraese Alpha', 'CNC-Fraese', 'Halle A'),\n    ('Drehbank Beta', 'Drehbank', 'Halle A'),\n    ('Schwei\u00dfroboter Gamma', 'Schwei\u00dfroboter', 'Halle B');\n\n-- Dann Wartungsprotokolle mit Verweis auf Maschinen\nINSERT INTO wartungsprotokolle (wartungsdatum, beschreibung, kosten, maschinen_id)\nVALUES\n    ('2024-01-15', 'Routinewartung', 450.00, 1),         --  CNC-Fraese Alpha\n    ('2024-06-20', 'Fraeskopf getauscht', 320.00, 1),    --  CNC-Fraese Alpha\n    ('2024-03-10', 'Oelwechsel', 150.00, 2),             --  Drehbank Beta\n    ('2024-02-05', 'Schwei\u00dfkopf kalibriert', 280.00, 3); --  Schwei\u00dfroboter\n\n\nSELECT * FROM maschinen;\nSELECT * FROM wartungsprotokolle;\n</code></pre> Output<pre><code>maschinen_id | name                 | typ            | standort\n-------------+----------------------+----------------+-----------\n           1 | CNC-Fraese Alpha     | CNC-Fraese     | Halle A\n           2 | Drehbank Beta        | Drehbank       | Halle A\n           3 | Schwei\u00dfroboter Gamma | Schwei\u00dfroboter | Halle B\n\n wartungs_id | wartungsdatum |      beschreibung      | kosten  | maschinen_id \n-------------+---------------+------------------------+---------+--------------\n           1 | 2024-01-15    | Routinewartung         |  450.00 |            1\n           2 | 2024-06-20    | Fraeskopf getauscht    |  320.00 |            1\n           3 | 2024-03-10    | \u00d6elwechsel             |  150.00 |            2\n           4 | 2024-02-05    | Schwei\u00dfkopf kalibriert |  280.00 |            3\n</code></pre> <p>\ud83c\udf89 Gratulation! Wir haben unsere erste 1:n-Beziehung erstellt. </p> Quelle: meme-arsenal"},{"location":"database/modellierung/#nm-beziehungen","title":"n:m Beziehungen","text":"<p>Die Implementierung der 1:n Beziehung in einer Datenbank ist - wie wir gesehen haben - relativ einfach. Die n:m-Beziehungen (Viele-zu-Viele) sind leider etwas komplexer.</p> Problem: n:m nicht direkt umsetzbar <p>Eine n:m-Beziehung l\u00e4sst sich nicht einfach durch einen einzigen Fremdschl\u00fcssel abbilden. Um dieses Problem zu l\u00f6sen, verwendet man eine sogenannte Zwischentabelle \u2013 auch Verbindungstabelle, Junction Table oder Assoziationstabelle genannt \u2013, die die Verkn\u00fcpfung zwischen den beiden Tabellen herstellt.</p> <p>Doch wieso brauchen wir diese Zwischentabelle?</p> <p>Stellen wir uns folgendes Szenario vor: Eine Maschine ben\u00f6tigt viele Ersatzteile, und ein Ersatzteil kann in vielen Maschinen verwendet werden. Dies kann mit einer n:m-Beziehung modelliert werden.</p> Gedankenexperiment <p>Versuch 1: Fremdschl\u00fcssel in <code>maschinen</code>?</p> Tabelle: wartungsprotokolle<pre><code>maschinen_id | name            | ersatzteil_id\n-------------+-----------------+--------------\n          1  | CNC-Fr\u00e4se Alpha | ???  -- Mehrere Ersatzteile?\n</code></pre> <p>\u274c Problem: Eine Maschine braucht mehrere Ersatzteile, aber wir k\u00f6nnen nur einen Fremdschl\u00fcssel speichern!</p> <p>Versuch 2: Fremdschl\u00fcssel in <code>ersatzteile</code>?</p> Tabelle: ersatzteile<pre><code>ersatzteil_id | bezeichnung      | maschinen_id\n--------------+------------------+--------------\n            1 | Spindelmotor     | ???  -- In mehreren Maschinen?\n</code></pre> <p>\u274c Problem: Ein Ersatzteil wird in mehreren Maschinen verwendet, aber wir k\u00f6nnen nur eine Maschine speichern!</p> <p>Wir sehen also, dass wir eine n:m-Beziehung nicht einfach durch einen einzigen Fremdschl\u00fcssel abbilden k\u00f6nnen. Doch wie k\u00f6nnen wir nun in der Praxis vorgehen?</p> <p>Betrachten wir zun\u00e4chst einmal das zugeh\u00f6rige konzeptionelle ER-Diagramm.</p> <pre><code>erDiagram\n    direction LR\n    MASCHINEN }o--o{ ERSATZTEILE : \"ben\u00f6tigen\"</code></pre> n:m wird zu 1:n in SQL <p>F\u00fcr die reale Umsetzung in SQL ben\u00f6tigen wir aber - wie bereits erw\u00e4hnt - eine Zwischentabelle. Der Trick ist dabei, dass wir die n:m-Beziehung in zwei 1:n-Beziehungen aufteilen. Diese Zwischentabelle wird dabei durch zwei Fremdschl\u00fcssel verkn\u00fcpft, die auf die Prim\u00e4rschl\u00fcssel der beiden Entit\u00e4ten verweisen.</p> <pre><code>erDiagram\n    MASCHINEN ||--o{ MASCHINEN_ERSATZTEILE : \"hat\"\n    ERSATZTEILE ||--o{ MASCHINEN_ERSATZTEILE : \"wird_verwendet_in\"\n\n    MASCHINEN {\n        int maschinen_id PK\n        string name\n        string typ\n    }\n\n    ERSATZTEILE {\n        int teil_id PK\n        string teilname\n        string hersteller\n    }\n\n    MASCHINEN_ERSATZTEILE {\n        int zuordnung_id PK\n        int maschinen_id FK\n        int teil_id FK\n        int menge \"Zus\u00e4tzliches Attribut\"\n    }</code></pre> <p>Wir sehen also, dass wir die n:m-Beziehung in zwei 1:n-Beziehungen aufteilen k\u00f6nnen. Nun k\u00f6nnen wir beginnen, die Tabellen zu erstellen. Zuerst erstellen wir die beiden Entit\u00e4ten Tabellen, dann die Zwischentabelle.</p> n:m Beziehung: Tabellen erstellen <pre><code>-- EXISTIERT BEREITS \n-- Tabelle 1: Maschinen (die \"n\"-Seite)\n-- CREATE TABLE maschinen (\n--     maschinen_id SERIAL PRIMARY KEY,\n--    name VARCHAR(100) NOT NULL,\n--    typ VARCHAR(50),\n--    standort VARCHAR(50)\n-- );\n\n-- Tabelle 2: Ersatzteile (die \"m\"-Seite)\nCREATE TABLE ersatzteile (\n    teil_id SERIAL PRIMARY KEY,\n    teilname VARCHAR(100) NOT NULL,\n    hersteller VARCHAR(50),\n    preis NUMERIC(10, 2)\n);\n\n-- Tabelle 3: Zwischentabelle (verbindet beide!)\nCREATE TABLE maschinen_ersatzteile (\n    zuordnung_id SERIAL PRIMARY KEY,\n    maschinen_id INTEGER NOT NULL,\n    teil_id INTEGER NOT NULL,\n    menge INTEGER DEFAULT 1,  -- Zus\u00e4tzliches Attribut der Beziehung!\n    FOREIGN KEY (maschinen_id) REFERENCES maschinen(maschinen_id)\n        ON DELETE CASCADE,\n    FOREIGN KEY (teil_id) REFERENCES ersatzteile(teil_id)\n        ON DELETE CASCADE\n);\n</code></pre> <p>Wichtige Punkte:</p> <ul> <li>Die Zwischentabelle hat zwei Fremdschl\u00fcssel</li> <li>Jede Zeile in der Zwischentabelle repr\u00e4sentiert eine Zuordnung</li> <li>Zus\u00e4tzliche Attribute (wie <code>menge</code>) k\u00f6nnen in der Zwischentabelle gespeichert werden</li> <li>Die <code>ON DELETE CASCADE</code> Option bedeutet, dass wenn eine Maschine oder ein Ersatzteil gel\u00f6scht wird, alle zugeh\u00f6rigen Zuordnungen in der Zwischentabelle automatisch gel\u00f6scht werden. Weitere Informationen dazu gibt es im n\u00e4chsten Abschnitt.</li> </ul> <p>Nun k\u00f6nnen wir beginnen, Daten in unsere Tabellen zu bef\u00fcllen. Zuerst f\u00fcllen wir die beiden Entit\u00e4ten Tabellen, dann die Zwischentabelle.</p> SQL-Code: Daten einf\u00fcgen <pre><code>-- EXISTIERT BEREITS \n-- 1. Erst die Maschinen\n-- INSERT INTO maschinen (name, typ, standort)\n-- VALUES\n--     ('CNC-Fr\u00e4se Alpha', 'CNC-Fr\u00e4se', 'Halle A'),\n--     ('Drehbank Beta', 'Drehbank', 'Halle A'),\n--     ('Schwei\u00dfroboter Gamma', 'Roboter', 'Halle B');\n\n-- 2. Dann die Ersatzteile\nINSERT INTO ersatzteile (teilname, hersteller, preis)\nVALUES\n    ('Spindelmotor', 'MotorTech GmbH', 1250.00),\n    ('Kuehlmittelpumpe', 'PumpCo', 380.50),\n    ('Schwei\u00dfdrahtspule', 'WeldSupply', 45.90);\n\n-- 3. Zuletzt die Zuordnungen\nINSERT INTO maschinen_ersatzteile (maschinen_id, teil_id, menge)\nVALUES\n    (1, 1, 1),  -- CNC-Fraese ben\u00f6tigt 1x Spindelmotor\n    (1, 2, 2),  -- CNC-Fraese ben\u00f6tigt 2x Kuehlmittelpumpe\n    (2, 1, 1),  -- Drehbank ben\u00f6tigt 1x Spindelmotor\n    (2, 2, 1),  -- Drehbank ben\u00f6tigt 1x Kuehlmittelpumpe\n    (3, 2, 1),  -- Schwei\u00dfroboter ben\u00f6tigt 1x Kuehlmittelpumpe\n    (3, 3, 5);  -- Schwei\u00dfroboter ben\u00f6tigt 5x Schwei\u00dfdrahtspule\n</code></pre> <p>Und das war's auch schon. Die Umsetzung einer n:m Beziehung ist leider nicht so einfach wie die der 1:n Beziehung. Aber mit etwas \u00dcberlegung und dem Trick, die n:m Beziehung in zwei 1:n Beziehungen aufzuteilen, k\u00f6nnen wir diese Beziehung in der Datenbank abbilden.</p> <p>Wie wir nun Auswertungen \u00fcber mehrere zusammenh\u00e4ngende Tabellen durchf\u00fchren k\u00f6nnen erfahren wir im n\u00e4chsten Kapitel.</p>"},{"location":"database/modellierung/#referenzielle-integritat","title":"Referenzielle Integrit\u00e4t","text":"<p>Nachdem wir nun m\u00fchevoll versucht haben Beziehungen in der Datenbank zu modellieren m\u00fcssen wir uns nun noch die FRage stellen: Was passiert eigentlich, wenn ich etwas L\u00f6sche, was von etwas anderem abh\u00e4ngt?</p> Maschine l\u00f6schen <p>Versuchen wir beispielsweise, eine Maschine zu l\u00f6schen, die Wartungen hat:</p> <pre><code>-- Versuch, Maschine 1 (CNC-Fr\u00e4se Alpha) zu l\u00f6schen\nDELETE FROM maschinen WHERE maschinen_id = 1;\n</code></pre> <p>\u274c Fehler!</p> Output<pre><code>FEHLER:  Aktualisieren oder L\u00f6schen in Tabelle \u00bbmaschinen\u00ab verletzt Fremdschl\u00fcssel-Constraint \u00bbwartungsprotokolle_maschinen_id_fkey\u00ab von Tabelle \u00bbwartungsprotokolle\u00ab\nDETAIL:  Auf Schl\u00fcssel (maschinen_id)=(1) wird noch aus Tabelle \u00bbwartungsprotokolle\u00ab verwiesen.\n</code></pre> Warum der Fehler? <p>Es gibt Wartungsprotokolle, die auf Maschine 1 verweisen. W\u00fcrden wir die Maschine l\u00f6schen, w\u00fcrden diese Wartungsprotokolle auf eine nicht existierende Maschine zeigen - sie w\u00e4ren \"verwaist\"!</p> <p>Die Datenbank verhindert dies automatisch durch die referenzielle Integrit\u00e4t.</p> <p>Referenzielle Integrit\u00e4t bedeutet also, dass jeder Fremdschl\u00fcssel auf einen existierenden Prim\u00e4rschl\u00fcssel verweisen muss.  Zum Gl\u00fcck stellt das DBMS sicher, dass keine \"verwaisten\" Datens\u00e4tze entstehen und gibt uns eine Fehlermeldung. </p> <p>Doch was ist, wenn wir einen Eintrag wirklich l\u00f6schen m\u00f6chten, obwohl er von etwas anderem abh\u00e4ngt? Dazu gibt es die sogenannten <code>ON DELETE</code> Optionen.</p> <p>Mit <code>ON DELETE</code> legen wir fest, was beim L\u00f6schen der referenzierten Zeile passieren soll:</p> Option Bedeutung Anwendungsfall <code>ON DELETE RESTRICT</code> L\u00f6schen wird verhindert (Standard) Sicherheit: Keine Daten verlieren <code>ON DELETE CASCADE</code> L\u00f6scht automatisch alle abh\u00e4ngigen Datens\u00e4tze Wenn abh\u00e4ngige Daten ohne Hauptdaten sinnlos sind <code>ON DELETE SET NULL</code> Setzt Fremdschl\u00fcssel auf <code>NULL</code> Wenn Beziehung optional ist <code>ON DELETE SET DEFAULT</code> Setzt Fremdschl\u00fcssel auf Standardwert Selten verwendet <p>Schauen wir uns dazu ein Beispiel an. </p> Kaskadierende L\u00f6schung <p>Was passiert, wenn wir nun versuchen ein Ersatzteil zu l\u00f6schen, welches in der Zwischentabelle <code>maschinen_ersatzteile</code> verwendet wird. </p> <pre><code>DELETE FROM ersatzteile WHERE teil_id = 1;\n-- \u2705 Ersatzteil UND alle zugeh\u00f6rigen Zuordnungen in der Zwischentabelle `maschinen_ersatzteile` werden gel\u00f6scht\n</code></pre> <p>Kein Fehler! Doch warum? </p> <p>Weil wir die <code>ON DELETE CASCADE</code> Option bei der Erstellung der Zwischentabelle <code>maschinen_ersatzteile</code> definiert haben.</p> <p>Wann verwenden?</p> <ul> <li>Wenn abh\u00e4ngige Daten ohne Hauptdaten sinnlos sind</li> <li>Beispiel: Wartungen ohne Maschine haben keine Bedeutung</li> </ul> weitere Beispiele <ul> <li> <p>RESTRICT - L\u00f6schen verhindern</p> L\u00f6schen verhindern <pre><code>CREATE TABLE wartungsprotokolle (\n    wartungs_id SERIAL PRIMARY KEY,\n    wartungsdatum DATE,\n    maschinen_id INTEGER,\n    FOREIGN KEY (maschinen_id) REFERENCES maschinen(maschinen_id)\n        ON DELETE RESTRICT  -- Standard, kann auch weggelassen werden\n);\n</code></pre> <p>Verhalten: </p><pre><code>DELETE FROM maschinen WHERE maschinen_id = 1;\n-- \u274c Fehler! Wartungsprotokolle existieren noch\n</code></pre><p></p> <p>Wann verwenden?</p> <ul> <li>Wenn Daten nicht versehentlich gel\u00f6scht werden sollen</li> <li>Wenn man bewusst zuerst abh\u00e4ngige Daten l\u00f6schen m\u00f6chte</li> </ul> </li> <li> <p>SET NULL - Beziehung aufl\u00f6sen</p> Beziehung aufl\u00f6sen <pre><code>CREATE TABLE wartungsprotokolle (\n    wartungs_id SERIAL PRIMARY KEY,\n    wartungsdatum DATE,\n    maschinen_id INTEGER,  -- Muss NULL erlauben!\n    FOREIGN KEY (maschinen_id) REFERENCES maschinen(maschinen_id)\n        ON DELETE SET NULL\n);\n</code></pre> <p>Verhalten: </p><pre><code>DELETE FROM maschinen WHERE maschinen_id = 1;\n-- \u2705 Maschine gel\u00f6scht, Wartungen bleiben mit maschinen_id = NULL\n</code></pre><p></p> <p>Wann verwenden?</p> <ul> <li>Wenn die Beziehung optional ist</li> <li>Beispiel: Mitarbeiter ohne Abteilung (z.B. ausgeschieden, aber Daten bleiben)</li> </ul> NULL muss erlaubt sein! <p>Die Fremdschl\u00fcssel-Spalte darf nicht <code>NOT NULL</code> sein, sonst funktioniert <code>SET NULL</code> nicht!</p> </li> <li> <p>SET DEFAULT - Auf Standardwert setzen</p> Standardwerte setzen <pre><code>CREATE TABLE wartungsprotokolle (\n    wartungs_id SERIAL PRIMARY KEY,\n    wartungsdatum DATE,\n    maschinen_id INTEGER DEFAULT 999,  -- Standard: \"Unbekannt\"\n    FOREIGN KEY (maschinen_id) REFERENCES maschinen(maschinen_id)\n        ON DELETE SET DEFAULT\n);\n</code></pre> <p>Verhalten: </p><pre><code>DELETE FROM maschinen WHERE maschinen_id = 1;\n-- \u2705 maschinen_id wird auf 999 gesetzt (\"Unbekannte Maschine\")\n</code></pre><p></p> <p>Wann verwenden?</p> <ul> <li>Selten verwendet</li> <li>Wenn ein \"Fallback\"-Wert sinnvoll ist</li> </ul> </li> </ul>"},{"location":"database/modellierung/#ubung","title":"\u00dcbung \u270d\ufe0f","text":"<p>Nun wenden wir das Erlernte auf unser TecGuy GmbH Produktionsplanungssystem an! Wir werden die bestehenden Tabellen um Beziehungen erweitern und so ein vollst\u00e4ndiges relationales Datenmodell mit Foreign Keys aufbauen.</p> <p>Im vorherigen Kapitel haben wir Daten manipuliert (UPDATE, DELETE). Jetzt f\u00fcgen wir referentielle Integrit\u00e4t hinzu und erstellen neue Tabellen f\u00fcr Wartungsprotokolle und Ersatzteile.</p> \u00dcbungsvorbereitung - Datenbank zur\u00fccksetzen <p>Da wir im vorherigen Kapitel einige \u00c4nderungen (z.B. L\u00f6schen von Daten) vorgenommen haben welche f\u00fcr die nachfolgenden \u00dcbungen nicht ideal sind. Wollen wir nochmals auf die Ausgangsbasis zur\u00fccksetzen. </p> <p>F\u00fchre dazu das nachfolgende Setup aus. Es l\u00f6scht alle bestehenden Daten und erstellt den korrekten Ausgangszustand f\u00fcr dieses Kapitel.</p> Setup <pre><code>-- Zu anderer Datenbank wechseln\n\\c postgres\n\n-- Zur Datenbank wechseln (oder neu erstellen)\nDROP DATABASE IF EXISTS produktionsplanung_db;\nCREATE DATABASE produktionsplanung_db;\n\\c produktionsplanung_db\n\n-- Tabelle f\u00fcr Maschinen erstellen\nCREATE TABLE maschinen (\n    maschinen_id INTEGER PRIMARY KEY,\n    maschinenname VARCHAR(100),\n    maschinentyp VARCHAR(50),\n    produktionshalle VARCHAR(50),\n    anschaffungsjahr INTEGER,\n    maschinenstatus VARCHAR(20),\n    wartungsintervall_tage INTEGER\n);\n\n-- Tabelle f\u00fcr Produktionsauftr\u00e4ge erstellen (MIT maschinen_id, OHNE FK)\nCREATE TABLE produktionsauftraege (\n    auftrag_id INTEGER PRIMARY KEY,\n    auftragsnummer VARCHAR(20),\n    kunde VARCHAR(100),\n    produkt VARCHAR(100),\n    menge INTEGER,\n    startdatum DATE,\n    lieferdatum DATE,\n    status VARCHAR(20),\n    maschinen_id INTEGER  -- Spalte existiert, aber KEIN FK-Constraint!\n);\n\n-- Maschinen-Daten einf\u00fcgen\nINSERT INTO maschinen VALUES\n(1, 'CNC-Fraese Alpha', 'CNC-Fraese', 'Halle A', 2020, 'Aktiv', 90),\n(2, 'Drehbank Delta', 'Drehbank', 'Halle A', 2018, 'Aktiv', 120),\n(3, 'Presse Gamma', 'Presse', 'Halle B', 2019, 'Aktiv', 60),\n(4, 'Schweissroboter Beta', 'Schweissroboter', 'Halle C', 2021, 'Aktiv', 90);\n\n-- Produktionsauftr\u00e4ge-Daten einf\u00fcgen (mit maschinen_id)\nINSERT INTO produktionsauftraege VALUES\n(1, 'AUF-2024-001', 'BMW AG', 'Getriebegeh\u00e4use', 500, '2024-04-01', '2024-04-15', 'In Produktion', 1),\n(2, 'AUF-2024-002', 'Audi AG', 'Kurbelwelle', 200, '2024-04-10', '2024-04-20', 'In Produktion', 2),\n(3, 'AUF-2024-003', 'Mercedes-Benz', 'Pleuelstange', 350, '2024-04-05', '2024-04-18', 'In Produktion', 2),\n(4, 'AUF-2024-004', 'Porsche AG', 'Kolben', 150, '2024-04-12', '2024-04-25', 'In Vorbereitung', 4),\n(5, 'AUF-2024-005', 'BMW AG', 'Kurbelwelle', 300, '2024-04-15', '2024-04-22', 'In Produktion', 2),\n(6, 'AUF-2024-006', 'Volkswagen AG', 'Kolben', 400, '2024-04-20', '2024-04-28', 'In Vorbereitung', 1),\n(7, 'AUF-2024-009', 'Porsche AG', 'Kurbelwelle', 120, '2024-04-28', '2024-05-05', 'In Vorbereitung', 2),\n(8, 'AUF-2024-010', 'BMW AG', 'Kolben', 350, '2024-04-12', '2024-04-19', 'In Produktion', 4);\n</code></pre> <p>Hinweis: Die Spalte <code>maschinen_id</code> existiert bereits in <code>produktionsauftraege</code>, hat aber noch keinen Foreign Key Constraint. Das werden wir in den \u00dcbungen hinzuf\u00fcgen!</p> Aufgabe 1: ER-Diagramm modellieren <p>Bevor wir mit der Implementierung beginnen, modelliere auf Papier ein ER-Diagramm f\u00fcr folgendes Szenario:</p> <p>Szenario: Produktionsplanung mit Maschinenzuordnung</p> <p>Die TecGuy GmbH m\u00f6chte ihre Produktionsplanung verbessern und Produktionsauftr\u00e4ge direkt Maschinen zuordnen.</p> <p>Anforderungen:</p> <ul> <li>Ein Produktionsauftrag wird von einer Maschine produziert</li> <li>Eine Maschine kann viele Produktionsauftr\u00e4ge bearbeiten</li> <li>Entit\u00e4ten:<ul> <li><code>maschinen</code> (bereits vorhanden)</li> <li><code>produktionsauftraege</code> (bereits vorhanden)</li> </ul> </li> </ul> <p>Aufgabe: Zeichne das ER-Diagramm und bestimme:</p> <ul> <li>Die Kardinalit\u00e4t der Beziehung (1:1, 1:n oder n:m?)</li> <li>Wo der Fremdschl\u00fcssel platziert werden muss</li> <li>Ob <code>ON DELETE CASCADE</code> oder <code>ON DELETE RESTRICT</code> sinnvoll ist</li> </ul> Aufgabe 2: 1:n Beziehung implementieren (Maschinen \u2192 Produktionsauftr\u00e4ge) <p>Implementiere die Foreign Key Beziehung zwischen Maschinen und Produktionsauftr\u00e4gen.</p> <p>Situation: Die Spalte <code>maschinen_id</code> existiert bereits in <code>produktionsauftraege</code> und Auftr\u00e4ge sind bereits Maschinen zugeordnet. Aber es gibt noch keinen Foreign Key Constraint - die Datenbank erzwingt also noch keine referentielle Integrit\u00e4t!</p> <p>Aufgaben:</p> <ol> <li> <p>Erstelle die Fremdschl\u00fcssel-Beziehung mit <code>ON DELETE RESTRICT</code>:     </p><pre><code>ALTER TABLE produktionsauftraege\nADD CONSTRAINT fk_maschinen\nFOREIGN KEY (maschinen_id) REFERENCES maschinen(maschinen_id)\nON DELETE RESTRICT;\n</code></pre><p></p> </li> <li> <p>Teste die referenzielle Integrit\u00e4t:</p> <ul> <li>Versuche, Maschine 1 (CNC-Fraese Alpha) zu l\u00f6schen</li> <li>Was passiert? Warum?</li> </ul> </li> <li> <p>Zeige alle Produktionsauftr\u00e4ge mit ihrer zugeordneten Maschinen-ID an:     </p><pre><code>SELECT auftragsnummer, kunde, produkt, maschinen_id\nFROM produktionsauftraege\nORDER BY maschinen_id;\n</code></pre><p></p> </li> </ol> Aufgabe 3: 1:n Beziehung implementieren (Maschinen \u2192 Wartungsprotokolle) <p>Erstelle eine neue Tabelle <code>wartungsprotokolle</code> mit einer 1:n-Beziehung zu <code>maschinen</code>.</p> <p>Anforderungen:</p> <ul> <li>Eine Maschine hat viele Wartungsprotokolle</li> <li>Jedes Wartungsprotokoll geh\u00f6rt zu einer Maschine</li> <li>Wartungsprotokolle: ID, Wartungsdatum, Beschreibung, Techniker, Kosten, Maschinen-ID</li> <li>Wenn eine Maschine gel\u00f6scht wird, sollen auch alle ihre Wartungsprotokolle gel\u00f6scht werden (<code>ON DELETE CASCADE</code>)</li> </ul> <p>Aufgaben:</p> <ol> <li> <p>Erstelle die Tabelle <code>wartungsprotokolle</code> mit geeigneten Datentypen und Fremdschl\u00fcssel. Folgende Attribute sind zu ber\u00fccksichtigen:</p> <p><code>wartungs_id</code>, <code>wartungsdatum</code>,<code>beschreibung</code>, <code>techniker</code>, <code>kosten</code>, <code>maschinen_id</code></p> </li> <li> <p>F\u00fcge mindestens 4 Wartungsprotokolle f\u00fcr verschiedene Maschinen ein     </p><pre><code>INSERT INTO wartungsprotokolle (wartungsdatum, beschreibung, techniker, kosten, maschinen_id)\nVALUES\n    ('2024-01-15', 'Routinewartung - Oelwechsel', 'M. Schneider', 250.00, 1),\n    ('2024-02-10', 'Reparatur Spindelmotor', 'L. Weber', 850.00, 1),\n    ('2024-01-20', 'Routinewartung - Kalibrierung', 'M. Schneider', 180.00, 2),\n    ('2024-03-05', 'Austausch Keilriemen', 'L. Weber', 120.00, 2);\n</code></pre><p></p> </li> <li> <p>Teste <code>ON DELETE CASCADE</code>: </p> <ul> <li>F\u00fcge zuerst eine Testmaschine und ein Testwartungsprotokoll ein <pre><code>INSERT INTO maschinen (maschinen_id, maschinenname, maschinentyp)\nVALUES (99, 'Test-Maschine', 'Test');\nINSERT INTO wartungsprotokolle (wartungsdatum, beschreibung, techniker, kosten, maschinen_id)\nVALUES ('2024-03-10', 'Test-Wartung', 'Test-Techniker', 100.00, 99);\n</code></pre></li> <li>Pr\u00fcfe, ob das Testwartungsprotokoll und die Testmaschine existiert</li> <li>L\u00f6sche eine Maschine und pr\u00fcfe, ob ihre Wartungsprotokolle ebenfalls gel\u00f6scht wurden</li> </ul> </li> </ol> Aufgabe 4: n:m Beziehung implementieren (Maschinen \u2194 Ersatzteile) <p>Erstelle Tabellen f\u00fcr eine n:m-Beziehung zwischen Maschinen und Ersatzteilen.</p> <p>Anforderungen:</p> <ul> <li>Eine Maschine ben\u00f6tigt viele Ersatzteile</li> <li>Ein Ersatzteil kann in vielen Maschinen verwendet werden</li> <li>Ersatzteile: ID, Teilename, Hersteller, Preis</li> <li>Zwischentabelle: Zus\u00e4tzliches Attribut <code>benoetigte_anzahl</code> (wie viele St\u00fcck dieses Ersatzteil die Maschine ben\u00f6tigt)</li> </ul> <p>Aufgaben:</p> <ol> <li> <p>Erstelle die Tabelle <code>ersatzteile</code> mit den Attributen <code>teil_id</code>, <code>teilename</code>, <code>hersteller</code>, <code>preis</code>.</p> <p>F\u00fcge folgende Ersatzteile ein: </p><pre><code>-- 3. Ersatzteile einf\u00fcgen\nINSERT INTO ersatzteile (teilename, hersteller, preis)\nVALUES\n    ('Spindelmotor 5kW', 'MotorTech GmbH', 1850.00),\n    ('Kuehlmittelpumpe', 'PumpCo AG', 320.50),\n    ('Linearfuehrung 500mm', 'Precision Parts', 680.00),\n    ('Werkzeughalter ISO40', 'ToolSupply GmbH', 145.00),\n    ('Drehfutter 250mm', 'ChuckMaster', 890.00);\n</code></pre><p></p> </li> <li> <p>Erstelle die Zwischentabelle <code>maschinen_ersatzteile</code> mit zwei Fremdschl\u00fcsseln und <code>ON DELETE CASCADE</code></p> <p>Erstelle folgende Zuordnungen in der Zwischentabelle:</p> <pre><code>INSERT INTO maschinen_ersatzteile (maschinen_id, teil_id, benoetigte_anzahl)\nVALUES\n    (1, 1, 1),  -- CNC-Fraese braucht 1x Spindelmotor\n    (1, 2, 2),  -- CNC-Fraese braucht 2x Kuehlmittelpumpe\n    (1, 3, 4),  -- CNC-Fraese braucht 4x Linearfuehrung\n    (1, 4, 6),  -- CNC-Fraese braucht 6x Werkzeughalter\n    (2, 2, 1),  -- Drehbank braucht 1x Kuehlmittelpumpe\n    (2, 5, 1);  -- Drehbank braucht 1x Drehfutter\n</code></pre> </li> </ol> Aufgabe 5: ER-Diagramm des Gesamtsystems zeichnen <p>Zeichne auf Papier das vollst\u00e4ndige ER-Diagramm des TecGuy GmbH Produktionsplanungssystems mit allen Tabellen und Beziehungen:</p> <p>Tabellen:</p> <ul> <li><code>maschinen</code></li> <li><code>produktionsauftraege</code></li> <li><code>wartungsprotokolle</code></li> <li><code>ersatzteile</code></li> <li><code>maschinen_ersatzteile</code></li> </ul> <p>Aufgabe: Zeichne das vollst\u00e4ndige ER-Diagramm mit:</p> <ul> <li>Allen Entit\u00e4ten und ihren wichtigsten Attributen</li> <li>Allen Beziehungen mit korrekten Kardinalit\u00e4ten</li> <li>Allen Fremdschl\u00fcsseln (FK)</li> </ul>"},{"location":"database/modellierung/#zusammenfassung","title":"Zusammenfassung \ud83d\udccc","text":"<p>In diesem Kapitel haben wir gelernt, wie man Beziehungen zwischen Tabellen modelliert und in SQL umsetzt. Das wichtigste wird hier nochmals kurz zusammengefasst.</p> <p>Datenmodellierung:</p> <ul> <li>ER-Modell beschreibt Entit\u00e4ten, Attribute und Beziehungen visuell</li> <li>Kardinalit\u00e4ten (1:1, 1:n, n:m) definieren, wie viele Datens\u00e4tze miteinander in Beziehung stehen</li> <li>Kr\u00e4henfu\u00df-Notation visualisiert Kardinalit\u00e4ten und Optionalit\u00e4t</li> <li>Fremdschl\u00fcssel (FK) stellen Beziehungen zwischen Tabellen her</li> <li>Referenzielle Integrit\u00e4t verhindert verwaiste Datens\u00e4tze</li> <li>ON DELETE Optionen legen fest, was passiert, wenn eine Zeile gel\u00f6scht wird</li> </ul> <p>Umsetzung in SQL</p> Beziehungstyp Umsetzung Beispiel 1:n Fremdschl\u00fcssel auf der \"n\"-Seite Eine Maschine hat viele Wartungen n:m Zwischentabelle mit zwei Fremdschl\u00fcsseln Maschinen ben\u00f6tigen viele Ersatzteile 1:1 Fremdschl\u00fcssel auf einer Seite (selten) Eine Maschine hat ein Wartungshandbuch Goldene Regel <p>Modelliere erst mit ER-Diagrammen, dann implementiere in SQL!</p> <ol> <li>Analysiere die Anforderungen</li> <li>Zeichne das ER-Diagramm (auf Papier/Whiteboard)</li> <li>Bestimme Kardinalit\u00e4ten und Fremdschl\u00fcssel</li> <li>Implementiere die Tabellen in SQL</li> </ol> <p>Im n\u00e4chsten Kapitel lernen wir JOINs kennen \u2013 wie man Daten aus mehreren verkn\u00fcpften Tabellen abfragt!</p> Quelle: Pinata Farms"},{"location":"database/relational/","title":"Relationale Datenbanken","text":""},{"location":"database/relational/#grundlagen-des-relationalen-modells","title":"Grundlagen des Relationalen Modells","text":"<p>Nachdem wir im vorherigen Kapitel Datenbanken als L\u00f6sung f\u00fcr strukturierte Datenhaltung kennengelernt und PostgreSQL installiert haben, wird es jetzt konkret: Wie werden Daten in einer relationalen Datenbank organisiert?</p> <p>Die Antwort: In Tabellen!</p>"},{"location":"database/relational/#das-relationale-modell","title":"Das relationale Modell","text":"<p>Eine relationale Datenbank organisiert Daten in Tabellen (auch Relationen genannt). Jede Tabelle besitzt einen Namen (Relationennamen) und besteht aus:</p> Relationale Datenbank <p>Eine Relationale Datenbank wird wiefolgt beschrieben:</p> <ul> <li>Tupel (auch Zeilen oder Datens\u00e4tze genannt) - repr\u00e4sentieren einzelne Objekte oder Eintr\u00e4ge</li> <li>Attribute (auch Spalten oder Felder genannt) - beschreiben Eigenschaften dieser Objekte</li> <li>Relationenschema - Menge von Attributen</li> <li>Relationenname - Name der Tabelle</li> </ul>"},{"location":"database/relational/#datentypen-in-postgresql","title":"Datentypen in PostgreSQL","text":"<p>Jede Spalte einer Tabelle hat einen Datentyp, der festlegt, welche Art von Daten gespeichert werden kann. PostgreSQL bietet eine Vielzahl von Datentypen (siehe Dokumentation) - wir konzentrieren uns zun\u00e4chst auf die wichtigsten:</p>"},{"location":"database/relational/#textdaten","title":"Textdaten","text":"Datentyp Beschreibung Beispiel <code>VARCHAR(n)</code> Zeichenkette mit max. <code>n</code> Zeichen <code>'Hydraulikzylinder'</code> <code>TEXT</code> Zeichenkette unbegrenzter L\u00e4nge <code>'Ein langer Text...'</code> <code>CHAR(n)</code> Zeichenkette mit fixer L\u00e4nge <code>n</code> <code>'DE'</code> (L\u00e4nderk\u00fcrzel)"},{"location":"database/relational/#zahlen","title":"Zahlen","text":"Datentyp Beschreibung Beispiel <code>INTEGER</code> Ganze Zahl (-2.147.483.648 bis 2.147.483.647) <code>42</code>, <code>-17</code> <code>SMALLINT</code> Kleine ganze Zahl (-32.768 bis 32.767) <code>5</code> <code>BIGINT</code> Gro\u00dfe ganze Zahl (-9.223.372.036.854.775.808 bis 9.223.372.036.854.775.807) <code>9876543210</code> <code>NUMERIC(p,d)</code> Festkommazahl (<code>p</code> Gesamtstellen, <code>d</code> Nachkommastellen) <code>123.45</code> <code>REAL</code> Gleitkommazahl (einfache Genauigkeit) <code>3.14159</code> Signed / Unsigned <p>Generell unterschiedet man bei ganzzahligen Datentypen zwischen signed (vorzeichenbehaftet) und unsigned (vorzeichenlos):</p> <p>Signed (vorzeichenbehaftet):</p> <ul> <li>Kann positive und negative Zahlen speichern</li> <li>Beispiel <code>INTEGER</code>: -2.147.483.648 bis +2.147.483.647</li> <li>Das erste Bit (Vorzeichenbit) bestimmt, ob die Zahl positiv oder negativ ist</li> </ul> <p>Unsigned (vorzeichenlos):</p> <ul> <li>Kann nur positive Zahlen speichern (inkl. 0)</li> <li>W\u00fcrde bei <code>INTEGER</code> theoretisch 0 bis 4.294.967.295 erm\u00f6glichen</li> </ul> <p>Wichtig: PostgreSQL unterst\u00fctzt standardm\u00e4\u00dfig keine unsigned-Typen!</p>"},{"location":"database/relational/#datum-zeit","title":"Datum &amp; Zeit","text":"Datentyp Beschreibung Beispiel <code>DATE</code> Datum (ohne Uhrzeit) <code>'2024-03-15'</code> <code>TIME</code> Uhrzeit (ohne Datum) <code>'14:30:00'</code> <code>TIMESTAMP</code> Datum und Uhrzeit <code>'2024-03-15 14:30:00'</code>"},{"location":"database/relational/#sonstige","title":"Sonstige","text":"Datentyp Beschreibung Beispiel <code>BOOLEAN</code> Wahrheitswert (wahr/falsch) <code>TRUE</code>, <code>FALSE</code> <code>SERIAL</code> Auto-inkrementierende Ganzzahl <code>1, 2, 3, ...</code>"},{"location":"database/relational/#der-primarschlussel","title":"Der Prim\u00e4rschl\u00fcssel","text":"<p>Stellen wir uns vor, ein Maschinenbau-Zulieferer hat zwei Produkte mit der Bezeichnung \"Hydraulikzylinder Standard\". Beide kosten 450 Euro und geh\u00f6ren zur Kategorie \"Hydraulik\". Wie k\u00f6nnen wir diese beiden Produkte in unserer Datenbank eindeutig voneinander unterscheiden? Was passiert, wenn wir eine Bestellung f\u00fcr das erste Produkt erfassen wollen - wie wei\u00df die Datenbank, welches der beiden gemeint ist?</p> <p>Genau hier kommt der Prim\u00e4rschl\u00fcssel (engl. Primary Key) ins Spiel!</p> <p>Ein Prim\u00e4rschl\u00fcssel ist eine Spalte (oder eine Kombination mehrerer Spalten), die jeden Datensatz in einer Tabelle eindeutig identifiziert. Er funktioniert wie eine Artikelnummer oder Seriennummer: Jedes Produkt, jeder Auftrag, jede Bestellung erh\u00e4lt einen einzigartigen Wert, \u00fcber den es jederzeit zweifelsfrei identifiziert werden kann.</p> <p>In unserem Beispiel w\u00fcrden wir den beiden Hydraulikzylindern unterschiedliche Produkt-IDs zuweisen - etwa <code>produkt_id = 101</code> f\u00fcr das erste und <code>produkt_id = 105</code> f\u00fcr das zweite Produkt. Selbst wenn beide dieselbe Bezeichnung, Kategorie und denselben Preis haben, sind sie durch ihre ID eindeutig unterscheidbar.</p> Prim\u00e4rschl\u00fcssel (Primary Key) <p>Ein Prim\u00e4rschl\u00fcssel ist ein Attribut (oder eine Kombination von Attributen), das jeden Datensatz in einer Tabelle eindeutig identifiziert.</p> <p>Eigenschaften eines Prim\u00e4rschl\u00fcssels:</p> <ul> <li>Eindeutig - Kein Wert darf in der Tabelle doppelt vorkommen</li> <li>Nicht NULL - Jeder Datensatz muss einen Wert haben (leere Eintr\u00e4ge sind nicht erlaubt)</li> <li>Unver\u00e4nderlich - Sollte sich idealerweise nie \u00e4ndern, um Konsistenz zu gew\u00e4hrleisten</li> </ul> <p>Beispiele aus der Praxis:</p> <ul> <li>Produkt-ID f\u00fcr Artikel (z.B. <code>101</code>, <code>102</code>, ...)</li> <li>Auftragsnummer f\u00fcr Bestellungen (z.B. <code>AUF-2024-00123</code>)</li> <li>Artikelnummer f\u00fcr Lagerteile (z.B. <code>HYD-001</code>, <code>PNE-042</code>)</li> <li>Kunden-ID f\u00fcr Gesch\u00e4ftspartner (z.B. <code>K1042</code>)</li> </ul>"},{"location":"database/relational/#warum-sind-primarschlussel-wichtig","title":"Warum sind Prim\u00e4rschl\u00fcssel wichtig?","text":"<p>Ohne Prim\u00e4rschl\u00fcssel w\u00fcrde es in der Datenbank schnell zu Chaos kommen. Ohne eindeutige Identifikation w\u00e4re eine verl\u00e4ssliche Datenverwaltung unm\u00f6glich. Der Prim\u00e4rschl\u00fcssel sorgt daf\u00fcr, dass:</p> <ul> <li>Datens\u00e4tze eindeutig identifiziert werden k\u00f6nnen</li> <li>Verkn\u00fcpfungen zwischen Tabellen funktionieren (mehr dazu sp\u00e4ter bei Fremdschl\u00fcsseln)</li> <li>Keine Duplikate entstehen k\u00f6nnen</li> <li>Daten konsistent bleiben, selbst wenn andere Werte ge\u00e4ndert werden</li> </ul> <p>In der Praxis verwendet man h\u00e4ufig eine fortlaufende Nummer (1, 2, 3, ...) als Prim\u00e4rschl\u00fcssel, da diese automatisch eindeutig ist und sich nie \u00e4ndert - selbst wenn die Produktbezeichnung oder der Preis sp\u00e4ter angepasst wird.</p> Quelle: Imgflip"},{"location":"database/relational/#erstellen-einer-tabelle","title":"Erstellen einer Tabelle","text":"<p>Nun wollen wir in die Praxis einsteigen und unsere erste Tabelle erstellen. In diesem Kapitel verwenden wir als Beispiel einen Produktkatalog eines Maschinenbau-Zulieferers.</p>"},{"location":"database/relational/#datenbankgrundlage-erstellen","title":"Datenbankgrundlage erstellen","text":"<p>Bevor wir starten, erstellen wir eine neue Datenbank f\u00fcr unser Beispiel. Dazu verbinden wir uns zuerst zu einer bereits bestehenden Datenbank unseres Servers. Daf\u00fcr sollten wir bereits die Datenbanken <code>produktions_db</code> (aus dem vorigen Kapitel) und <code>postgres</code> (standardm\u00e4\u00dfig vorhanden) haben:</p> Verbindung zur Datenbank <p>Option 1: pgAdmin</p> <p>Wechsle zu pgAdmin in das PSQL Tool Workspace und w\u00e4hle die Datenbank <code>produktions_db</code> oder <code>postgres</code> aus.</p> <p></p> <p></p> <p>Option 2: Terminal / Kommandozeile</p> <p>Alternativ kannst du \u00fcber das Terminal (macOS) oder die Kommandozeile (Windows) die Verbindung herstellen:</p> <pre><code>psql -h localhost -p 5432 -U postgres -d produktions_db\n</code></pre> <p>Anschlie\u00dfend erstellen wir eine neue Datenbank f\u00fcr unser Beispiel in diesem Kapitel: </p> Zulieferer Datenbank erstellen <pre><code>-- Datenbank erstellen\nCREATE DATABASE zulieferer_db;\n\n-- Mit der Datenbank verbinden\n\\c zulieferer_db\n</code></pre> Output<pre><code>You are now connected to database \"zulieferer_db\" as user \"postgres\"\n</code></pre> <p>Der Befehl <code>\\c</code> ist ein psql-Befehl, der uns zur angegebenen Datenbank wechselt.</p>"},{"location":"database/relational/#erstellen-create-table","title":"Erstellen (CREATE TABLE)","text":"<p>Beim Erstellen der Tabelle verwenden wir den Befehl <code>CREATE TABLE</code>. Nach dem Befehl folgt der Name der Tabelle und anschlie\u00dfend die Attribute der Tabelle in Klammern. Jedes Attribut hat einen Namen und einen Datentyp und wird durch ein Komma getrennt. </p> <pre><code>CREATE TABLE tabellenname (\n    attribut1 typ,\n    attribut2 typ,\n    ...\n);\n</code></pre> Produktkatalog <pre><code>CREATE TABLE produkte ( --(1)!\n    produkt_id INTEGER PRIMARY KEY, --(2)!\n    produktname VARCHAR(100), --(3)!\n    kategorie VARCHAR(50), --(4)!\n    preis NUMERIC(10,2), --(5)!\n    lagerbestand INTEGER, --(6)!\n    lieferant VARCHAR(100) --(7)!\n);\n</code></pre> <ol> <li>Erstelle eine Tabelle mit dem Namen \"produkte\"</li> <li>Spalte f\u00fcr die Produkt-ID (Prim\u00e4rschl\u00fcssel = eindeutig!)</li> <li>Produktname (max. 100 Zeichen)</li> <li>Produktkategorie (z.B. \"Hydraulik\", \"Pneumatik\", max 50 Zeichen)</li> <li>Preis (10 Gesamtstellen, 2 Nachkommastellen)</li> <li>Aktueller Lagerbestand (ganze Zahl)</li> <li>Name des Lieferanten (max 100 Zeichen)</li> </ol> Output<pre><code>CREATE TABLE\n</code></pre> <p>Den Prim\u00e4rschl\u00fcssel haben wir dabei mit Hilfe des Befehls <code>PRIMARY KEY</code> auf das Attribut <code>produkt_id</code> gesetzt.</p> <p>Wenn der Befehl erfolgreich ausgef\u00fchrt wurde, sollte die Tabelle in der Datenbank angezeigt werden (Default Workspace &gt; ... &gt; zulieferer_db &gt; Schemas &gt; public &gt; Tables).</p>"},{"location":"database/relational/#daten-einfugen-insert","title":"Daten einf\u00fcgen (INSERT)","text":"<p>Eine leere Tabelle ist meist nicht das Ziel. Daher m\u00fcssen wir uns nun ansehen, wie wir Daten (Zeilen / Tupel) in unsere nun bestehende Tabelle einf\u00fcgen k\u00f6nnen. Dazu gibt es in SQL den <code>INSERT</code> Befehl.</p> <pre><code>INSERT INTO tabellenname (attribut1, attribut2, ...)\nVALUES (wert1, wert2, ...);\n</code></pre> Produkte einf\u00fcgen <pre><code>INSERT INTO produkte (\n    produkt_id, produktname, kategorie, preis, lagerbestand, lieferant\n)\nVALUES\n(101, 'Hydraulikzylinder Standard', 'Hydraulik', 450.00, 25, 'Bosch Rexroth'),\n(102, 'Pneumatikventil 5/2-Wege', 'Pneumatik', 89.50, 50, 'Festo AG'),\n(103, 'Kugelgewindetriebe KGT40', 'Mechanik', 780.00, 12, 'THK GmbH'),\n(104, 'Servomotor 3kW', 'Antriebstechnik', 1250.00, 8, 'Siemens AG'),\n(105, 'N\u00e4herungsschalter induktiv', 'Sensorik', 35.90, 100, 'Sick AG');\n</code></pre> Output<pre><code>INSERT 0 5\n</code></pre> Datentyp beachten <ul> <li>Textwerte m\u00fcssen in einfachen Anf\u00fchrungszeichen stehen: <code>'Text'</code></li> <li>Zahlen stehen ohne Anf\u00fchrungszeichen: <code>42</code> oder <code>123.45</code></li> </ul>"},{"location":"database/relational/#daten-abfragen-select","title":"Daten abfragen (SELECT)","text":"<p>Nachdem wir nun eine bef\u00fcllte Tabelle vor uns haben, ist die n\u00e4chste Aufgabe klar: wir wollen die Daten aus der Datenbank auslesen/abrufen. Dazu verwenden wir den <code>SELECT</code> Befehl:</p> <pre><code>SELECT * FROM tabellenname;\n</code></pre> Alle Produkte anzeigen <pre><code>SELECT * FROM produkte;\n</code></pre> Output<pre><code> produkt_id |         produktname          |    kategorie     |  preis  | lagerbestand |   lieferant\n------------+------------------------------+------------------+---------+--------------+----------------\n        101 | Hydraulikzylinder Standard   | Hydraulik        | 450.00  |           25 | Bosch Rexroth\n        102 | Pneumatikventil 5/2-Wege     | Pneumatik        |  89.50  |           50 | Festo AG\n        103 | Kugelgewindetriebe KGT40     | Mechanik         | 780.00  |           12 | THK GmbH\n        104 | Servomotor 3kW               | Antriebstechnik  | 1250.00 |            8 | Siemens AG\n        105 | N\u00e4herungsschalter induktiv   | Sensorik         |  35.90  |          100 | Sick AG\n(5 rows)\n</code></pre> Der * Operator <p>Das <code>*</code> (Sternchen) ist ein Platzhalter f\u00fcr \"alle Spalten\". Es ist praktisch f\u00fcr schnelle Abfragen, aber in der Praxis sollte man die ben\u00f6tigten Spalten explizit angeben, da sonst unn\u00f6tig Daten \u00fcbertragen werden m\u00fcssen.</p> <pre><code>SELECT attribut1, attribut2 FROM tabellenname;\n</code></pre> Bestimmte Spalten anzeigen <pre><code>SELECT produktname, kategorie, preis FROM produkte;\n</code></pre> Output<pre><code>        produktname          |    kategorie     | preis\n-----------------------------+------------------+--------\nHydraulikzylinder Standard   | Hydraulik        | 450.00\nPneumatikventil 5/2-Wege     | Pneumatik        |  89.50\nKugelgewindetriebe KGT40     | Mechanik         | 780.00\nServomotor 3kW               | Antriebstechnik  | 1250.00\nN\u00e4herungsschalter induktiv   | Sensorik         |  35.90\n(5 rows)\n</code></pre>"},{"location":"database/relational/#ubung","title":"\u00dcbung \u270d\ufe0f","text":"<p>Jetzt geht es darum, das Erlernte in einem praxisnahen Projekt anzuwenden. In diesem und den folgenden Kapiteln baust du Schritt f\u00fcr Schritt ein Produktionsplanungssystem f\u00fcr einen mittelst\u00e4ndischen Fertigungsbetrieb auf.</p> <p>Die TecGuy GmbH ist ein mittelst\u00e4ndisches Fertigungsunternehmen, das Pr\u00e4zisionsteile f\u00fcr die Automobilindustrie herstellt. Das Unternehmen m\u00f6chte ein digitales System zur Verwaltung seiner Produktionsauftr\u00e4ge und Produktionsmaschinen aufbauen.</p> <p>In diesem Kapitel startest du mit den ersten beiden Tabellen: Produktionsauftr\u00e4ge und Maschinen.</p> \u00dcbungsvorbereitung - Datenbank zur\u00fccksetzen <p>Falls du neu startest oder die \u00dcbung wiederholen m\u00f6chtest, f\u00fchre dieses Setup aus. Es l\u00f6scht alle bestehenden Daten und erstellt den korrekten Ausgangszustand f\u00fcr dieses Kapitel.</p> <pre><code>-- Zu anderer Datenbank wechseln\n\\c postgres\n\n-- Datenbank l\u00f6schen falls vorhanden\nDROP DATABASE IF EXISTS produktionsplanung_db;\n</code></pre> <p>Hinweis: Ab jetzt kannst du direkt mit Aufgabe 1 starten.</p> Aufgabe 1: Datenbank und Tabellen erstellen <p>Schritt 1: Erstelle eine neue Datenbank f\u00fcr das Projekt:</p> <pre><code>CREATE DATABASE produktionsplanung_db;\n\\c produktionsplanung_db\n</code></pre> <p>Schritt 2: Erstelle eine Tabelle <code>produktionsauftraege</code> mit folgenden Spalten:</p> <ul> <li><code>auftrag_id</code> (INTEGER, Prim\u00e4rschl\u00fcssel)</li> <li><code>auftragsnummer</code> (VARCHAR(20))</li> <li><code>kunde</code> (VARCHAR(100))</li> <li><code>produkt</code> (VARCHAR(100))</li> <li><code>menge</code> (INTEGER)</li> <li><code>startdatum</code> (DATE)</li> <li><code>lieferdatum</code> (DATE)</li> <li><code>status</code> (VARCHAR(20))</li> <li><code>maschinen_id</code> (INTEGER)</li> </ul> <p>Schritt 3: Erstelle eine Tabelle <code>maschinen</code> mit folgenden Spalten:</p> <ul> <li><code>maschinen_id</code> (INTEGER, Prim\u00e4rschl\u00fcssel)</li> <li><code>maschinenname</code> (VARCHAR(100))</li> <li><code>maschinentyp</code> (VARCHAR(50))</li> <li><code>produktionshalle</code> (VARCHAR(50))</li> <li><code>anschaffungsjahr</code> (INTEGER)</li> <li><code>maschinenstatus</code> (VARCHAR(20))</li> <li><code>wartungsintervall_tage</code> (INTEGER)</li> </ul> Aufgabe 2: Daten einf\u00fcgen <p>Teil A: F\u00fcge folgende Maschinen in die Tabelle <code>maschinen</code> ein:</p> <p></p> maschinen_id maschinenname maschinentyp produktionshalle anschaffungsjahr maschinenstatus wartungsintervall_tage 1 CNC-Fraese Alpha CNC-Fraese Halle A 2020 Aktiv 90 2 Drehbank Delta Drehbank Halle A 2018 Aktiv 120 3 Presse Gamma Presse Halle B 2019 Wartung 60 4 Schweissroboter Beta Schweissroboter Halle C 2021 Aktiv 90 <p></p> <p>Teil B: F\u00fcge folgende Produktionsauftr\u00e4ge in die Tabelle <code>produktionsauftraege</code> ein:</p> <p></p> auftrag_id auftragsnummer kunde produkt menge startdatum lieferdatum status maschinen_id 1 AUF-2024-001 BMW AG Getriebegeh\u00e4use 500 2024-04-01 2024-04-15 In Produktion 1 2 AUF-2024-002 Audi AG Kurbelwelle 200 2024-04-10 2024-04-20 Geplant 2 3 AUF-2024-003 Mercedes-Benz Pleuelstange 350 2024-04-05 2024-04-18 In Produktion 2 4 AUF-2024-004 Porsche AG Kolben 150 2024-04-12 2024-04-25 Geplant 4 <p></p> Aufgabe 3: Daten abfragen <p>F\u00fchre folgende Abfragen durch:</p> <ol> <li>Zeige alle Produktionsauftr\u00e4ge an.</li> <li>Zeige nur Auftragsnummer, Kunde und Produkt der Auftr\u00e4ge an.</li> <li>Zeige alle Maschinen an.</li> <li>Zeige nur Maschinenname und Maschinentyp der Maschinen an.</li> </ol> <p>In den folgenden Kapiteln werden wir:</p> <ul> <li>Beziehungen zwischen Tabellen erstellen (Foreign Keys)</li> <li>Weitere Tabellen hinzuf\u00fcgen (Wartungsprotokolle, Ersatzteile, Lager)</li> <li>Komplexe Abfragen durchf\u00fchren (Joins, Aggregationen, Subqueries)</li> <li>Datenintegrit\u00e4t sicherstellen (Constraints, CHECK, UNIQUE)</li> <li>Transaktionen f\u00fcr sichere Operationen nutzen</li> <li>Daten manipulieren (UPDATE, DELETE, ALTER TABLE)</li> </ul> <p>Am Ende haben wir ein vollst\u00e4ndiges, funktionsf\u00e4higes Produktionsplanungssystem!</p>"},{"location":"database/relational/#zusammenfassung","title":"Zusammenfassung \ud83d\udccc","text":"<ul> <li>Das relationale Modell organisiert Daten in Tabellen mit Zeilen und Spalten</li> <li>Jede Spalte hat einen Datentyp (VARCHAR, INTEGER, NUMERIC, DATE, ...)</li> <li>Ein Prim\u00e4rschl\u00fcssel identifiziert jeden Datensatz eindeutig und darf nicht NULL sein</li> <li><code>CREATE TABLE</code> erstellt eine neue Tabelle mit definierter Struktur</li> <li><code>INSERT INTO</code> f\u00fcgt neue Datens\u00e4tze in eine Tabelle ein</li> <li><code>SELECT</code> fragt Daten aus einer Tabelle ab</li> <li><code>SELECT *</code> zeigt alle Spalten, w\u00e4hrend <code>SELECT attribut1, attribut2</code> nur bestimmte Spalten zeigt</li> </ul> <p>Im n\u00e4chsten Kapitel lernen wir, wie wir Daten gezielt filtern, sortieren und aggregieren k\u00f6nnen - die wahre Macht von SQL!</p>"},{"location":"database/transaktionen/","title":"Transaktionen","text":""},{"location":"database/transaktionen/#transaktionen-acid","title":"Transaktionen &amp; ACID","text":"<p>In den vorherigen Kapiteln haben wir gelernt, wie wir Daten in PostgreSQL strukturieren, abfragen und manipulieren k\u00f6nnen. Dabei haben wir immer angenommen, dass unsere Operationen erfolgreich ausgef\u00fchrt werden und die Datenbank in einem konsistenten Zustand bleibt.</p> <p>Doch was passiert, wenn:</p> <ul> <li>Ein Fehler w\u00e4hrend einer Reihe von \u00c4nderungen auftritt?</li> <li>Mehrere Benutzer gleichzeitig auf dieselben Daten zugreifen?</li> <li>Das System abst\u00fcrzt, w\u00e4hrend eine Operation l\u00e4uft?</li> </ul> <p>In solchen Situationen reicht es nicht aus, einfach SQL-Befehle auszuf\u00fchren. Wir ben\u00f6tigen einen Mechanismus, der sicherstellt, dass unsere Daten konsistent und zuverl\u00e4ssig bleiben. Dieser Mechanismus hei\u00dft Transaktion.</p> Quelle: imgflip <p>In diesem Kapitel lernen wir, was Transaktionen sind, warum sie wichtig sind und wie wir sie in PostgreSQL verwenden. Au\u00dferdem schauen wir uns die ACID-Prinzipien an, die das Fundament f\u00fcr verl\u00e4ssliche Datenbanksysteme bilden.</p> Datenbank-Setup <p>F\u00fcr die folgenden Beispiele erstellen wir eine Banking-Datenbank. In dieser Datenbank werden Bankkonten und Geldtransfers verwaltet.</p> <pre><code>-- Datenbank erstellen\nCREATE DATABASE banking_db;\n\n-- Zur Datenbank wechseln\n\\c banking_db\n\n-- Tabelle: Konten\nCREATE TABLE konten (\n    konto_id SERIAL PRIMARY KEY,\n    kontoinhaber VARCHAR(100) NOT NULL,\n    kontonummer VARCHAR(22) UNIQUE NOT NULL,\n    saldo NUMERIC(12, 2) NOT NULL CHECK (saldo &gt;= 0),\n    kontotyp VARCHAR(20) DEFAULT 'Girokonto'\n);\n\n-- Tabelle: Transaktionslog\nCREATE TABLE transaktionslog (\n    transaktion_id SERIAL PRIMARY KEY,\n    von_konto_id INTEGER REFERENCES konten(konto_id),\n    zu_konto_id INTEGER REFERENCES konten(konto_id),\n    betrag NUMERIC(12, 2) NOT NULL CHECK (betrag &gt; 0),\n    transaktionsdatum TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\n    beschreibung TEXT,\n    status VARCHAR(20) DEFAULT 'abgeschlossen'\n);\n\n-- Testdaten: Konten\nINSERT INTO konten (kontoinhaber, kontonummer, saldo, kontotyp) VALUES\n('Max Mustermann', 'DE89370400440532013000', 5000.00, 'Girokonto'),\n('Anna Schmidt', 'DE89370400440532013001', 3000.00, 'Girokonto'),\n('Thomas Weber', 'DE89370400440532013002', 10000.00, 'Sparkonto'),\n('Lisa Miller', 'DE89370400440532013003', 1500.00, 'Girokonto'),\n('Peter Klein', 'DE89370400440532013004', 8000.00, 'Sparkonto');\n</code></pre>"},{"location":"database/transaktionen/#was-ist-eine-transaktion","title":"Was ist eine Transaktion?","text":"<p>Eine Transaktion ist eine logische Einheit von Datenbankoperationen, die entweder vollst\u00e4ndig ausgef\u00fchrt oder vollst\u00e4ndig r\u00fcckg\u00e4ngig gemacht wird.</p> <p>Man kann sich eine Transaktion wie eine All-or-Nothing-Operation vorstellen:</p> <ul> <li>\u2705 Entweder werden alle \u00c4nderungen erfolgreich durchgef\u00fchrt</li> <li>\u274c Oder keine der \u00c4nderungen wird \u00fcbernommen</li> </ul> <pre><code>flowchart LR\n    A[Transaktion starten]:::peach --&gt; B{Alle Operationen erfolgreich?}:::teal\n    B --&gt;|Ja| C[COMMIT: \u00c4nderungen speichern]:::peach\n    B --&gt;|Nein| D[ROLLBACK: \u00c4nderungen verwerfen]:::peach\n    C --&gt; E[Konsistenter Zustand]:::teal\n    D --&gt; E\n\n    classDef peach fill:#FFB482aa,stroke:#333,stroke-width:1px;\n    classDef teal fill:#009485aa,stroke:#333,stroke-width:1px;</code></pre>"},{"location":"database/transaktionen/#warum-brauchen-wir-transaktionen","title":"Warum brauchen wir Transaktionen?","text":"<p>Ohne Transaktionen k\u00f6nnen inkonsistente Zust\u00e4nde entstehen, die zu schwerwiegenden Problemen f\u00fchren.</p> Geldtransfer ohne Transaktion <p>Stell dir vor, wir \u00fcberweisen 500\u20ac vom Konto von Max Mustermann an Anna Schmidt:</p> <pre><code>-- Schritt 1: Geld vom Sender-Konto abbuchen\nUPDATE konten\nSET saldo = saldo - 500\nWHERE kontoinhaber = 'Max Mustermann';\n\n-- Schritt 2: Geld auf Empf\u00e4nger-Konto gutschreiben\nUPDATE konten\nSET saldo = saldo + 500\nWHERE kontoinhaber = 'Anna Schmidt';\n</code></pre> <p>\u274c Problem: Was passiert, wenn zwischen diesen beiden Schritten ein Fehler auftritt?</p> <ul> <li>Das Geld w\u00e4re vom Sender-Konto abgebucht</li> <li>Aber nicht auf dem Empf\u00e4nger-Konto angekommen</li> <li>500\u20ac w\u00e4ren einfach verschwunden! \ud83d\udcb8</li> </ul> <p>Mit einer Transaktion stellen wir sicher, dass entweder beide Operationen erfolgreich sind, oder keine von beiden.</p>"},{"location":"database/transaktionen/#transaktionen-in-postgresql","title":"Transaktionen in PostgreSQL","text":"<p>In PostgreSQL verwenden wir drei Hauptbefehle f\u00fcr Transaktionen:</p> Befehl Bedeutung Verwendung <code>BEGIN</code> Startet eine neue Transaktion Am Anfang einer Transaktionsfolge <code>COMMIT</code> Speichert alle \u00c4nderungen dauerhaft Nach erfolgreicher Ausf\u00fchrung aller Operationen <code>ROLLBACK</code> Verwirft alle \u00c4nderungen seit BEGIN Bei Fehlern oder bewusstem Abbruch <p>Der Allgemeine Aufbau einer Transaktion ist wie folgt:</p> <pre><code>BEGIN;\n\n-- SQL-Befehle\nUPDATE ...\nINSERT ...\nDELETE ...\nSELECT ...\n\nCOMMIT;  -- oder ROLLBACK;\n</code></pre> <p>Der <code>BEGIN</code> Befehl startet zun\u00e4chst eine neue Transaktion. Alle nachfolgenden SQL-Befehle werden in dieser Transaktion ausgef\u00fchrt. Sollte eine Transaktion fehlschlagen, hat man anschlie\u00dfend die M\u00f6glichkeit die Transaktion mit <code>ROLLBACK</code> r\u00fcckg\u00e4ngig zu machen. Sollte die Transaktion erfolgreich ausgef\u00fchrt werden, kann man die Transaktion mit <code>COMMIT</code> abschlie\u00dfen.</p> <p>Betrachten wir zum besseren Verst\u00e4ndnis wieder ein praktisches Beispiel.</p> Transaktion mit <code>COMMIT</code> abschlie\u00dfen <p>\u00dcberpr\u00fcfen wir zun\u00e4chst die aktuellen Kontost\u00e4nde:</p> <pre><code>SELECT kontoinhaber, kontonummer, saldo\nFROM konten\nWHERE kontoinhaber IN ('Max Mustermann', 'Anna Schmidt');\n</code></pre> Output<pre><code>  kontoinhaber  |      kontonummer       |  saldo\n----------------+------------------------+---------\n Max Mustermann | DE89370400440532013000 | 4500.00\n Anna Schmidt   | DE89370400440532013001 | 3500.00\n(2 rows)\n</code></pre> <p>Jetzt f\u00fchren wir die \u00dcberweisung mit einer Transaktion durch:</p> <pre><code>BEGIN;\n\n-- Schritt 1: Geld vom Sender-Konto abbuchen\nUPDATE konten\nSET saldo = saldo - 500\nWHERE kontoinhaber = 'Max Mustermann';\n\n-- Schritt 2: Geld auf Empf\u00e4nger-Konto gutschreiben\nUPDATE konten\nSET saldo = saldo + 500\nWHERE kontoinhaber = 'Anna Schmidt';\n</code></pre> <p>\u00dcberpr\u00fcfen wir das Ergebnis (noch innerhalb der Transaktion):</p> <pre><code>SELECT kontoinhaber, saldo\nFROM konten\nWHERE kontoinhaber IN ('Max Mustermann', 'Anna Schmidt');\n</code></pre> Output<pre><code>  kontoinhaber  |  saldo\n----------------+---------\n Max Mustermann | 4000.00\n Anna Schmidt   | 4000.00\n(2 rows)\n</code></pre> <p>Sollte alles wie gew\u00fcnscht funktioniert haben, k\u00f6nnen wir die Transaktion abschlie\u00dfen:</p> <pre><code>COMMIT;\n</code></pre> <p>\u2705 Beide \u00c4nderungen wurden erfolgreich durchgef\u00fchrt! Die Gesamtsumme (8000\u20ac) bleibt gleich.</p> Best Practice: Transaktionen verwenden <p>Verwende Transaktionen immer dann, wenn:</p> <ul> <li>Mehrere zusammenh\u00e4ngende Operationen durchgef\u00fchrt werden</li> <li>Daten zwischen Tabellen verschoben werden</li> <li>Kritische Gesch\u00e4ftslogik umgesetzt wird</li> <li>Datenintegrit\u00e4t oberste Priorit\u00e4t hat</li> </ul> <p>Was passiert aber, wenn wir einen Fehler bemerken oder die Transaktion abbrechen m\u00f6chten?</p> Transaktion mit <code>ROLLBACK</code> abbrechen <p>Arbeiten wir am vorherigen Beispiel weiter und versuchen einen Transfer, den wir dann abbrechen:</p> <pre><code>BEGIN;\n\n-- Versuch einer \u00dcberweisung\nUPDATE konten\nSET saldo = saldo - 1000\nWHERE kontoinhaber = 'Max Mustermann';\n\n-- Ups, falscher Betrag! Abbrechen:\nROLLBACK;\n</code></pre> <p>\u00dcberpr\u00fcfen wir nun wieder den Kontostand:</p> <pre><code>SELECT kontoinhaber, saldo\nFROM konten\nWHERE kontoinhaber = 'Max Mustermann';\n</code></pre> Output<pre><code>  kontoinhaber  |  saldo\n----------------+---------\n Max Mustermann | 4000.00\n(1 row)\n</code></pre> <p>Die \u00c4nderung wurde NICHT gespeichert! Der Kontostand ist immer noch bei 4000\u20ac.</p> <p>Mit <code>ROLLBACK</code> werden also alle \u00c4nderungen seit BEGIN verworfen, als h\u00e4tten sie nie stattgefunden.</p> Quelle: dev.to"},{"location":"database/transaktionen/#automatisches-rollback-bei-fehlern","title":"Automatisches Rollback bei Fehlern","text":"<p>PostgreSQL f\u00fchrt automatisch ein ROLLBACK durch, wenn w\u00e4hrend einer Transaktion ein Fehler auftritt.</p> Automatisches Rollback bei Constraint-Verletzung <p>Wir versuchen, mehr Geld abzuheben, als auf dem Konto vorhanden ist:</p> <pre><code>BEGIN;\n\nUPDATE konten\nSET saldo = saldo - 200\nWHERE kontoinhaber = 'Max Mustermann';\n\n-- Dieser Befehl verletzt die CHECK-Constraint (Saldo darf nicht negativ sein)\nUPDATE konten\nSET saldo = saldo - 5000\nWHERE kontoinhaber = 'Max Mustermann';  -- Fehler! Saldo w\u00fcrde negativ werden (-700)\n</code></pre> Output<pre><code>FEHLER:  neue Zeile f\u00fcr Relation \u00bbkonten\u00ab verletzt Check-Constraint \u00bbkonten_saldo_check\u00ab\nDETAIL:  Fehlgeschlagene Zeile enth\u00e4lt (1, Max Mustermann, DE89370400440532013000, -1200.00, Girokonto)\n</code></pre> <p>Wenn wir nun in weiterer Folge einen Befehl eingeben - egal welchen - wird uns das System folgendes zur\u00fcckmelden:</p> <pre><code>SELECT * FROM konten;\n</code></pre> Output<pre><code>FEHLER:  aktuelle Transaktion wurde abgebrochen, Befehle werden bis zum Ende der Transaktion ignoriert\n</code></pre> <p>Was nun passiert ist, dass egal ob wir <code>COMMIT</code> oder <code>ROLLBACK</code> ausf\u00fchren, PostgreSQL automatisch einen <code>ROLLBACK</code> durchf\u00fchren wird. Dabei werden alle \u00c4nderungen r\u00fcckg\u00e4ngig gemacht! Wir testen dies, indem wir ein <code>COMMIT</code> ausf\u00fchren und anschlie\u00dfend nochmals die Daten \u00fcberpr\u00fcfen.</p> <pre><code>COMMIT;\n\nSELECT kontoinhaber, saldo\nFROM konten\nWHERE kontoinhaber = 'Max Mustermann';\n</code></pre> Output<pre><code>  kontoinhaber  |  saldo\n----------------+---------\n Max Mustermann | 4000.00\n(1 row)\n</code></pre> <p>\u2705 Das Konto hat seinen urspr\u00fcnglichen Kontostand behalten!</p> Verwendet PostgreSQL automatisch Transaktionen? <p>Ja! Jeder einzelne SQL-Befehl wird implizit in einer eigenen Transaktion ausgef\u00fchrt. Wenn du nur einen <code>UPDATE</code>-Befehl ausf\u00fchrst, wird automatisch ein <code>BEGIN</code> davor und ein <code>COMMIT</code> danach gesetzt.</p> <p>Explizite Transaktionen mit <code>BEGIN</code> und <code>COMMIT</code> brauchst du nur, wenn du mehrere Befehle zu einer logischen Einheit zusammenfassen m\u00f6chtest.</p>"},{"location":"database/transaktionen/#acid-prinzipien","title":"ACID-Prinzipien","text":"<p>Transaktionen folgen den sogenannten ACID-Prinzipien. ACID ist ein Akronym f\u00fcr vier Eigenschaften, die jede zuverl\u00e4ssige Datenbank-Transaktion erf\u00fcllen muss:</p> Prinzip Bedeutung Beispiel Atomicity Alles oder nichts Entweder beide Updates oder keines Consistency Datenbank bleibt konsistent Gesamtbestand bleibt gleich Isolation Transaktionen laufen unabh\u00e4ngig Andere User sehen \u00c4nderungen erst nach COMMIT Durability \u00c4nderungen bleiben dauerhaft Auch nach Systemabsturz erhalten <p>Schauen wir uns die einzelnen Prinzipien genauer an:</p> <ul> <li> <p>A - Atomicity</p> <p>Entweder werden alle Operationen ausgef\u00fchrt, oder keine einzige Operation wird \u00fcbernommen. Es gibt kein \"teilweise erfolgreich\"</p> </li> <li> <p>C - Consistency</p> <p>Alle Integrit\u00e4tsbedingungen (Constraints) m\u00fcssen erf\u00fcllt sein. Dies bedeutet, dass vor und nach der Transaktion die Datenbank in einem g\u00fcltigen Zustand ist</p> </li> <li> <p>I - Isolation</p> <p>Jede Transaktion l\u00e4uft isoliert, als w\u00e4re sie die einzige. \u00c4nderungen einer Transaktion sind f\u00fcr andere erst nach COMMIT sichtbar</p> </li> <li> <p>D - Durability</p> <p>Nach einem COMMIT sind die \u00c4nderungen permanent gespeichert. Auch bei Systemabst\u00fcrzen oder Stromausf\u00e4llen gehen die Daten nicht verloren</p> </li> </ul> Zwei Transaktionen gleichzeitig <p>Wenn man die ACID Regeln betrachtet, mag dem ein oder anderen die Frage aufkommen: Was passiert wenn es zwei Transaktionen gleichzeitig gibt? Speziell das Isolationsprinzip w\u00fcrde ja bedeuten, dass gleichzeitig auf den gleichen Daten etwas ge\u00e4ndert werden kann. Hier verwendet PostgreSQL standardm\u00e4\u00dfig ein sogenannntes Row-Level Locking. Dies bedeutet, dass wenn in einer Transaktion eine \u00c4nderung an einer Zeile vorgenommen wird, diese f\u00fcr \u00c4nderungen in einer anderen Transaktion gesperrt wird. Das bedeutet, dass PostgreSQL nie zwei <code>UPDATE</code> Befehle gleichzeitig auf die selbe Zeile zul\u00e4sst. </p>"},{"location":"database/transaktionen/#savepoint-teilweiser-rollback","title":"<code>SAVEPOINT</code>: Teilweiser Rollback","text":"<p>Ein <code>SAVEPOINT</code> ist ein Zwischenspeicherpunkt innerhalb einer Transaktion. Du kannst zu einem <code>SAVEPOINT</code> zur\u00fcckrollen, ohne die gesamte Transaktion abzubrechen.</p> <code>SAVEPOINT</code> verwenden <p>Betrachten wir nochmals kurz den aktuellen Kontostand von Thomas, Max und Anna: </p> <pre><code>SELECT kontoinhaber, saldo FROM konten\nWHERE kontoinhaber IN ('Max Mustermann', 'Anna Schmidt', 'Thomas Weber');\n</code></pre> Output<pre><code>  kontoinhaber  |  saldo\n----------------+----------\n Thomas Weber   | 10000.00\n Max Mustermann |  4000.00\n Anna Schmidt   |  4000.00\n(3 rows)\n</code></pre> <p>Stellen wir uns vor, wir f\u00fchren mehrere \u00dcberweisungen durch, m\u00f6chten aber nur eine davon r\u00fcckg\u00e4ngig machen:</p> <pre><code>BEGIN;\n\n-- Erste \u00dcberweisung: 200\u20ac von Max an Anna\nUPDATE konten SET saldo = saldo - 200 WHERE kontoinhaber = 'Max Mustermann';\nUPDATE konten SET saldo = saldo + 200 WHERE kontoinhaber = 'Anna Schmidt';\n\nSAVEPOINT nach_erster_ueberweisung;\n\n-- Zweite \u00dcberweisung: 300\u20ac von Max an Thomas\nUPDATE konten SET saldo = saldo - 300 WHERE kontoinhaber = 'Max Mustermann';\nUPDATE konten SET saldo = saldo + 300 WHERE kontoinhaber = 'Thomas Weber';\n\n-- Ups, die zweite \u00dcberweisung war falsch! Nur diese r\u00fcckg\u00e4ngig machen:\nROLLBACK TO SAVEPOINT nach_erster_ueberweisung;\n\n-- Die erste \u00dcberweisung bleibt erhalten, die zweite wurde r\u00fcckg\u00e4ngig gemacht\nCOMMIT;\n</code></pre> <p>Beim oben gezeigten Beispiel wird die erste \u00dcberweisung (200\u20ac an Anna) durchgef\u00fchrt, die zweite \u00dcberweisung (300\u20ac an Thomas) aber verworfen. Lassen wir uns nochmals den aktuellen Kontostand anzeigen, erhalten wir: </p> Output<pre><code>  kontoinhaber  |  saldo\n----------------+----------\n Thomas Weber   | 10000.00\n Max Mustermann |  3800.00\n Anna Schmidt   |  4200.00\n(3 rows)\n</code></pre>"},{"location":"database/transaktionen/#ubung","title":"\u00dcbung \u270d\ufe0f","text":"<p>Nun wenden wir Transaktionen auf unser TecGuy GmbH Produktionsplanungssystem an! Die \u00dcbungen decken verschiedene Transaktionsszenarien ab und helfen dir, ACID-Prinzipien in der Praxis anzuwenden.</p> \u00dcbungsvorbereitung \u2013 Datenbank zur\u00fccksetzen <p>F\u00fcr die nachfolgenden \u00dcbungen wollen wir nochmals auf die Ausgangsbasis zur\u00fcckgehen und zus\u00e4tzlich noch eine neue Lager Tabelle hinzuf\u00fcgen. F\u00fchre dazu das nachfolgende Setup aus.</p> Setup <pre><code>-- Zu anderer Datenbank wechseln\n\\c postgres\n\n-- Datenbank l\u00f6schen und neu erstellen\nDROP DATABASE IF EXISTS produktionsplanung_db;\nCREATE DATABASE produktionsplanung_db;\n\n-- Zur Datenbank wechseln\n\\c produktionsplanung_db\n\n-- Tabelle: Maschinen\nCREATE TABLE maschinen (\n    maschinen_id INTEGER PRIMARY KEY,\n    maschinenname VARCHAR(100) NOT NULL,\n    maschinentyp VARCHAR(50),\n    maschinencode VARCHAR(20),\n    produktionshalle VARCHAR(50),\n    anschaffungsjahr INTEGER,\n    maschinenstatus VARCHAR(20),\n    wartungsintervall_tage INTEGER\n);\n\n-- Tabelle: Produktionsauftr\u00e4ge\nCREATE TABLE produktionsauftraege (\n    auftrag_id INTEGER PRIMARY KEY,\n    auftragsnummer VARCHAR(20),\n    kunde VARCHAR(100),\n    produkt VARCHAR(100),\n    menge INTEGER,\n    startdatum DATE,\n    lieferdatum DATE,\n    enddatum DATE,\n    status VARCHAR(20),\n    maschinen_id INTEGER,\n    FOREIGN KEY (maschinen_id) REFERENCES maschinen(maschinen_id)\n        ON DELETE RESTRICT\n);\n\n-- Tabelle: Wartungsprotokolle (1:n Beziehung zu Maschinen)\nCREATE TABLE wartungsprotokolle (\n    wartungs_id SERIAL PRIMARY KEY,\n    wartungsdatum DATE NOT NULL,\n    beschreibung TEXT,\n    techniker VARCHAR(100),\n    kosten NUMERIC(10, 2),\n    maschinen_id INTEGER NOT NULL,\n    FOREIGN KEY (maschinen_id) REFERENCES maschinen(maschinen_id)\n        ON DELETE CASCADE\n);\n\n-- Tabelle: Ersatzteile\nCREATE TABLE ersatzteile (\n    ersatzteil_id INTEGER PRIMARY KEY,\n    teilenummer VARCHAR(20) NOT NULL UNIQUE,\n    bezeichnung VARCHAR(100) NOT NULL,\n    lagerbestand INTEGER DEFAULT 0,\n    mindestbestand INTEGER DEFAULT 10\n);\n\n-- Tabelle: Maschinen-Ersatzteile (n:m Beziehung)\nCREATE TABLE maschinen_ersatzteile (\n    maschinen_id INTEGER,\n    ersatzteil_id INTEGER,\n    menge_pro_wartung INTEGER,\n    PRIMARY KEY (maschinen_id, ersatzteil_id),\n    FOREIGN KEY (maschinen_id) REFERENCES maschinen(maschinen_id)\n        ON DELETE CASCADE,\n    FOREIGN KEY (ersatzteil_id) REFERENCES ersatzteile(ersatzteil_id)\n        ON DELETE CASCADE\n);\n\n-- Tabelle: Lager (NEU f\u00fcr Transaktions\u00fcbungen)\nCREATE TABLE lager (\n    lager_id SERIAL PRIMARY KEY,\n    standort VARCHAR(100) NOT NULL,\n    ersatzteil_id INTEGER REFERENCES ersatzteile(ersatzteil_id),\n    bestand INTEGER NOT NULL CHECK (bestand &gt;= 0)\n);\n\n-- Testdaten: Maschinen\nINSERT INTO maschinen VALUES\n(1, 'CNC-Fraese Alpha', 'CNC-Fraese', 'M-CNC-001', 'Halle A', 2020, 'Aktiv', 90),\n(2, 'Drehbank Delta', 'Drehbank', 'M-DRE-002', 'Halle A', 2018, 'Aktiv', 120),\n(3, 'Presse Gamma', 'Presse', 'M-PRE-003', 'Halle B', 2019, 'Aktiv', 60),\n(4, 'Schweissroboter Beta', 'Schweissroboter', 'M-SCH-004', 'Halle C', 2021, 'Aktiv', 90);\n\n-- Testdaten: Produktionsauftr\u00e4ge\nINSERT INTO produktionsauftraege VALUES\n(1, 'AUF-2024-001', 'BMW AG', 'Getriebegeh\u00e4use', 500, '2024-04-01', '2024-04-15', NULL, 'In Produktion', 1),\n(2, 'AUF-2024-002', 'Audi AG', 'Kurbelwelle', 200, '2024-04-10', '2024-04-20', NULL, 'In Produktion', 2),\n(3, 'AUF-2024-003', 'Mercedes-Benz', 'Pleuelstange', 350, '2024-04-05', '2024-04-18', '2024-04-17', 'In Produktion', 2),\n(4, 'AUF-2024-004', 'Porsche AG', 'Kolben', 150, '2024-04-12', '2024-04-25', NULL, 'In Vorbereitung', 4),\n(5, 'AUF-2024-005', 'BMW AG', 'Kurbelwelle', 300, '2024-04-15', '2024-04-22', NULL, 'In Produktion', 2),\n(6, 'AUF-2024-006', 'Volkswagen AG', 'Kolben', 400, '2024-04-20', '2024-04-28', NULL, 'In Vorbereitung', 1),\n(7, 'AUF-2024-009', 'Porsche AG', 'Kurbelwelle', 120, '2024-04-28', '2024-05-05', NULL, 'In Vorbereitung', 2),\n(8, 'AUF-2024-010', 'BMW AG', 'Kolben', 350, '2024-04-12', '2024-04-19', NULL, 'In Produktion', 4);\n\n-- Testdaten: Wartungsprotokolle\nINSERT INTO wartungsprotokolle (wartungsdatum, beschreibung, techniker, kosten, maschinen_id) VALUES\n('2024-01-15', 'Routinewartung - \u00d6lwechsel und Filter', 'Thomas Weber', 450.00, 1),\n('2024-02-20', 'Austausch Hydraulikschl\u00e4uche', 'Anna Schmidt', 320.00, 4),\n('2024-03-10', 'Software-Update CNC-Steuerung', 'Thomas Weber', 180.00, 2),\n('2024-03-22', 'Inspektion nach 5000 Betriebsstunden', 'Michael Klein', 520.00, 3),\n('2024-04-05', 'Reparatur K\u00fchlsystem', 'Anna Schmidt', 890.00, 1);\n\n-- Testdaten: Ersatzteile\nINSERT INTO ersatzteile VALUES\n(1, 'ET-001', 'Hydraulik\u00f6l 10L', 50, 20),\n(2, 'ET-002', '\u00d6lfilter', 30, 15),\n(3, 'ET-003', 'Hydraulikschlauch 2m', 25, 10),\n(4, 'ET-004', 'Dichtungssatz', 40, 12),\n(5, 'ET-005', 'Sicherungsring Set', 100, 30);\n\n-- Testdaten: Maschinen-Ersatzteile (Zuordnung)\nINSERT INTO maschinen_ersatzteile VALUES\n(1, 1, 2),  -- Spritzgussmaschine braucht Hydraulik\u00f6l\n(1, 2, 1),  -- Spritzgussmaschine braucht \u00d6lfilter\n(2, 4, 1),  -- CNC-Fr\u00e4se braucht Dichtungssatz\n(3, 1, 1),  -- Drehmaschine braucht Hydraulik\u00f6l\n(4, 3, 2),  -- Presse braucht Hydraulikschl\u00e4uche\n(4, 4, 1);  -- Presse braucht Dichtungssatz\n\n-- Testdaten: Lager (f\u00fcr Transaktions\u00fcbungen)\nINSERT INTO lager (standort, ersatzteil_id, bestand) VALUES\n('Hauptlager', 1, 100),\n('Hauptlager', 2, 80),\n('Hauptlager', 3, 60),\n('Produktionslager', 1, 50),\n('Produktionslager', 2, 40),\n('Produktionslager', 3, 30);\n</code></pre> Aufgabe 1: Ersatzteile-Transfer zwischen Lagern <p>Transferiere 20 Einheiten eines Ersatzteils vom Hauptlager ins Produktionslager mit einer Transaktion.</p> <p>Anforderungen:</p> <ul> <li>W\u00e4hle ein beliebiges Ersatzteil</li> <li>Reduziere Bestand im Hauptlager um 20</li> <li>Erh\u00f6he Bestand im Produktionslager um 20</li> <li>Verwende BEGIN und COMMIT</li> </ul> Aufgabe 2: Produktionsauftrag mit Maschinenpr\u00fcfung <p>Erstelle einen neuen Produktionsauftrag und weise ihm eine Maschine zu. Wenn die Maschine bereits einen aktiven Auftrag hat, soll die Transaktion abgebrochen werden.</p> <p>Anforderungen:</p> <ul> <li>Pr\u00fcfe, ob die Maschine verf\u00fcgbar ist (kein aktiver Auftrag mit status = 'in_produktion')</li> <li>Erstelle nur dann einen neuen Auftrag</li> <li>Verwende ROLLBACK, wenn die Maschine nicht verf\u00fcgbar ist</li> </ul> Aufgabe 3: SAVEPOINT f\u00fcr komplexe Wartung <p>F\u00fchre eine komplexe Wartung mit mehreren Schritten durch. Verwende SAVEPOINT, um nur einen Teil r\u00fcckg\u00e4ngig zu machen.</p> <p>Szenario:</p> <ul> <li>Wartung beginnen und Kosten f\u00fcr Grundinspektion erfassen</li> <li>SAVEPOINT setzen</li> <li>Zus\u00e4tzliche Reparatur erfassen</li> <li>SAVEPOINT setzen</li> <li>Dritte Reparatur (zu teuer!) \u2192 zur\u00fcck zum zweiten SAVEPOINT</li> </ul> Aufgabe 4: Automatisches ROLLBACK bei Constraint-Verletzung <p>Versuche, mehr Ersatzteile aus dem Lager zu entnehmen, als vorhanden sind. Beobachte das automatische ROLLBACK.</p> <p>Anforderungen:</p> <ul> <li>Starte eine Transaktion</li> <li>Versuche, 200 Einheiten zu entnehmen (obwohl nur z.B. 100 vorhanden sind)</li> <li>Beobachte die Fehlermeldung</li> <li>\u00dcberpr\u00fcfe, dass keine \u00c4nderungen gespeichert wurden</li> </ul>"},{"location":"database/transaktionen/#zusammenfassung","title":"Zusammenfassung \ud83d\udccc","text":"<ul> <li>Eine Transaktion ist eine Gruppe von Operationen, die entweder vollst\u00e4ndig ausgef\u00fchrt oder vollst\u00e4ndig r\u00fcckg\u00e4ngig gemacht wird</li> <li><code>BEGIN</code> startet eine Transaktion</li> <li><code>COMMIT</code> speichert alle \u00c4nderungen dauerhaft</li> <li><code>ROLLBACK</code> verwirft alle \u00c4nderungen seit BEGIN</li> <li>Bei Fehlern f\u00fchrt PostgreSQL automatisch ein ROLLBACK durch</li> <li>Die ACID-Prinzipien garantieren:<ul> <li>Atomicity: Alles oder nichts</li> <li>Consistency: Datenbank bleibt konsistent</li> <li>Isolation: Transaktionen laufen unabh\u00e4ngig</li> <li>Durability: \u00c4nderungen bleiben dauerhaft erhalten</li> </ul> </li> <li><code>SAVEPOINT</code> erm\u00f6glicht teilweise Rollbacks innerhalb einer Transaktion</li> <li>Transaktionen sind besonders wichtig bei kritischen Operationen wie Lagertransfers, Maschinenregistrierungen oder anderen zusammenh\u00e4ngenden \u00c4nderungen</li> </ul> <p>Im n\u00e4chsten und letzten Kapitel werfen wir einen Ausblick auf weiterf\u00fchrende Themen wie Views, Stored Procedures und NoSQL-Datenbanken.</p>"}]}